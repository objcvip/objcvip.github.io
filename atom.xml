<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OBJC.VIP</title>
  <icon>https://www.gravatar.com/avatar/7f3b33261dd48600587207c66a04554c</icon>
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://objcvip.github.io/"/>
  <updated>2020-02-20T09:45:50.867Z</updated>
  <id>https://objcvip.github.io/</id>
  
  <author>
    <name>ObjC.vip</name>
    <email>objcvip@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《三年高考五年模拟》系列之好未来篇</title>
    <link href="https://objcvip.github.io/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A5%BD%E6%9C%AA%E6%9D%A5%E7%AF%87/"/>
    <id>https://objcvip.github.io/《三年高考五年模拟》系列之好未来篇/</id>
    <published>2020-02-20T09:40:00.000Z</published>
    <updated>2020-02-20T09:45:50.867Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在问面试题时，我们究竟在问什么？<strong>OBJC.VIP</strong> 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到<a href="mailto:objcvip@163.com" target="_blank" rel="noopener">objcvip@163.com</a>斧正。本期带来《三年高考五年模拟》系列之好未来篇。<br><a id="more"></a></p><p>题目链接：<a href="https://objc.vip/好未来面试题/" target="_blank" rel="noopener">好未来面试题</a></p><h2 id="1-一面"><a href="#1-一面" class="headerlink" title="1. 一面"></a>1. 一面</h2><p>1、说一下optional。（？ ！ ？？ 几种解包方式 if let、guard、？？等）</p><p>2、说一下闭包。</p><p>3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？( KVO 效率最低，因为 Runtime ）</p><p>4、NSString 和 String 的区别？（ String 是值类型，NSString 是引用类型）</p><p>5、Swift 跟 OC 的区别？（ OC 是动态的语言，Swift 是静态的语言）OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？</p><p>6、说一下 MRC ？自动释放池？自动释放池什么时候释放？（我说 drain ）</p><p>7、说一下多线程？（我提到了 dispatch_once 单例）</p><p>8、分别用 OC 和 Swift 手写一下单例。（ Swift 的单例我忘记写 static 了，但是经提醒立马说出来了）</p><p>9、SnaptKit 内部看过吗？</p><p>10、链式语法的实现。</p><p>UIView.top.equalTo().offSet(10)</p><p>UIView.left.equalTo().offSet(10)</p><p>为什么能写成UIView.top.left.offSet(10)</p><h2 id="2-二面"><a href="#2-二面" class="headerlink" title="2. 二面"></a>2. 二面</h2><p>主要是手写算法题：</p><p>1、用两个栈实现队列。</p><p>2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。</p><h2 id="3-三面"><a href="#3-三面" class="headerlink" title="3. 三面"></a>3. 三面</h2><p>项目经理聊项目</p><h2 id="4-四面"><a href="#4-四面" class="headerlink" title="4. 四面"></a>4. 四面</h2><p>HR问了很多问题，包括个人优缺点，在前公司3年的成长等等。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在问面试题时，我们究竟在问什么？&lt;strong&gt;OBJC.VIP&lt;/strong&gt; 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到&lt;a href=&quot;mailto:objcvip@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objcvip@163.com&lt;/a&gt;斧正。本期带来《三年高考五年模拟》系列之好未来篇。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="《三年高考五年模拟》" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="三年高考五年模拟" scheme="https://objcvip.github.io/tags/%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>《三年高考五年模拟》系列之微店篇</title>
    <link href="https://objcvip.github.io/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E5%BE%AE%E5%BA%97%E7%AF%87/"/>
    <id>https://objcvip.github.io/《三年高考五年模拟》系列之微店篇/</id>
    <published>2020-02-20T09:29:00.000Z</published>
    <updated>2020-02-20T09:32:36.045Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在问面试题时，我们究竟在问什么？<strong>OBJC.VIP</strong> 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到<a href="mailto:objcvip@163.com" target="_blank" rel="noopener">objcvip@163.com</a>斧正。本期带来《三年高考五年模拟》系列之微店篇。<br><a id="more"></a></p><p>题目链接：<a href="https://objc.vip/微店面试题/" target="_blank" rel="noopener">微店面试题</a></p><h2 id="1-一面"><a href="#1-一面" class="headerlink" title="1. 一面"></a>1. 一面</h2><p>1、说项目里的有价值的东西？</p><p>2、HTTPS 过程是怎么样的？非对称加密</p><p>3、Swift 中逃逸闭包和非逃逸闭包的区别？</p><p>4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？</p><p>5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？</p><p>6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？</p><p>7、GCD 内部实现？</p><p>8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？</p><p>9、KVO 的原理？具体 NSObject 的两个方法？</p><p>10、消息转发流程？使用场景？</p><p>11、数据库减字段怎么容错？</p><p>12、有没有打包过私有库？</p><p>13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？</p><p>14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？</p><p>15、说一下一个项目的架构？</p><p>16、组件化？</p><p>17、手写冒泡排序算法？算法复杂度？</p><h2 id="2-二面"><a href="#2-二面" class="headerlink" title="2. 二面"></a>2. 二面</h2><p>1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？</p><p>2、写一下其中一个项目的项目架构？写一下用到的第三方库。</p><p>3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？</p><p>4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？</p><p>5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？</p><p>6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图）</p><p>7、加密算法，对称加密和非对称加密？</p><p>8、如何理解 OC 是动态语言？</p><p>9、Runtime？用 Runtime 做过什么？</p><p>10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？</p><p>11、内存管理？内存优化？</p><p>12、卡顿？</p><p>13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d）</p><p>14、从点击 App 图标，到显示界面流程？</p><p>15、组件化？</p><p>16、编译过程？某一个东西是属于哪一步骤的？</p><p>17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图）</p><p>18、RN、Week？内部是怎么用 JS 调用原生的？</p><p>19、日志记录？</p><p>20、遇到的闪退？Bug？</p><p>21、竞争同一个资源？</p><p>22、进程线程与 App 的关系。</p><p>23、Git rebase</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在问面试题时，我们究竟在问什么？&lt;strong&gt;OBJC.VIP&lt;/strong&gt; 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到&lt;a href=&quot;mailto:objcvip@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objcvip@163.com&lt;/a&gt;斧正。本期带来《三年高考五年模拟》系列之微店篇。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="《三年高考五年模拟》" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="三年高考五年模拟" scheme="https://objcvip.github.io/tags/%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>《三年高考五年模拟》系列之美团篇</title>
    <link href="https://objcvip.github.io/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E7%BE%8E%E5%9B%A2%E7%AF%87/"/>
    <id>https://objcvip.github.io/《三年高考五年模拟》系列之美团篇/</id>
    <published>2020-02-20T09:27:00.000Z</published>
    <updated>2020-02-20T09:27:45.146Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在问面试题时，我们究竟在问什么？<strong>OBJC.VIP</strong> 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到<a href="mailto:objcvip@163.com" target="_blank" rel="noopener">objcvip@163.com</a>斧正。本期带来《三年高考五年模拟》系列之美团篇。<br><a id="more"></a></p><p>题目链接：<a href="https://objc.vip/美团面试题/" target="_blank" rel="noopener">美团面试题</a></p><h2 id="1、Block-的底层原理，结构，内存以及需要注意的地方。"><a href="#1、Block-的底层原理，结构，内存以及需要注意的地方。" class="headerlink" title="1、Block 的底层原理，结构，内存以及需要注意的地方。"></a>1、Block 的底层原理，结构，内存以及需要注意的地方。</h2><h2 id="2、图片渲染，一张-png-jpg-格式的图片渲染到页面上显示有哪些流程。png-和-jpg-的区别。png-一定是无损的吗？"><a href="#2、图片渲染，一张-png-jpg-格式的图片渲染到页面上显示有哪些流程。png-和-jpg-的区别。png-一定是无损的吗？" class="headerlink" title="2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？"></a>2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？</h2><h2 id="3、Runtime。"><a href="#3、Runtime。" class="headerlink" title="3、Runtime。"></a>3、Runtime。</h2><h2 id="4、Runloop-的结构和循环流程，用-Runloop-做过什么事情。"><a href="#4、Runloop-的结构和循环流程，用-Runloop-做过什么事情。" class="headerlink" title="4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。"></a>4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。</h2><h2 id="5、多线程，NSOperationQueue-和-GCD-的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。"><a href="#5、多线程，NSOperationQueue-和-GCD-的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。" class="headerlink" title="5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。"></a>5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。</h2><h2 id="6、NSURLSession-和-NSURLConnection-的区别，-NSURLConnection-是怎么封装的。CFNetwork。"><a href="#6、NSURLSession-和-NSURLConnection-的区别，-NSURLConnection-是怎么封装的。CFNetwork。" class="headerlink" title="6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。"></a>6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。</h2><h2 id="7、做过什么动画。"><a href="#7、做过什么动画。" class="headerlink" title="7、做过什么动画。"></a>7、做过什么动画。</h2><h2 id="8、HTTPS-的工作原理，和-HTTP-的区别。RSA-加密原理。"><a href="#8、HTTPS-的工作原理，和-HTTP-的区别。RSA-加密原理。" class="headerlink" title="8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。"></a>8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。</h2><h2 id="9、网络层级，TCP-和-UDP-的区别。"><a href="#9、网络层级，TCP-和-UDP-的区别。" class="headerlink" title="9、网络层级，TCP 和 UDP 的区别。"></a>9、网络层级，TCP 和 UDP 的区别。</h2><h2 id="10、SDWebImage-的框架结构，缓存机制。"><a href="#10、SDWebImage-的框架结构，缓存机制。" class="headerlink" title="10、SDWebImage 的框架结构，缓存机制。"></a>10、SDWebImage 的框架结构，缓存机制。</h2><h2 id="11、Git-的-rebase-的原理。Git-流程。"><a href="#11、Git-的-rebase-的原理。Git-流程。" class="headerlink" title="11、Git 的 rebase 的原理。Git 流程。"></a>11、Git 的 rebase 的原理。Git 流程。</h2><h2 id="12、对组件化的了解，组件化是为了解决什么问题。"><a href="#12、对组件化的了解，组件化是为了解决什么问题。" class="headerlink" title="12、对组件化的了解，组件化是为了解决什么问题。"></a>12、对组件化的了解，组件化是为了解决什么问题。</h2><h2 id="13、JSPatch-的原理。"><a href="#13、JSPatch-的原理。" class="headerlink" title="13、JSPatch 的原理。"></a>13、JSPatch 的原理。</h2><h2 id="14、单例是为了处理什么问题而使用的，单例和全局变量的区别。"><a href="#14、单例是为了处理什么问题而使用的，单例和全局变量的区别。" class="headerlink" title="14、单例是为了处理什么问题而使用的，单例和全局变量的区别。"></a>14、单例是为了处理什么问题而使用的，单例和全局变量的区别。</h2><h2 id="15、对设计模式的掌握。"><a href="#15、对设计模式的掌握。" class="headerlink" title="15、对设计模式的掌握。"></a>15、对设计模式的掌握。</h2><h2 id="16、分层打印二叉树。"><a href="#16、分层打印二叉树。" class="headerlink" title="16、分层打印二叉树。"></a>16、分层打印二叉树。</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在问面试题时，我们究竟在问什么？&lt;strong&gt;OBJC.VIP&lt;/strong&gt; 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到&lt;a href=&quot;mailto:objcvip@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objcvip@163.com&lt;/a&gt;斧正。本期带来《三年高考五年模拟》系列之美团篇。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="《三年高考五年模拟》" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="三年高考五年模拟" scheme="https://objcvip.github.io/tags/%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>《三年高考五年模拟》系列之滴滴出行篇</title>
    <link href="https://objcvip.github.io/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E6%BB%B4%E6%BB%B4%E5%87%BA%E8%A1%8C%E7%AF%87/"/>
    <id>https://objcvip.github.io/《三年高考五年模拟》系列之滴滴出行篇/</id>
    <published>2020-02-20T09:06:00.000Z</published>
    <updated>2020-02-20T09:45:58.370Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在问面试题时，我们究竟在问什么？<strong>OBJC.VIP</strong> 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到<a href="mailto:objcvip@163.com" target="_blank" rel="noopener">objcvip@163.com</a>斧正。本期带来《三年高考五年模拟》系列之滴滴出行篇。<br><a id="more"></a></p><p>题目链接：</p><p><a href="https://objc.vip/滴滴笔试题/" target="_blank" rel="noopener">滴滴笔试题</a></p><p><a href="https://objc.vip/滴滴面试题/" target="_blank" rel="noopener">滴滴面试题</a></p><h2 id="1-笔试题"><a href="#1-笔试题" class="headerlink" title="1. 笔试题"></a>1. 笔试题</h2><p>0.姓名？日期。</p><p>1.C语言实现字符串反转：<code>void reverse(char *str, int length) {}</code></p><p>2.实现一个字符串数组去重函数。</p><p>3.描述OC中对象的实现原理。</p><p>4.编写代码，实现 NSObject 中添加一个属性 p1</p><p>5.KVO 的实现原理和注意事项。</p><p>6.下面的代码有哪些问题？</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Demo</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">BOOL</span> *p1;</span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *p2;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Demo</span></span></span><br><span class="line"><span class="hljs-keyword">@dynamic</span> p1;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)setP2:(<span class="hljs-built_in">NSString</span> *)p2;</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">self</span>.p1 = <span class="hljs-literal">YES</span>;</span><br><span class="line"><span class="hljs-keyword">self</span>.p2 = p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>7.JS 和 Native 的通讯方式。</p><p>8.网络5层模型是哪5层？</p><p>9.把t1表中 name 为 mike 的记录中 status 值改为1</p><p>10.常用的 Linux 命令。</p><p>11.用过的包/库管理工具。</p><h2 id="2-一面"><a href="#2-一面" class="headerlink" title="2. 一面"></a>2. 一面</h2><p>1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？</p><p>2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？</p><p>3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？</p><p>4、你觉得自己是什么级别的？优势和不足主要是哪方面？</p><p>5、GCD 平时项目里怎么用的？我提到了回到主线程操作 UI 需要 dispatch_get_mainQueue</p><p>6、为什么操作 UI 需要在主线程？</p><p>7、哪些是你独立开发的项目？</p><p>8、问了一下上家公司的情况</p><p>9、之后有什么打算？</p><p>10、上家薪资多少？你还有啥想问的吗？</p><h2 id="3-二面"><a href="#3-二面" class="headerlink" title="3. 二面"></a>3. 二面</h2><p>1、自定义封装控件需要注意什么？有什么规范？</p><p>2、说一下你了解的设计模式。</p><p>3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？</p><p>4、内存优化是怎么做的？我提到了内存泄漏。什么情况会发生内存泄漏？</p><p>5、App 启动时间优化？</p><p>6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？</p><p>7、AFNetworking 内部是怎么样的一个过程？</p><p>8、你还有什么想问我的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在问面试题时，我们究竟在问什么？&lt;strong&gt;OBJC.VIP&lt;/strong&gt; 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到&lt;a href=&quot;mailto:objcvip@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objcvip@163.com&lt;/a&gt;斧正。本期带来《三年高考五年模拟》系列之滴滴出行篇。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="《三年高考五年模拟》" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="三年高考五年模拟" scheme="https://objcvip.github.io/tags/%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>《三年高考五年模拟》系列之苏宁篇</title>
    <link href="https://objcvip.github.io/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B%E7%B3%BB%E5%88%97%E4%B9%8B%E8%8B%8F%E5%AE%81%E7%AF%87/"/>
    <id>https://objcvip.github.io/《三年高考五年模拟》系列之苏宁篇/</id>
    <published>2020-02-20T07:47:00.000Z</published>
    <updated>2020-02-20T09:21:24.746Z</updated>
    
    <content type="html"><![CDATA[<p>当我们在问面试题时，我们究竟在问什么？<strong>OBJC.VIP</strong> 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到<a href="mailto:objcvip@163.com" target="_blank" rel="noopener">objcvip@163.com</a>斧正。本期带来《三年高考五年模拟》系列之苏宁篇。<br><a id="more"></a></p><p>题目链接：<a href="https://objc.vip/苏宁面试题/" target="_blank" rel="noopener">苏宁面试题</a></p><h2 id="1-笔试题"><a href="#1-笔试题" class="headerlink" title="1. 笔试题"></a>1. 笔试题</h2><h3 id="1-1-冒泡排序"><a href="#1-1-冒泡排序" class="headerlink" title="1.1 冒泡排序"></a>1.1 冒泡排序</h3><p>Objective-C 实现如下：<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (void)bubbleSort:(NSMutableArray *)array &#123;</span><br><span class="line">  for (int i = 0; i &lt; array.count; i++)</span><br><span class="line">  &#123;</span><br><span class="line">    for (int j = 0; j &lt; array.count-1-i; j++)</span><br><span class="line">    &#123;</span><br><span class="line">      NSInteger left = [array[j] integerValue];</span><br><span class="line">      NSInteger right = [array[j+1] integerValue];</span><br><span class="line">      if (left &lt; right) &#123;</span><br><span class="line">        [array exchangeObjectAtIndex:j withObjectAtIndex:j+1];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  NSLog(@&quot;%@&quot;,array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://objc.vip/冒泡排序/" target="_blank" rel="noopener">【算法】冒泡排序</a></p><h3 id="1-2-二分查找"><a href="#1-2-二分查找" class="headerlink" title="1.2 二分查找"></a>1.2 二分查找</h3><p>Swift实现如下：<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binarySearch</span>&lt;T: comparable&gt;<span class="hljs-params">(_a: [T], key: T)</span></span> -&gt; <span class="hljs-type">Int</span>? &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> lowerBound = <span class="hljs-number">0</span></span><br><span class="line">  <span class="hljs-keyword">var</span> upperBound = a.<span class="hljs-built_in">count</span></span><br><span class="line">  <span class="hljs-keyword">while</span> lowerBound &lt; upperBound &#123;</span><br><span class="line">    <span class="hljs-keyword">let</span> midIndex = lowerBound + (upperBound - lowerBound) / <span class="hljs-number">2</span></span><br><span class="line">    <span class="hljs-keyword">if</span> a[midIndex] == key &#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> midIndex</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a[midIndex] &lt; key &#123;</span><br><span class="line">      lowerBound = midIndex + <span class="hljs-number">1</span></span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">      upperBound = midIndex</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="https://objc.vip/二分查找/" target="_blank" rel="noopener">【算法】二分查找</a></p><h3 id="1-3-合并两个数组去重"><a href="#1-3-合并两个数组去重" class="headerlink" title="1.3 合并两个数组去重"></a>1.3 合并两个数组去重</h3><p>参考链接：<a href="https://objc.vip/合并两个数组并去重/" target="_blank" rel="noopener">【算法】合并两个数组并去重</a></p><h3 id="1-4-两个大数相加"><a href="#1-4-两个大数相加" class="headerlink" title="1.4 两个大数相加"></a>1.4 两个大数相加</h3><p>参考链接：<a href="https://www.jianshu.com/p/fdeb84644b50" target="_blank" rel="noopener">大数相加算法</a></p><h2 id="2-一面"><a href="#2-一面" class="headerlink" title="2. 一面"></a>2. 一面</h2><h3 id="2-1-SDWebImage-的缓存机制？LRU-说一下。"><a href="#2-1-SDWebImage-的缓存机制？LRU-说一下。" class="headerlink" title="2.1 SDWebImage 的缓存机制？LRU 说一下。"></a>2.1 SDWebImage 的缓存机制？LRU 说一下。</h3><p>SDWebImage加载图片拿到url会先把url的MD5值作为key从内存中查找，如果内存中有，则直接取图片显示；如果内存中没有，会从磁盘中查找。磁盘中没有，会走下载流程。<br>LRU 最近最少使用。缓存容量满时，会先清理最近最少的缓存。</p><h3 id="2-2-数据库升级，比如从-1-0-升级到-2-0，增加了字段。"><a href="#2-2-数据库升级，比如从-1-0-升级到-2-0，增加了字段。" class="headerlink" title="2.2 数据库升级，比如从 1.0 升级到 2.0，增加了字段。"></a>2.2 数据库升级，比如从 1.0 升级到 2.0，增加了字段。</h3><p>做好兼容处理。</p><h3 id="2-3-性能优化"><a href="#2-3-性能优化" class="headerlink" title="2.3 性能优化"></a>2.3 性能优化</h3><h4 id="2-3-1-优化启动时间"><a href="#2-3-1-优化启动时间" class="headerlink" title="2.3.1 优化启动时间"></a>2.3.1 优化启动时间</h4><ol><li>将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。</li><li>不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。</li><li>减少动态库、合并动态库，定期清理不必要的动态库。</li><li>减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。</li><li>将不必须在+load中做的事延时到+initialize中。</li></ol><h4 id="2-3-2-减少CPU、GPU资源消耗"><a href="#2-3-2-减少CPU、GPU资源消耗" class="headerlink" title="2.3.2 减少CPU、GPU资源消耗"></a>2.3.2 减少CPU、GPU资源消耗</h4><ol><li>cell复用，header、footer复用。</li><li>尽量把view设置不透明。</li><li>减少视图的层级。</li><li>尽量避免调整视图层次、添加和移除视图。</li><li>合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。</li><li>图片大小最好和UIImageView的大小相同。</li><li>不要阻塞主线程，耗时操作放在子线程进行。</li><li>懒加载。</li><li>缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。</li><li>复用高开销对象NSDateFormatter和NSCalendar。</li><li>减少离屏渲染，优化圆角、阴影。</li><li>使用正确的数据存储。</li></ol><h4 id="2-3-3-内存优化"><a href="#2-3-3-内存优化" class="headerlink" title="2.3.3 内存优化"></a>2.3.3 内存优化</h4><ol><li>减少内存泄漏。</li><li>降低内存使用峰值。<ul><li>懒加载。</li><li>灵活运用图片和文件加载。</li><li>拉长文件处理机制，逐步处理文件。</li></ul></li></ol><h4 id="2-3-4-耗电优化"><a href="#2-3-4-耗电优化" class="headerlink" title="2.3.4 耗电优化"></a>2.3.4 耗电优化</h4><p>耗电功率是个比较综合的指标，影响因素很多。密集的网络请求，长链接，密集的CPU操作（比如大量的复杂计算）都会使耗电功率增加。网络状况（流畅的Wi-Fi还是信号不好的3G）都会影响。</p><ol><li>优化网络。<ul><li>减少、压缩网络数据。</li><li>若多次网络请求结果相同，尽量使用缓存。</li><li>网络不可用时，不进行网络请求。</li></ul></li><li>优化CPU、GPU消耗。</li><li>优化I/O操作，使用dispatch_io。</li><li>定位优化<ul><li>尽量降低定位精度，如不要使用精度最高的KCLLocationAccuracyBest。</li><li>如果只是需要快速确定用户位置，用 CLLocationManager 的 requestLocation 方法定位，定位完成后，定位硬件会自动断电。</li></ul></li></ol><h3 id="2-4-Git-开发流程。"><a href="#2-4-Git-开发流程。" class="headerlink" title="2.4 Git 开发流程。"></a>2.4 Git 开发流程。</h3><ul><li>master </li><li>develop</li><li>dev-xx 具体开发人员分支</li></ul><p>开发完成后发起PR。项目提审打Tag</p><h3 id="2-5-微信登录流程。"><a href="#2-5-微信登录流程。" class="headerlink" title="2.5 微信登录流程。"></a>2.5 微信登录流程。</h3><p>注册微信的AppKey与AppSecret。使用微信SDK方法调起微信，回调拿到一些参数，把包含openId等协定好的参数传给服务器，由服务器判断该用户是否注册过，如果注册过，返回登录成功后的用户相关信息。</p><h3 id="2-6-WebView-与-JS-交互。"><a href="#2-6-WebView-与-JS-交互。" class="headerlink" title="2.6 WebView 与 JS 交互。"></a>2.6 WebView 与 JS 交互。</h3><p>H5调用原生采用拦截协议的方式。<br>执行JS方法：evaluateScript<br>也可以使用JSBridge等方式。</p><h3 id="2-7-说一下Runloop，苹果设计-Runloop-的初衷是什么？"><a href="#2-7-说一下Runloop，苹果设计-Runloop-的初衷是什么？" class="headerlink" title="2.7 说一下Runloop，苹果设计 Runloop 的初衷是什么？"></a>2.7 说一下Runloop，苹果设计 Runloop 的初衷是什么？</h3><p>Runloop 运行循环。<br>让线程在有任务的时候忙任务，没任务的时候休眠。<br>参考链接：<a href="https://objc.vip/RunloopSummary/" target="_blank" rel="noopener">【iOS 开发】RunLoop 总结</a></p><h3 id="2-8-Delegate"><a href="#2-8-Delegate" class="headerlink" title="2.8 Delegate"></a>2.8 Delegate</h3><p>代理用assign修饰。</p><h3 id="2-9-GCD"><a href="#2-9-GCD" class="headerlink" title="2.9 GCD"></a>2.9 GCD</h3><p>参考链接：<a href="https://www.jianshu.com/p/93cecfd5fc89" target="_blank" rel="noopener">GCD 的 API</a></p><h3 id="2-10-深拷贝与浅拷贝"><a href="#2-10-深拷贝与浅拷贝" class="headerlink" title="2.10 深拷贝与浅拷贝"></a>2.10 深拷贝与浅拷贝</h3><p>深拷贝是拷贝整个对象。<br>浅拷贝只拷贝对象的指针。<br>copy用于修饰NSArray、NSDictionary、NSString。如果=右边赋值的对象是可变的，copy是深拷贝，拷贝对象的本身。如果赋值的对象是不可变的，copy是浅拷贝，只拷贝对象的指针。<br>用copy和用strong的区别？<br>用copy更安全，避免赋的值是可变的。如果能确保赋的值是不可变的，那么用strong和用copy都是浅拷贝，copy只是多了一个判断，判断可变还是不可变，其他是一样的。<br>NSMutableArray、NSMutableDictionary用Strong修饰，如果用copy，就会拷贝一份，变成不可变的，如果增删数据，就会发生错误。</p><h3 id="2-11-进程间通信"><a href="#2-11-进程间通信" class="headerlink" title="2.11 进程间通信"></a>2.11 进程间通信</h3><p>URL Schemes</p><h3 id="2-12-线程间通信，两个线程怎么切换？"><a href="#2-12-线程间通信，两个线程怎么切换？" class="headerlink" title="2.12 线程间通信，两个线程怎么切换？"></a>2.12 线程间通信，两个线程怎么切换？</h3><p>performSelectorOnThread</p><h3 id="2-13-多态"><a href="#2-13-多态" class="headerlink" title="2.13 多态"></a>2.13 多态</h3><p>多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。<br>子类继承父类后，子类重写父类的方法，实现多态。</p><h3 id="2-14-HTTP-三次握手，四次挥手。"><a href="#2-14-HTTP-三次握手，四次挥手。" class="headerlink" title="2.14 HTTP 三次握手，四次挥手。"></a>2.14 HTTP 三次握手，四次挥手。</h3><h2 id="3-二面"><a href="#3-二面" class="headerlink" title="3. 二面"></a>3. 二面</h2><h3 id="3-1-有没有复杂点的页面。"><a href="#3-1-有没有复杂点的页面。" class="headerlink" title="3.1 有没有复杂点的页面。"></a>3.1 有没有复杂点的页面。</h3><h3 id="3-2-（这个部门是做智能硬件的）蓝牙有哪些API。"><a href="#3-2-（这个部门是做智能硬件的）蓝牙有哪些API。" class="headerlink" title="3.2 （这个部门是做智能硬件的）蓝牙有哪些API。"></a>3.2 （这个部门是做智能硬件的）蓝牙有哪些API。</h3><h3 id="3-3-播放音频，展示音频的曲线，具体怎么做？"><a href="#3-3-播放音频，展示音频的曲线，具体怎么做？" class="headerlink" title="3.3 播放音频，展示音频的曲线，具体怎么做？"></a>3.3 播放音频，展示音频的曲线，具体怎么做？</h3><h2 id="4-三面"><a href="#4-三面" class="headerlink" title="4. 三面"></a>4. 三面</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们在问面试题时，我们究竟在问什么？&lt;strong&gt;OBJC.VIP&lt;/strong&gt; 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到&lt;a href=&quot;mailto:objcvip@163.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;objcvip@163.com&lt;/a&gt;斧正。本期带来《三年高考五年模拟》系列之苏宁篇。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="《三年高考五年模拟》" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/%E3%80%8A%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F%E3%80%8B/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="三年高考五年模拟" scheme="https://objcvip.github.io/tags/%E4%B8%89%E5%B9%B4%E9%AB%98%E8%80%83%E4%BA%94%E5%B9%B4%E6%A8%A1%E6%8B%9F/"/>
    
  </entry>
  
  <entry>
    <title>面试题交流（2019.10.16）</title>
    <link href="https://objcvip.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98%E4%BA%A4%E6%B5%8120191016/"/>
    <id>https://objcvip.github.io/面试题交流20191016/</id>
    <published>2020-02-19T02:43:00.000Z</published>
    <updated>2020-02-20T10:28:40.728Z</updated>
    
    <content type="html"><![CDATA[<p>面试题交流</p><a id="more"></a><p>1、<code>Block</code>的实质是怎样的？使用<code>Block</code>为何容易产生循环引用？</p><p>2、简单说说怎样利用<code>GCD</code>实现高效的多读单写逻辑?</p><p>3、<code>Runloop</code>为何能做到有事做事，没事休息？</p><p>4、怎么样解决<code>DNS</code>劫持？</p><p>5、系统的<code>UI</code>事件传递机制是怎样的？</p><p>6、<code>KVO</code>实现原理是怎么样的？</p><p>7、简单说说消息传递机制和消息转发流程？</p><p>8、当一个对象<code>obj</code>废弃的时候，指向它的<code>weak</code>指针为何会自动置为<code>nil</code>？</p><p>9、<code>TableView</code>滑动卡顿与离屏渲染问题，如何优化？</p><p>10、分类可以添加哪些内容？实例方法、类方法、协议、属性</p><p>11、<code>iOS</code>持久化方式有哪些？</p><p>12、比较关键词：<code>__weak</code>,<code>__block</code>（或者<code>weak</code>相比<code>assign</code>有什么不同）</p><p>13、数组去重问题？</p><p>14、内存分布与内存管理问题，栈区、堆区、未初始化数据、已初始化数据、代码段</p><p>15、类方法和实例方法区别？</p><p>16、<code>ARC</code>、<code>MRC</code>，有什么区别？有啥优缺点</p><p>17、面向对象在<code>OC</code>的体现?</p><p>18、如何理解<code>OC</code>是动态语言？</p><p>19、<code>iOS13</code>，遇到过没有一些问题？如何处理？</p><p>20、说一下单例的作用是什么？为何不能多次创建对象？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试题交流&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》五</title>
    <link href="https://objcvip.github.io/DataStructurePart5/"/>
    <id>https://objcvip.github.io/DataStructurePart5/</id>
    <published>2019-09-15T15:55:00.000Z</published>
    <updated>2019-09-16T08:59:51.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第6章-树"><a href="#第6章-树" class="headerlink" title="第6章 树"></a>第6章 树</h1><p>树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p><a id="more"></a><h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><blockquote><p>树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p></blockquote><h3 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h3><p>树的结点包含一个数据元素及若干指向其子树的分支。</p><p>结点拥有的子树数称为结点的度（Degree）。度为 0 的结点称为叶结点（Leaf）或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</p><h3 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h3><p>结点的子树的根称为该结点的孩子（Child），相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之前互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p><h3 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h3><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 1 层，则其子树的根就在第 i+1 层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。</p><p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p><p>森林（Forest）是 m（m≥0）棵互不相交的树的集合。</p><p>线性表与树结构</p><table><thead><tr><th style="text-align:center">线性结构</th><th style="text-align:center">树结构</th></tr></thead><tbody><tr><td style="text-align:center">第一个数据元素：无前驱</td><td style="text-align:center">根结点：无双亲，唯一</td></tr><tr><td style="text-align:center">最后一个数据元素：无后继</td><td style="text-align:center">叶结点：无孩子，可以多个</td></tr><tr><td style="text-align:center">中间元素：一个前驱一个后继</td><td style="text-align:center">中间结点：一个双亲多个孩子</td></tr></tbody></table><h2 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h2><p>ADT 树（tree）</p><p>Data</p><p>  树是由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系。</p><p>Operation</p><p>  InitTree(*T):构造空树 T。</p><p>  DestroyTree(*T):销毁树 T。</p><p>  CreateTree(*T, definition):按 definition 中给出树的定义来构造树。</p><p>  ClearTree(*T):若树 T 存在，则将树 T 清为空树。</p><p>  TreeEmpty(*T):若 T 为空树，返回 true，否则返回 false。</p><p>  TreeDepth(T):返回 T 的深度。</p><p>  Root(T):返回树的根结点。</p><p>  Value(T, cur_e):cur_e 是树 T 中一个结点，返回此结点的值。</p><p>  Assign(T, cur_e,value):给树 T 的结点 cur_e 赋值为 value。</p><p>  Parent(T, cur_e):若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。</p><p>  LeftChild(T, cur_e):若 cur_e 是树 T 的非叶结点，则返回它的最左孩子，否则返回空。</p><p>  RightSibling(T, cur_e):若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。</p><p>  InsertChild(<em>T, </em>p, i, c):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 指结点的第 i 棵子树。</p><p>  DeleteChild(<em>T, </em>p, i):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。</p><p>endADT</p><h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器表示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p><p>以下是我们的双亲表示法的结点结构定义代码。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 树的双亲表示法结点结构定义 */</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> TElemType; <span class="hljs-comment">/* 树结点的数据类型，目前暂定为整型 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data; <span class="hljs-comment">/* 结点数据 */</span></span><br><span class="line">  <span class="hljs-keyword">int</span> parent; <span class="hljs-comment">/* 双亲位置 */</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  /* 树结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE]; <span class="hljs-comment">/* 结点数组 */</span></span><br><span class="line">  <span class="hljs-keyword">int</span> r,n;  <span class="hljs-comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125; PTree</span><br></pre></td></tr></table></figure><p>存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适、是否方便，时间复杂度好不好等。</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。</p><p>孩子表示法。把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，放进一个一维数组中。</p><p>以下是我们的孩子表示法的结构定义代码。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 树的孩子表示法结构定义 */</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> /* 孩子结点 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> child;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /* 表头结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /* 树结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE]; <span class="hljs-comment">/* 结点数组 */</span></span><br><span class="line">  <span class="hljs-keyword">int</span> r,n; <span class="hljs-comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p><p>结构定义代码如下。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 树的孩子兄弟表示法结构定义 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">fistchild</span>,*<span class="hljs-title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure><h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树（Binary Tree）是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p><h3 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h3><p>二叉树的特点有：</p><ul><li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者一棵子树都是可以的。</li><li>左子树和右子树是有顺序的，次序不能任意颠倒。</li><li>即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。</li></ul><p>二叉树具有五种基本形态：</p><ol><li>空二叉树。</li><li>只有一个根结点。</li><li>根结点只有左子树。</li><li>根结点只有右子树。</li><li>根结点既有左子树又有右子树。</li></ol><h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><h4 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1. 斜树"></a>1. 斜树</h4><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p><h4 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2. 满二叉树"></a>2. 满二叉树</h4><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层，这样的二叉树称为满二叉树。</p><p>满二叉树的特点有：</p><p>（1）叶子只能出现在最下一层。</p><p>（2）非叶子结点的度一定是 2。</p><p>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。</p><h4 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3. 完全二叉树"></a>3. 完全二叉树</h4><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p><p>完全二叉树的特点：</p><p>（1）叶子结点只能出现在最下两层。</p><p>（2）最下层的叶子一定集中在左部连续位置。</p><p>（3）倒数二层，若有叶子结点，一定都在右部连续位置。</p><p>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</p><p>（5）同样结点的二叉树，完全二叉树的深度最小。</p><p>判断某个二叉树是否是完全二叉树的办法，就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是。</p><h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树的性质1"><a href="#二叉树的性质1" class="headerlink" title="二叉树的性质1"></a>二叉树的性质1</h3><p>性质1：在二叉树的第 i 层上至多有 2<sup>i-1</sup> 个结点（i≥1）。</p><h3 id="二叉树的性质2"><a href="#二叉树的性质2" class="headerlink" title="二叉树的性质2"></a>二叉树的性质2</h3><p>性质2：深度为 k 的二叉树至多有 2<sup>k</sup>-1 个结点（k≥1）。</p><h3 id="二叉树的性质3"><a href="#二叉树的性质3" class="headerlink" title="二叉树的性质3"></a>二叉树的性质3</h3><p>性质3：对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1。</p><h3 id="二叉树的性质4"><a href="#二叉树的性质4" class="headerlink" title="二叉树的性质4"></a>二叉树的性质4</h3><p>性质4：具有 n 个结点的完全二叉树的深度为 ⎣log<sub>2</sub>n⎦+1 ( ⎣x⎦表示不大于 x 的最大整数)。</p><p>注：⎣⎦ 向下取整运算。</p><h3 id="二叉树的性质5"><a href="#二叉树的性质5" class="headerlink" title="二叉树的性质5"></a>二叉树的性质5</h3><p>性质5：如果对于一棵有 n 个结点的完全二叉树（其深度为 ⎣log<sub>2</sub>n⎦+1）的结点按层序编号（从第 1 层到第 ⎣log<sub>2</sub>n⎦+1 层），每层从左到右，对任一结点 i （1≤i≤n）有：</p><ol><li>如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1，则其双亲是结点 ⎣i/2⎦。</li><li>如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。</li><li>如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li></ol><h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h3><p>顺序存储结构一般只用于完全二叉树。</p><h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p><p>以下是我们的二叉链表的结点结构定义代码。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data; <span class="hljs-comment">/* 结点数据 */</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure><h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h3 id="二叉树遍历原理"><a href="#二叉树遍历原理" class="headerlink" title="二叉树遍历原理"></a>二叉树遍历原理</h3><p>二叉树的遍历（traversing biary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p><h3 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h3><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h4><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p><h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h4><p>规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p><h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h4><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p><h4 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4. 层序遍历"></a>4. 层序遍历</h4><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p><h3 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的前序遍历递归算法 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraverse</span> <span class="hljs-params">(BiTree T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (T==<span class="hljs-literal">NULL</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data); <span class="hljs-comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">  PreOrderTraverse (T-&gt;lchild); <span class="hljs-comment">/* 再先序遍历左子树 */</span></span><br><span class="line">  PreOrderTraverse (T-&gt;rchild); <span class="hljs-comment">/* 最后先序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的中序遍历递归算法 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraverse</span> <span class="hljs-params">(BiTree T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (T==<span class="hljs-literal">NULL</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  InOrderTraverse (T-&gt;lchild); <span class="hljs-comment">/* 中序遍历左子树 */</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data); <span class="hljs-comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">  InOrderTraverse (T-&gt;rchild); <span class="hljs-comment">/* 最后中序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的后序遍历递归算法 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraverse</span> <span class="hljs-params">(BiTree T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (T==<span class="hljs-literal">NULL</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  PostOrderTraverse (T-&gt;lchild); <span class="hljs-comment">/* 先后序遍历左子树 */</span></span><br><span class="line">  PostOrderTraverse (T-&gt;rchild); <span class="hljs-comment">/* 再后序遍历右子树 */</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data); <span class="hljs-comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h3><ul><li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li><li>已知前序和后序遍历，是不能唯一确定一棵二叉树的。</li></ul><h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 按前序输入二叉树中结点的值（一个字符） */</span></span><br><span class="line"><span class="hljs-comment">/* #表示空树，构造二叉链表表示二叉树 T。 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBiTree</span> <span class="hljs-params">(BiTree *T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  TElemType ch;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;ch);</span><br><span class="line">  <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'#'</span>)</span><br><span class="line">    *T=<span class="hljs-literal">NULL</span>;</span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="hljs-keyword">if</span> (!*T)</span><br><span class="line">      <span class="hljs-built_in">exit</span> (OVERFLOW);</span><br><span class="line">    (*T)-&gt;data=ch; <span class="hljs-comment">/* 生成根结点 */</span></span><br><span class="line">    CreateBiTree(&amp;(*T)-&gt;lchild); <span class="hljs-comment">/* 构造左子树 */</span></span><br><span class="line">    CreateBiTree(&amp;(*T)-&gt;rchild); <span class="hljs-comment">/* 构造右子树 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h3><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</p><p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做是线索化。</p><h3 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的二叉线索存储结构定义 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">enum</span> <span class="hljs-params">(Link, Thread)</span> PointerTag</span>; <span class="hljs-comment">/* Link==0 表示指向左右孩子指针 Thread==1 表示指向前驱或后继的线索 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> /* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data; <span class="hljs-comment">/* 结点数据 */</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">/* 左右孩子指针 */</span></span><br><span class="line">  PointerTag LTag;</span><br><span class="line">  PointerTag RTag; <span class="hljs-comment">/* 左右标志 */</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure><p>线索化的过程就是在遍历的过程中修改空指针的过程。</p><p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p><h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>将树转换为二叉树的步骤如下</p><ol><li>加线。在所有兄弟结点之间加一条连线。</li><li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li><li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li></ol><h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>步骤如下：</p><ol><li>将每个树转换为二叉树。</li><li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li></ol><h3 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h3><ol><li>加线。</li><li>去线。</li><li>层次调整。</li></ol><h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3><ol><li>从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li><li>再将每棵分离的二叉树转换为树即可。</li></ol><h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><p>树的遍历分为两种方式。</p><ol><li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li><li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li></ol><p>森林的遍历也分为两种方式：</p><ol><li>前序遍历</li><li>后序遍历</li></ol><h2 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h2><h3 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h3><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</p><p>树的路径长度就是从树根到每一个结点的路径长度之和。</p><p>带权路径长度 WPL 最小的二叉树称做赫夫曼树。</p><h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3><p>一般地，设需要编码的字符集为{d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub>}，各个字符在电文中出现的次数或频率集合为 {w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub>}，以 d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub> 作为叶子结点，以 w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub> 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第6章-树&quot;&gt;&lt;a href=&quot;#第6章-树&quot; class=&quot;headerlink&quot; title=&quot;第6章 树&quot;&gt;&lt;/a&gt;第6章 树&lt;/h1&gt;&lt;p&gt;树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&amp;gt;1 时，其余结点可分为 m（m&amp;gt;0）个互不相交的有限集 T&lt;sub&gt;1&lt;/sub&gt;、T&lt;sub&gt;2&lt;/sub&gt;、……、T&lt;sub&gt;m&lt;/sub&gt;，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="https://objcvip.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="https://objcvip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》四</title>
    <link href="https://objcvip.github.io/DataStructurePart4/"/>
    <id>https://objcvip.github.io/DataStructurePart4/</id>
    <published>2019-09-10T14:24:00.000Z</published>
    <updated>2019-09-14T16:04:52.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第5章-串"><a href="#第5章-串" class="headerlink" title="第5章 串"></a>第5章 串</h1><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</p><a id="more"></a><h2 id="串的定义"><a href="#串的定义" class="headerlink" title="串的定义"></a>串的定义</h2><blockquote><p>串（string）是由零个或多个字符组成的有限序列，又名叫字符串。</p></blockquote><h2 id="串的比较"><a href="#串的比较" class="headerlink" title="串的比较"></a>串的比较</h2><p>给定两个串：s= “a<sub>1</sub>a<sub>2</sub>……a<sub>n</sub>“,  t= “b<sub>1</sub>b<sub>2</sub>……b<sub>m</sub>“, 当满足以下条件之一时，s&lt;t。</p><ol><li>n&lt;m，且a<sub>i</sub>=b<sub>i</sub>（i=1, 2, ……, n）。</li><li>存在某个k&lt;min(m, n), 使得a<sub>i</sub>=b<sub>i</sub>（i=1，2，……，k-1）a<sub>k</sub>&lt;b<sub>k</sub></li></ol><h2 id="串的抽象数据类型"><a href="#串的抽象数据类型" class="headerlink" title="串的抽象数据类型"></a>串的抽象数据类型</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ADT 串（string）</span><br><span class="line">Data</span><br><span class="line">  串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T。</span><br><span class="line">  StrCopy(T,S):串S存在，由串复制得串T。</span><br><span class="line">  ClearString(S):串S存在，将串清空。</span><br><span class="line">  StringEmpty(S):若串为空，返回true，否则返回false。</span><br><span class="line">  StrLength(S):返回串S的元素个数，即串的长度。</span><br><span class="line">  StrCompare(S,T):若S&gt;T，返回值&gt;0,若S=T，返回0，若S&lt;T，返回值&lt;0.</span><br><span class="line">  Concat(T,S1,S2):用T返回由S1和S2联接而成的新串。</span><br><span class="line">  SubString(Sub,S,pos,len):串S存在，1&lt;=pos&lt;=StrLength(S)，且0&lt;=len&lt;=StrLength(S)-pos+1,用Sub返回串S的第pos个字符长度为len的子串。</span><br><span class="line">  Index(S,T,pos):串S和T存在，T是非空串，1&lt;=pos&lt;=StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。</span><br><span class="line">  Replace(S,T,V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。</span><br><span class="line">  StrInsert(S,pos,T):串S和T存在，1&lt;=pos&lt;=StrLength(S)+1。在串S的第pos个字符之前插入串T。</span><br><span class="line">  StrDelete(S,pos,len):串S存在，1&lt;=pos&lt;=StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><p>Index 的实现算法<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Index</span><span class="hljs-params">(String S, String T, <span class="hljs-keyword">int</span> pos)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> n,m,i;</span><br><span class="line">  String sub;</span><br><span class="line">  <span class="hljs-keyword">if</span> (pos &gt; <span class="hljs-number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    n = StrLength(S);</span><br><span class="line">    m = StrLength(T);</span><br><span class="line">    i = pos;</span><br><span class="line">    <span class="hljs-keyword">while</span> ( i &lt;= n-m+<span class="hljs-number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      SubString(sub,S,i,m); <span class="hljs-comment">/* 取主串第i个位置 长度与T相等子串给sub */</span></span><br><span class="line">      <span class="hljs-keyword">if</span> (StrCompare(sub,T) != <span class="hljs-number">0</span>)  <span class="hljs-comment">/* 如果两串不相等 */</span></span><br><span class="line">        ++i;</span><br><span class="line">      <span class="hljs-keyword">else</span>  <span class="hljs-comment">/* 如果两串相等 */</span></span><br><span class="line">        <span class="hljs-keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* 若无子串与T相等，返回0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当中用到了 StrLength、SubString、StrCompare 等基本操作来实现。</p><h2 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h2><h3 id="串的顺序存储结构"><a href="#串的顺序存储结构" class="headerlink" title="串的顺序存储结构"></a>串的顺序存储结构</h3><p>串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般使用定长数组来定义。</p><h3 id="串的链式存储结构"><a href="#串的链式存储结构" class="headerlink" title="串的链式存储结构"></a>串的链式存储结构</h3><p>对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全。</p><p>串的链式存储结构除了在链接串与串操作时有一定方便外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。</p><h2 id="朴素的模式匹配算法"><a href="#朴素的模式匹配算法" class="headerlink" title="朴素的模式匹配算法"></a>朴素的模式匹配算法</h2><p>子串的定位操作通常称做串的模式匹配。<br>假设我们要从下面的主串S=“goodgoogle”中，找到T=“google这个子串的位置”。<br>简单的来说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。<br>最好的情况，时间复杂度为O(1)。<br>稍差一些的情况，时间复杂度为O(n+m)，其中n为主串长度，m为要匹配的子串长度。<br>根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。</p><h2 id="KMP模式匹配算法"><a href="#KMP模式匹配算法" class="headerlink" title="KMP模式匹配算法"></a>KMP模式匹配算法</h2><p>D.E.Knuth、J.H.Morris 和 V.R.Pratt 发表一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特-莫里斯-普拉特算法，简称 KMP 算法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第5章-串&quot;&gt;&lt;a href=&quot;#第5章-串&quot; class=&quot;headerlink&quot; title=&quot;第5章 串&quot;&gt;&lt;/a&gt;第5章 串&lt;/h1&gt;&lt;p&gt;串（string）是由零个或多个字符组成的有限序列，又名叫字符串。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="https://objcvip.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="https://objcvip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》三</title>
    <link href="https://objcvip.github.io/DataStructurePart3/"/>
    <id>https://objcvip.github.io/DataStructurePart3/</id>
    <published>2019-09-08T14:58:00.000Z</published>
    <updated>2019-09-13T15:56:13.301Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第4章-栈与队列"><a href="#第4章-栈与队列" class="headerlink" title="第4章 栈与队列"></a>第4章 栈与队列</h1><p>栈是限定仅在表尾进行插入和删除操作的线性表。<br>队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。</p><a id="more"></a><h2 id="栈的定义"><a href="#栈的定义" class="headerlink" title="栈的定义"></a>栈的定义</h2><blockquote><p>栈（stack）是限定仅在表尾进行插入和删除操作的线性表。</p></blockquote><p>我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。</p><p>栈的插入操作，叫做进栈，也称压栈、入栈。<br>栈的删除操作，叫做出栈，也有的叫弹栈。</p><h2 id="进栈出栈的变化形式"><a href="#进栈出栈的变化形式" class="headerlink" title="进栈出栈的变化形式"></a>进栈出栈的变化形式</h2><p>元素数量多个，出栈次序会有很多种可能。</p><h2 id="栈的抽象数据类型"><a href="#栈的抽象数据类型" class="headerlink" title="栈的抽象数据类型"></a>栈的抽象数据类型</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT 栈</span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  InitStack(*S):初始化操作，建立一个空栈S。</span><br><span class="line">  DestroyStack(*S):若栈存在，则销毁它。</span><br><span class="line">ClearStack(*S):将栈清空。</span><br><span class="line">  StackEmpty(S):若栈为空，返回 <span class="hljs-literal">true</span> ，否则返回 <span class="hljs-literal">false</span>。</span><br><span class="line">  GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素。</span><br><span class="line">  Push(*S,e):若栈S存在，插入新元素e到栈S中并成为栈顶元素。</span><br><span class="line">  Pop(*S,e):删除栈S中的栈顶元素，并用e返回其值。</span><br><span class="line">  StackLength(S):返回栈S的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="栈的顺序存储结构及实现"><a href="#栈的顺序存储结构及实现" class="headerlink" title="栈的顺序存储结构及实现"></a>栈的顺序存储结构及实现</h2><h3 id="栈的顺序存储结构"><a href="#栈的顺序存储结构" class="headerlink" title="栈的顺序存储结构"></a>栈的顺序存储结构</h3><p>栈的结构定义<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> init SElemType;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  SElemType data[MAXSIZE]</span><br><span class="line">  <span class="hljs-keyword">int</span> top;     <span class="hljs-comment">/* 用于栈顶指针 */</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure></p><h3 id="栈的顺序存储结构——进栈操作"><a href="#栈的顺序存储结构——进栈操作" class="headerlink" title="栈的顺序存储结构——进栈操作"></a>栈的顺序存储结构——进栈操作</h3><p>进栈操作 push，其代码如下：<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">Push</span> <span class="hljs-params">(SqStack *S, SElemType e)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (S-&gt;top == MAXSIZE - <span class="hljs-number">1</span>) <span class="hljs-comment">/* 栈满 */</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> ERROR;</span><br><span class="line">  &#125;</span><br><span class="line">  S-&gt;top++;   <span class="hljs-comment">/* 栈顶指针增加一 */</span></span><br><span class="line">  S-&gt;data[S-&gt;top]=e;   <span class="hljs-comment">/* 将新插入元素赋值给栈顶空间 */</span></span><br><span class="line">  <span class="hljs-keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="栈的顺序存储结构——出栈操作"><a href="#栈的顺序存储结构——出栈操作" class="headerlink" title="栈的顺序存储结构——出栈操作"></a>栈的顺序存储结构——出栈操作</h3><p>出栈操作 pop，其代码如下：<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">Pop</span> <span class="hljs-params">(SqStack *S, SElemType *e)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span>(S-&gt;top==<span class="hljs-number">-1</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> ERROR;</span><br><span class="line">  *e=S-&gt;data[S-&gt;top]; <span class="hljs-comment">/* 将要删除的栈顶元素赋值给e */</span></span><br><span class="line">  S-&gt;top--;   <span class="hljs-comment">/* 栈顶指针减一 */</span></span><br><span class="line">  <span class="hljs-keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>进栈和出栈没有涉及到任何循环语句，因此时间复杂度均是 O(1)。</p><h2 id="两栈共享空间"><a href="#两栈共享空间" class="headerlink" title="两栈共享空间"></a>两栈共享空间</h2><p>使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。</p><h2 id="栈的链式存储结构及实现"><a href="#栈的链式存储结构及实现" class="headerlink" title="栈的链式存储结构及实现"></a>栈的链式存储结构及实现</h2><h3 id="栈的链式存储结构"><a href="#栈的链式存储结构" class="headerlink" title="栈的链式存储结构"></a>栈的链式存储结构</h3><p>栈的链式存储结构，简称为链栈。<br>链栈的结构代码如下：<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  SElemType data;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">StackNode</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;StackNode, *LinkStackPtr;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">LinkStack</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  LinkStackPtr top;</span><br><span class="line">  <span class="hljs-keyword">int</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="栈的链式存储结构——进栈操作"><a href="#栈的链式存储结构——进栈操作" class="headerlink" title="栈的链式存储结构——进栈操作"></a>栈的链式存储结构——进栈操作</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 插入元素 e 为新的栈顶元素 */</span></span><br><span class="line"><span class="hljs-function">Status <span class="hljs-title">Push</span> <span class="hljs-params">(LinkStack *S, SElemType e)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  LinkStackPtr s = (LinkStackPtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(StackNode));</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  s-&gt;next = s-&gt;top;  <span class="hljs-comment">/* 把当前的栈顶元素赋值给新结点的直接后继 */</span></span><br><span class="line">  S-&gt;top = s;  <span class="hljs-comment">/* 将新的结点s赋值给栈顶指针 */</span></span><br><span class="line">  S-&gt;count++;</span><br><span class="line">  <span class="hljs-keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="栈的链式存储结构——出栈操作"><a href="#栈的链式存储结构——出栈操作" class="headerlink" title="栈的链式存储结构——出栈操作"></a>栈的链式存储结构——出栈操作</h3><p>假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 p 即可。<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">Pop</span> <span class="hljs-params">(LinkStack *S, SElemType *e)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  LinkStackPtr p;</span><br><span class="line">  <span class="hljs-keyword">if</span> (StackEmpty(*S))</span><br><span class="line">    <span class="hljs-keyword">return</span> ERROR;</span><br><span class="line">  *e = S-&gt;top-&gt;data;</span><br><span class="line">  p=S-&gt;top;  <span class="hljs-comment">/* 将栈顶结点赋值给p */</span></span><br><span class="line">  S-&gt;top=S-&gt;top-&gt;next;  <span class="hljs-comment">/* 使得栈顶指针下移一位，指向后一结点 */</span></span><br><span class="line">  <span class="hljs-built_in">free</span>(p);  <span class="hljs-comment">/* 释放结点 p */</span></span><br><span class="line">  S-&gt;count--;</span><br><span class="line">  <span class="hljs-keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>链栈的进栈 push 和出栈 pop 操作没有任何循环操作，时间复杂度均为O(1)。<br>如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。</p><h2 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h2><p>栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。</p><h2 id="栈的应用——递归"><a href="#栈的应用——递归" class="headerlink" title="栈的应用——递归"></a>栈的应用——递归</h2><h3 id="斐波那切数列实现"><a href="#斐波那切数列实现" class="headerlink" title="斐波那切数列实现"></a>斐波那切数列实现</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Fbi</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">2</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span> i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;</span><br><span class="line">  <span class="hljs-keyword">return</span> Fbi(i<span class="hljs-number">-1</span>) + Fbi(i<span class="hljs-number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">int</span> i;</span><br><span class="line">  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">40</span>; i++)</span><br><span class="line">    <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%d "</span>, Fbi(i));</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。<br>每个递归定义必须至少有一个条件，满足递归不再进行，即不再引用自身而是返回值退出。</p><h2 id="栈的应用——四则运算表达式求值"><a href="#栈的应用——四则运算表达式求值" class="headerlink" title="栈的应用——四则运算表达式求值"></a>栈的应用——四则运算表达式求值</h2><ol><li><p>将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。</p></li><li><p>将后缀表达式进行运算得出结果（栈用来进出运算的数字）。</p></li></ol><h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><blockquote><p>队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。</p></blockquote><p>队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。</p><h2 id="队列的抽象数据类型"><a href="#队列的抽象数据类型" class="headerlink" title="队列的抽象数据类型"></a>队列的抽象数据类型</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ADT 队列（Queue）</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">  同线性表。元素具有相同的类型，相邻元素具有前缀和后继关系。</span><br><span class="line">Operation</span><br><span class="line">  InitQueue(*Q):初始化操作，建立一个空队列Q。</span><br><span class="line">  DestroyQueue(*Q):若队列Q存在，则销毁它。</span><br><span class="line">  ClearQueue(*Q):将队列Q清空。</span><br><span class="line">  QueueEmpty(*Q):若队列Q为空，返回 <span class="hljs-literal">true</span>，否则返回 <span class="hljs-literal">false</span>。</span><br><span class="line">  GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素。</span><br><span class="line">  EnQueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素。</span><br><span class="line">  DeQueue(*Q,*e):删除队列Q中队头元素，并用e返回其值。</span><br><span class="line">  QueueLength(Q):返回队列Q的元素个数。</span><br><span class="line">endADT</span><br></pre></td></tr></table></figure><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><h3 id="循环队列定义"><a href="#循环队列定义" class="headerlink" title="循环队列定义"></a>循环队列定义</h3><p>我们把队列的这种头尾相接的顺序存储结构称为循环队列。</p><h2 id="队列的链式存储结构及实现"><a href="#队列的链式存储结构及实现" class="headerlink" title="队列的链式存储结构及实现"></a>队列的链式存储结构及实现</h2><p>队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。<br>链队列的结构为：<br><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> QElemType;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span>  /* 节点结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  QElemType data;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">QNode</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  /* 队列的链表结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  QueuePtr front,rear; <span class="hljs-comment">/* 队头、队尾指针 */</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure></p><h3 id="队列的链式存储结构——入队操作"><a href="#队列的链式存储结构——入队操作" class="headerlink" title="队列的链式存储结构——入队操作"></a>队列的链式存储结构——入队操作</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">EnQueue</span><span class="hljs-params">(LinkQueue *Q, QElemType e)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  QueuePtr s = (QueuePtr)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(QNode));</span><br><span class="line">  <span class="hljs-keyword">if</span>(!s)  <span class="hljs-comment">/* 存储分配失败 */</span></span><br><span class="line">    <span class="hljs-built_in">exit</span>(OVERFLOW);</span><br><span class="line">  s-&gt;data = e;</span><br><span class="line">  s-&gt;next = <span class="hljs-literal">NULL</span>;</span><br><span class="line">  Q-&gt;rear-&gt;next = s;  <span class="hljs-comment">/* 把拥有元素e新结点s赋值给原队尾节点的后继 */</span></span><br><span class="line">  Q-&gt;rear = s;  <span class="hljs-comment">/* 把当前的s设置为队尾结点，rear指向s */</span></span><br><span class="line">  <span class="hljs-keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="队列的链式存储结构——出队操作"><a href="#队列的链式存储结构——出队操作" class="headerlink" title="队列的链式存储结构——出队操作"></a>队列的链式存储结构——出队操作</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function">Status <span class="hljs-title">DeQueue</span><span class="hljs-params">(LinkQueue *Q, QElemType *e)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  QueuePtr p;</span><br><span class="line">  <span class="hljs-keyword">if</span>(Q-&gt;front==Q-&gt;rear)</span><br><span class="line">    <span class="hljs-keyword">return</span> ERROR;</span><br><span class="line">  p=Q-&gt;front-&gt;next;  <span class="hljs-comment">/* 将欲删除的队头结点暂存给p */</span></span><br><span class="line">  *e=p-&gt;data;  <span class="hljs-comment">/* 将欲删除的队头结点的值赋值给e */</span></span><br><span class="line">  Q-&gt;front-&gt;next=p-&gt;next;  <span class="hljs-comment">/* 将原队头结点后继p-&gt;next赋值给头结点后缀 */</span></span><br><span class="line">  <span class="hljs-keyword">if</span>(Q-&gt;rear==p)  <span class="hljs-comment">/* 若队头是队尾，则删除后将rear指向头结点 */</span></span><br><span class="line">    Q-&gt;rear=Q-&gt;front;</span><br><span class="line">  <span class="hljs-built_in">free</span>(p);</span><br><span class="line">  <span class="hljs-keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第4章-栈与队列&quot;&gt;&lt;a href=&quot;#第4章-栈与队列&quot; class=&quot;headerlink&quot; title=&quot;第4章 栈与队列&quot;&gt;&lt;/a&gt;第4章 栈与队列&lt;/h1&gt;&lt;p&gt;栈是限定仅在表尾进行插入和删除操作的线性表。&lt;br&gt;队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="https://objcvip.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="https://objcvip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>苏宁面试题</title>
    <link href="https://objcvip.github.io/%E8%8B%8F%E5%AE%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/苏宁面试题/</id>
    <published>2019-09-06T16:08:00.000Z</published>
    <updated>2019-09-08T01:45:54.599Z</updated>
    
    <content type="html"><![CDATA[<p>苏宁面试题<br><a id="more"></a></p><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>1、冒泡排序</p><p>2、二分查找</p><p>3、合并两个数组去重</p><p>4、两个大数相加</p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>笔试题过一遍。</p><p>1、SDWebImage 的缓存机制？LRU 说一下。</p><p>2、数据库升级，比如从 1.0 升级到 2.0，增加了字段。</p><p>3、性能优化。</p><p>4、Git 开发流程。</p><p>5、微信登录流程。</p><p>6、WebView 与 JS 交互。</p><p>7、说一下Runloop，苹果设计 Runloop 的初衷是什么？</p><p>8、性能优化。</p><p>9、Delegate</p><p>10、GCD</p><p>11、深拷贝与浅拷贝。</p><p>12、进程间通信。</p><p>13、线程间通信，两个线程怎么切换？</p><p>performSelector</p><p>14、多态。</p><p>15、HTTP 三次握手，四次挥手。</p><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>像是人事，不太像技术。让说具体方案。</p><p>1、有没有复杂点的页面。</p><p>2、（这个部门是做只能硬件的）蓝牙有哪些API。</p><p>3、播放音频，展示音频的曲线，具体怎么做？</p><h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>技术总监</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;苏宁面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="面试题" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="苏宁" scheme="https://objcvip.github.io/tags/%E8%8B%8F%E5%AE%81/"/>
    
  </entry>
  
  <entry>
    <title>开果科技面试题</title>
    <link href="https://objcvip.github.io/%E5%BC%80%E6%9E%9C%E7%A7%91%E6%8A%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/开果科技面试题/</id>
    <published>2019-09-06T15:30:00.000Z</published>
    <updated>2019-09-06T16:13:42.745Z</updated>
    
    <content type="html"><![CDATA[<p>开果科技面试题<br><a id="more"></a></p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、卡顿原因、解决办法。为什么透明视图不如不透明视图？</p><p>2、闪退原因、监测、过程。友盟是怎么捕获闪退的？从一个事件到闪退发生了什么？</p><p>3、图片的压缩，从600k到500k，不能设置固定压缩比，应该怎么做？压缩图片，压缩图片实际压缩的是哪些东西？加载超大图；图片在计算机中的存储形式；10M的图片加载到内存中是多大？大图是怎么加载的？</p><p>图像文件存储的都是每一个像素对应的颜色值。</p><p>4、字典的本质？哈希表原理？</p><p>哈希表。</p><p>5、链表和数组，哪个容易找到地址？</p><p>数组。</p><ul><li><p>在内存中，数组是一块连续的区域。插入和删除数据效率低。随机读取效率很高，因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。</p></li><li><p>链表增加和删除数据很容易。查找数据时效率低，因为不具有随机访问性。</p></li></ul><p>6、列表有好多页，某一页和后边加载的一页中有相同的数据，怎么处理？</p><p>7、动态库和静态库的区别。</p><p>8、设计模式。</p><h1 id="二面-电话面试"><a href="#二面-电话面试" class="headerlink" title="二面(电话面试)"></a>二面(电话面试)</h1><p>1、什么时候开始接触 iOS？怎么学的iOS？</p><p>2、公司多少人？什么项目？</p><p>3、你会选择什么样的公司？</p><p>4、数据库（SQLite/Realm）是怎么保证线程安全的？</p><p>5、UserDeafaults 系统做了哪些优化？为什么可以在主线程上去做存取？如果让你实现，方法已经是同步的方法了，你会怎么处理？</p><p>6、+load 和 +initialize 方法什么时候会调用，+load 和 +initialize 方法、main 方法这三个的调用顺序。</p><p>7、@class 和 #import 在编译的时候有哪些区别？</p><p>8、JSON 转 Model 你用的是什么？MJExtension 字典转模型的具体步骤？拿到字典了，第一步做什么，第二步做什么？</p><p>9、WebView 跟 JS 是怎么交互的？</p><p>10、WebView 怎么存 cookie？</p><p>11、A-&gt;B-&gt;C-&gt;D 从D返回到B。说几个不同的实现思路。</p><ul><li>方案1：for 循环 self.navigationController.viewControllers 判断某个控制器是否是 B 如果是就 popToViewController:B。</li><li>方案2：self.navigationController.viewControllers 是一个不可变数组，可以赋值给一个可变的数组，然后把 C 移除，然后再赋值给 viewControllers。</li><li>其他方案：提示不一定要 push，present出来的怎么弄？</li></ul><p>12、二分查找。</p><p>13、深拷贝与浅拷贝，某个值得改变可能会影响原始值，那是深拷贝还是浅拷贝？</p><p>14、性能优化？图片加载到 UIImageView 上经过了哪些过程？</p><p>15、Label 怎么多行显示。</p><p>16、Button有哪些状态？</p><p>17、dispatch_group_notify 是在哪个线程上？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;开果科技面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="开果" scheme="https://objcvip.github.io/tags/%E5%BC%80%E6%9E%9C/"/>
    
      <category term="面试题" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>美团面试题</title>
    <link href="https://objcvip.github.io/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/美团面试题/</id>
    <published>2019-09-06T08:50:00.000Z</published>
    <updated>2019-09-06T08:51:09.319Z</updated>
    
    <content type="html"><![CDATA[<p>美团面试题</p><a id="more"></a><p>1、Block 的底层原理，结构，内存以及需要注意的地方。</p><p>2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？</p><p>3、Runtime。</p><p>4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。</p><p>5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。</p><p>6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。</p><p>7、做过什么动画。</p><p>8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。</p><p>9、网络层级，TCP 和 UDP 的区别。</p><p>10、SDWebImage 的框架结构，缓存机制。</p><p>11、Git 的 rebase 的原理。Git 流程。</p><p>12、对组件化的了解，组件化是为了解决什么问题。</p><p>13、JSPatch 的原理。</p><p>14、单例是为了处理什么问题而使用的，单例和全局变量的区别。</p><p>15、对设计模式的掌握。</p><p>16、分层打印二叉树。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团面试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="https://objcvip.github.io/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>ofo面试题</title>
    <link href="https://objcvip.github.io/ofo%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/ofo面试题/</id>
    <published>2019-09-06T08:40:00.000Z</published>
    <updated>2020-02-20T09:21:14.387Z</updated>
    
    <content type="html"><![CDATA[<p>ofo面试题</p><a id="more"></a><p>1、block 的底层实现?</p><p>2、block 的类型有哪几种?</p><p>3、你碰到的 block 的循环引用?</p><p>4、为什么你在用 Masonry , AFNetworking 的 block 回调不需要对 self 进行 __weak?</p><p>5、出现野指针的情况大概有哪些？</p><p>6、Swift 里的闭包和 OC 的 block 的区别。</p><p>7、Sqlite 使用的时候需要注意什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ofo面试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="ofo" scheme="https://objcvip.github.io/tags/ofo/"/>
    
  </entry>
  
  <entry>
    <title>京东面试题</title>
    <link href="https://objcvip.github.io/%E4%BA%AC%E4%B8%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/京东面试题/</id>
    <published>2019-09-06T08:27:00.000Z</published>
    <updated>2019-09-07T16:27:57.388Z</updated>
    
    <content type="html"><![CDATA[<p>京东面试题</p><a id="more"></a><p>1、AFNetworking 是如何实现多线程的。</p><p>2、如何自己控制 AFNetWorking 的多线程，如果解决上传多张图片引起的内存剧增的问题。</p><p>3、模块化的实现过程。</p><p>4、自动化测试。</p><p>5、数据库的升级（当前数据库不能满足业务了，1.0-&gt;2.0-&gt;3.0…..）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;京东面试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="京东" scheme="https://objcvip.github.io/tags/%E4%BA%AC%E4%B8%9C/"/>
    
  </entry>
  
  <entry>
    <title>高思教育笔试题</title>
    <link href="https://objcvip.github.io/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/高思教育笔试题/</id>
    <published>2019-09-06T08:25:00.000Z</published>
    <updated>2019-09-08T09:04:25.596Z</updated>
    
    <content type="html"><![CDATA[<p>高思教育笔试题</p><a id="more"></a><h1 id="笔试题（部分）"><a href="#笔试题（部分）" class="headerlink" title="笔试题（部分）"></a>笔试题（部分）</h1><p>3.下面代码输出什么？</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>;</span><br><span class="line"><span class="hljs-keyword">void</span> (^foo)(<span class="hljs-keyword">void</span>) = ^&#123;</span><br><span class="line">a = <span class="hljs-number">1</span>;</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"inner a=%d"</span>,a);</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br><span class="line"><span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"outer a=%@"</span>,a);</span><br></pre></td></tr></table></figure><p>4.下面代码输出什么？</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="hljs-keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="hljs-keyword">super</span> viewDidLoad];</span><br><span class="line">  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"1"</span>);</span><br><span class="line">  <span class="hljs-built_in">dispatch_sync</span>(dispatch_get_main_queue(),^&#123;</span><br><span class="line">    <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"2"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="hljs-built_in">NSLog</span>(<span class="hljs-string">@"3"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.什么情况使用 weak 关键字，相比 assign 有什么不同？</p><p>6.@property 中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</p><p>7.@synthesize 和 @dynamic 分别有什么作用？</p><p>8.什么时候会报 unrecognized selector 的异常？</p><p>9.能否想编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p><p>10.如何用 GCD 同步若干异步调用？dispatch_barrier_async 的作用是什么？</p><p>11.如何手动触发一个 value 的 KVO</p><p>12.Native 的 Web（WK/UI）控件和 js 的交互是如何实现的？（native<->js）</-></p><p>13.JavaScriptCore 框架中，native 如何调用 js？反之，js如何调用native？</p><p>14.有阅读 Weex、ReactNative 或者 Cordova 框架的描述其一即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高思教育笔试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="笔试题" scheme="https://objcvip.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
      <category term="高思教育" scheme="https://objcvip.github.io/tags/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>滴滴笔试题</title>
    <link href="https://objcvip.github.io/%E6%BB%B4%E6%BB%B4%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/滴滴笔试题/</id>
    <published>2019-09-06T08:11:00.000Z</published>
    <updated>2019-09-08T09:06:36.796Z</updated>
    
    <content type="html"><![CDATA[<p>滴滴笔试题</p><a id="more"></a><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>0.姓名？日期。</p><p>1.C语言实现字符串反转：<code>void reverse(char *str, int length) {}</code></p><p>2.实现一个字符串数组去重函数。</p><p>3.描述OC中对象的实现原理。</p><p>4.编写代码，实现 NSObject 中添加一个属性 p1</p><p>5.KVO 的实现原理和注意事项。</p><p>6.下面的代码有哪些问题？</p><figure class="highlight objc hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">@interface</span> <span class="hljs-title">Demo</span> : <span class="hljs-title">NSObject</span></span></span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">assign</span>) <span class="hljs-built_in">BOOL</span> *p1;</span><br><span class="line"><span class="hljs-keyword">@property</span> (<span class="hljs-keyword">nonatomic</span>, <span class="hljs-keyword">strong</span>) <span class="hljs-built_in">NSString</span> *p2;</span><br><span class="line"><span class="hljs-keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">@implementation</span> <span class="hljs-title">Demo</span></span></span><br><span class="line"><span class="hljs-keyword">@dynamic</span> p1;</span><br><span class="line"></span><br><span class="line">- (<span class="hljs-keyword">void</span>)setP2:(<span class="hljs-built_in">NSString</span> *)p2;</span><br><span class="line">&#123;</span><br><span class="line"><span class="hljs-keyword">self</span>.p1 = <span class="hljs-literal">YES</span>;</span><br><span class="line"><span class="hljs-keyword">self</span>.p2 = p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">@end</span></span><br></pre></td></tr></table></figure><p>7.JS 和 Native 的通讯方式。</p><p>8.网络5层模型是哪5层？</p><p>9.把t1表中 name 为 mike 的记录中 status 值改为1</p><p>10.常用的 Linux 命令。</p><p>11.用过的包/库管理工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;滴滴笔试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="滴滴" scheme="https://objcvip.github.io/tags/%E6%BB%B4%E6%BB%B4/"/>
    
      <category term="笔试题" scheme="https://objcvip.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>新浪乐居面试题</title>
    <link href="https://objcvip.github.io/%E6%96%B0%E6%B5%AA%E4%B9%90%E5%B1%85%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/新浪乐居面试题/</id>
    <published>2019-09-04T08:12:00.000Z</published>
    <updated>2019-09-04T08:16:49.347Z</updated>
    
    <content type="html"><![CDATA[<p>新浪乐居面试题<br><a id="more"></a></p><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>笔试题</p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、类方法和实例方法有什么区别？</p><p>2、用封装的类方法去请求网络会有什么问题？</p><p>3、说一下单例。单例的作用是什么？为什么不能多次创建对象？</p><p>4、说一下 ARC、MRC，有什么区别？有啥优缺点？</p><p>5、自动释放池的使用场景？耗内存时需要加到池子里。</p><p>6、沙盒目录除了 Documents 还有啥？Cache 和 Temp 有什么区别？</p><p>7、项目里用地图了吗？如果用系统的地图会有一个问题，电量急速下降，遇到过这个问题吗？</p><p>8、都有哪些可能循环引用？</p><p>9、说一下从网络请求回来的数据怎么存？数据持久化的方法。数据库是存在沙盒的哪个目录？我说在 Documents 中。</p><p>10、assign 与 weak 区别？</p><p>11、笔试题19的答案为什么是2、5？</p><p>12、说一下冒泡排序的思路？</p><p>13、GCD 需要注意什么？我说了一下使用场景。</p><p>14、Runtime、Runloop 了解吗？（说了一下消息发送和消息转发的流程）Runloop 有哪些 Mode？（说了3个，面试官说能用的到的就这三个。。其他俩点进去也看不着）说一下 CommonMode ？</p><p>15、最后一个问题：类似简历  右上角是图片（宽高已知） 左边是一段文字  文字会包裹着图片，问实现思路？</p><p>说了三个思路：<br>（1）计算一下上边 label 宽高，左边用一个 label 显示，下边多余的字也用另一个 label 显示。</p><p>（2）YYText 可能有处理办法，算是第三方。</p><p>（3）他提示底层一点的，我说绘制。</p><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>1、了解项目，问在公司干啥。</p><p>2、AutoLayout 和 Masonry 有什么区别？</p><p>3、面向对象在 OC 中的体现？封装、继承、多态。你觉得最主要的是面向对象的哪个特性？</p><p>4、你对 H5、原生交互的看法。我说了实现方式后，他说不要实现细节，就你的看法。我又说了阿里是大前端，他说不要说阿里，你的看法呢？我说活动页用H5，其他用原生，可能效率高。</p><p>5、Block 和 delegate 的使用场景差异？</p><p>6、你觉得开发一个项目难点在哪儿？</p><p>7、其他问题：薪水能商量吗？有什么要问我的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新浪乐居面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>微店面试题</title>
    <link href="https://objcvip.github.io/%E5%BE%AE%E5%BA%97%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/微店面试题/</id>
    <published>2019-09-04T08:05:00.000Z</published>
    <updated>2019-09-04T08:10:06.680Z</updated>
    
    <content type="html"><![CDATA[<p>微店面试题<br><a id="more"></a></p><h1 id="微店一面"><a href="#微店一面" class="headerlink" title="微店一面"></a>微店一面</h1><p>1、说项目里的有价值的东西？</p><p>2、HTTPS 过程是怎么样的？非对称加密</p><p>3、Swift 中逃逸闭包和非逃逸闭包的区别？</p><p>4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？</p><p>5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？</p><p>6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？</p><p>7、GCD 内部实现？</p><p>8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？</p><p>9、KVO 的原理？具体 NSObject 的两个方法？</p><p>10、消息转发流程？使用场景？</p><p>11、数据库减字段怎么容错？</p><p>12、有没有打包过私有库？</p><p>13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？</p><p>14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？</p><p>15、说一下一个项目的架构？</p><p>16、组件化？</p><p>17、手写冒泡排序算法？算法复杂度？</p><h1 id="微店二面"><a href="#微店二面" class="headerlink" title="微店二面"></a>微店二面</h1><p>1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？</p><p>2、写一下其中一个项目的项目架构？写一下用到的第三方库。</p><p>3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？</p><p>4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？</p><p>5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？</p><p>6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图）</p><p>7、加密算法，对称加密和非对称加密？</p><p>8、如何理解 OC 是动态语言？</p><p>9、Runtime？用 Runtime 做过什么？</p><p>10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？</p><p>11、内存管理？内存优化？</p><p>12、卡顿？</p><p>13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d）</p><p>14、从点击 App 图标，到显示界面流程？</p><p>15、组件化？</p><p>16、编译过程？某一个东西是属于哪一步骤的？</p><p>17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图）</p><p>18、RN、Week？内部是怎么用 JS 调用原生的？</p><p>19、日志记录？</p><p>20、遇到的闪退？Bug？</p><p>21、竞争同一个资源？</p><p>22、进程线程与 App 的关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微店面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>好未来面试题</title>
    <link href="https://objcvip.github.io/%E5%A5%BD%E6%9C%AA%E6%9D%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/好未来面试题/</id>
    <published>2019-09-04T07:56:00.000Z</published>
    <updated>2019-09-04T08:01:25.975Z</updated>
    
    <content type="html"><![CDATA[<p>好未来面试题<br><a id="more"></a></p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、说一下optional。（？ ！ ？？ 几种解包方式 if let、guard、？？等）</p><p>2、说一下闭包。</p><p>3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？( KVO 效率最低，因为 Runtime ）</p><p>4、NSString 和 String 的区别？（ String 是值类型，NSString 是引用类型）</p><p>5、Swift 跟 OC 的区别？（ OC 是动态的语言，Swift 是静态的语言）OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？</p><p>6、说一下 MRC ？自动释放池？自动释放池什么时候释放？（我说 drain ）</p><p>7、说一下多线程？（我提到了 dispatch_once 单例）</p><p>8、分别用 OC 和 Swift 手写一下单例。（ Swift 的单例我忘记写 static 了，但是经提醒立马说出来了）</p><p>9、SnaptKit 内部看过吗？</p><p>10、链式语法的实现。</p><p>UIView.top.equalTo().offSet(10)</p><p>UIView.left.equalTo().offSet(10)</p><p>为什么能写成UIView.top.left.offSet(10)</p><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>主要是手写算法题：</p><p>1、用两个栈实现队列。</p><p>2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。</p><h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>项目经理</p><h1 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h1><p>HR</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好未来面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>高思教育面试题</title>
    <link href="https://objcvip.github.io/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/高思教育面试题/</id>
    <published>2019-09-04T07:39:00.000Z</published>
    <updated>2019-09-06T08:36:19.087Z</updated>
    
    <content type="html"><![CDATA[<p>高思教育面试题<br><a id="more"></a></p><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>笔试题</p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、@property 本质是什么？NSString 为什么用 Copy，用 Strong 行不行？</p><p>2、block 为什么用 copy ？</p><p>3、block 和代理你用的哪个多？各有什么特点？</p><p>4、GCD 的两个队列（串行、并行）有了解吗？从字面意思看，你觉得这俩哪个效率高，哪个（占空间）忘记了问的啥指标了。。</p><p>5、（说一下你的项目吧）看到我的酒店 App，问类似网易新闻那种滑动切换页面你是怎么做的？我说是一个 scrollView，点击按钮后滚动到指定的 index。他说的顶部按钮是3个，如果是30个呢，会有什么问题？他说如果1个页面占用5M，30个页面就占用5x30M，会有内存问题，怎么解决这个问题？我说看过别人写的，用的是子控制器，把这些页面加到当前控制器的子控制器中。（现在想想我也是这么做的。。但是没说是这么做）</p><p>6、AFN内部看过吗？AFN的5个模块。</p><p>大概这时候问，你觉得自己是什么级别的？（中级）</p><p>7、说一下响应者链。</p><p>8、一个约束题。</p><p>9、项目不忙的时候做过什么优化？（我说用 Instruments 分析过内存泄漏）他说发现过什么问题？（发现过 NSTimer 定时器有内存泄漏）他说那考虑用什么替换定时器呢？（我说没有替换它，退出这个页面的时候关掉了 Timer）</p><p>还做过什么优化？（忘记咋回答了）</p><p>10、（不知道问啥我的回答是野指针）然后就问野指针是啥？指针指向的那块地址（忘记了。。）如果又有其他指针指向了这块内存，会怎么样（他好像说会闪退）</p><p>12、斐波那切数列</p><p>0 1 2 3 4 5…</p><p>1 1 2 3 5 8 13 21  求n  f(n) = f(n-1) + f(n-2)</p><h1 id="复试"><a href="#复试" class="headerlink" title="复试"></a>复试</h1><p>1、怎么学的 iOS ？为什么没搞 Java </p><p>2、介绍公司情况，人员规模，介绍项目</p><p>3、说一下项目中遇到的问题，怎么解决的？</p><p>4、说一下内存管理，怎么检测内存泄漏的？</p><p>5、你用 OC 开发还是 Swift ？你觉得两者有啥不同？</p><p>6、金融 App 应该有一些安全措施吧？你们是怎么做的？</p><p>7、TCP 和 UDP 有啥区别？</p><p>8、TCP 几次握手？过程是怎么样的？</p><p>9、Post 请求和 Get 请求有啥区别？</p><p>10、数据持久化都有哪些？</p><p>11、AFN 的实现原理？SDWebImage 的实现原理？哪些存在内存，哪些存在磁盘？</p><p>12、两个网络请求有依赖关系时，怎么处理的？</p><p>13、同步、异步  串行、并行</p><p>14、几张图合成一张图</p><p>15、说一下 Runloop</p><p>16、KVO 的实现原理</p><p>17、不使用中间变量 实现交换两个数 swap(a, b)</p><p>18、copy 关键字修饰什么？</p><p>19、类的私有属性，怎么设置属性值？我答了 KVC  他提到了 Runtime</p><p>20、有没有做过音频的处理？类似唱吧把原唱关掉。</p><p>21、动画了解的怎么样？</p><p>22、了解 ARKit 吗？</p><p>23、数据结构和算法你怎么样？冒泡排序，选择排序？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高思教育面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="高思教育" scheme="https://objcvip.github.io/tags/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
</feed>
