{"pages":[{"title":"标签","text":"","link":"/blog/tags/index.html"},{"title":"分类","text":"","link":"/blog/categories/index.html"},{"title":"关于","text":"iOS开发者。 多年iOS开发经验，熟练掌握Objective-C/Swift，开发过多款商业App，业余时间独立开发上架过几款商业App，涉及直播、互联网金融、酒店、医疗、电商等。 邮箱lc@chanceli.com 经历 联想佳沃 新毅集团 项目 718金融财富、借款、房毅贷 佳沃市集 业余时间独立开发项目：吆趣、酒店会、历真诊疗、医生端","link":"/blog/about/index.html"}],"posts":[{"title":"Effective Objective-C 2.0（第1章）","text":"编写高质量iOS与OS X代码的52个有效方法第1章 熟悉Objective-C 1.了解Objective-C 语言的起源Objective-C使用消息结构messaging structure，而非函数调用function calling。消息结构：运行时所运行的代码是由运行环境决定的。运行时才会去查找所要执行的方法。函数调用：编译器决定。Objective-C是C语言的超集，使用动态绑定的消息结构，在运行时才会检查对象类型。接收到一条消息后，究竟该执行何种代码，由运行时环境而非编译器决定。对象所占内存总是分配在堆上。 要点 Objective-C 为C语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接受一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。 理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。 2.在类的头文件中尽量少引入其他头文件@class的作用：（1）可以将引入头文件的时机延后，只在确实有需要的时候才引入，可以减少类的使用者所需引入的头文件数量，减少编译时间。（2）解决两个类相互引用的问题。相互引用会导致循环引用，两个类里有一个无法被正确编译。 要点 除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 3.多用字面量语法，少用与之等价的方法字面量语法简明扼要。创建数组或字典时使用字面量语法能够尽早发现插入nil的问题。 要点 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。 应该通过取下标操作来访问数组下标或字典中的键所对应的元素。 用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。 4.多用类型常量，少用#define预处理命令 不要使用预处理指令定义常量。（1）这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。（2）如果被其他人重新定义了常量值，编译器不会报警告，这将导致常量值不一致。 在实现文件里使用static const来定义此类中使用的常量。由于此类常量不在全局符号表中，所以无须为其名称加前缀。 在头文件中使用extern来声明全局变量，并在实现文件中定义其值。这种常量会出现在全局符号表中，所以名称最好加上与之相关的类名做前缀。 5.用枚举表示状态、选项、状态码要点 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将个选项值定义为2的幂，以便通过按位或操作将其组合起来。 用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据结构。这样做可以确保枚举类型是用开发者所选的底层数据结构实现出来的，而不会采用编译器所选的类型。 在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。","link":"/blog/EffectiveObjectiveCPart1/"},{"title":"《大话数据结构》学习笔记一","text":"第1章 数据结构绪论 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种： 集合机构 线性结构 树形结构 图形结构 2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。 顺序存储结构：是把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 链式存储结构：是把数据元素存放在任意的存储单元里，这组单元可以是连续的，也可以是不连续的。 抽象数据类型数据类型：是指一组性质相同的值得集合及定义在此集合上的一些操作的总称。C语言中，按照取值的不同，可以分为两类： 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。 结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数组组成的。 抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。 第2章 算法算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。 算法的特性 输入输出 有穷性 确定性 可行性 算法设计的要求 正确性 可读性 健壮性 时间效率高和存储量低 算法效率的度量方法 事后统计方法（不科学、不准确） 事前分析估算方法 函数的渐近式增长函数的渐近增长：给定两个函数 f(n) 和 g(n), 如果存在一个整数N，使得对于所有的 n &gt; N, f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。 算法时间复杂度在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。 推导大 O 阶方法 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。 常见的时间复杂度O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)","link":"/blog/DataStructurePart1/"},{"title":"《大话数据结构》学习笔记二","text":"第3章 线性表线性表：零个或多个数据元素的有限序列。 线性表的定义 线性表(List):零个或多个数据元素的有限序列。 线性表元素的个数 n (n&gt;=0) 定义为线性表的长度，当 n = 0时，称为空表。 线性表的抽象数据类型ADT 线性表(List)Data​ 线性表的数据对象集合为{a1,a2,……,an},每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。 Operation ​ InitList (*L):初始化操作，建立一个空的线性表L。 ​ ListEmpty(L)：若线性表为空，返回true，否则返回false。 ​ ClearList(*L)：将线性表清空。 ​ GetElem(L,i,*e)：在线性表L中的第i个位置元素值返回给e。 ​ LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败。 ​ ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。 ​ ListDelete(L,i, e)：删除线性表L中的第i个位置元素，并用e返回其值。 ​ ListLength(L)：返回线性表L的元素个数。 endADT 线性表的顺序存储结构顺序存储定义 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 顺序存储方式一维数组来实现顺序存储结构。 数组长度与线性表长度区别数组的长度是存放线性表的存储空间的长度。线性表的长度是线性表中数据元素的个数。在任意时刻，线性表的长度应该小于等于数组的长度。 地址计算方法存储器中每个存储单元都有自己的编号，这个编号称为地址。 LOC(ai) = LOC(a1) + (i-1)*c 存取的时间性能为O(1)。 顺序存储结构的插入与删除获得元素操作只要i的数值在数组的下标范围内，就是把数组的第i-1下标的值返回即可。 插入操作插入算法的思路： 如果插入位置不合理，抛出异常； 如果线性表的长度大于等于数组长度，则抛出异常或动态增加容量； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置； 将要插入元素填入位置i处； 表长加1。 删除操作删除算法的思路： 如果删除位置不合理，抛出异常； 取出删除元素； 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置； 表长减1。 插入和删除的时间复杂度，最好情况为O(1)，最坏情况为O(n)，平均时间复杂度为O(n)。 线性表顺序存储结构的优缺点优点： 无须为表示表中元素之间的逻辑关系而增加额外的存储空间。 可以快速地存取表中任一位置的元素。 缺点： 插入和删除操作需要移动大量元素。 当线性表长度变化较大时，难以确定存储空间的容量。 造成存储空间的”碎片”。 线性表的链式存储结构线性表链式存储结构定义​ 为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。 ​ n个结点(ai的存储映像)链结成一个链表，即为线性表(a1,a2,…,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。 ​ 链表中的第一个结点的存储位置叫做头指针。在单链表的第一个结点前附设一个结点，称为头结点。头结点的指针域存储指向第一个结点的指针。 线性表链式存储结构代码描述单链表中，我们在C语言中可用结构指针来描述。 1234567/*线性表的单链表存储结构*/typedef struct Node{ ElemType data; struct Node *next;} Node;typedef struct Node *LinkList; /*定义LinkList*/ 单链表的读取获取链表第i个数据的算法思路： 声明一个指针p指向链表的第一个结点，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，返回结点p的数据。 单链表的插入与删除单链表的插入单链表第i个数据插入结点的算法思路： 声明一指针p指向链表头结点，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，在系统中生成一个空节点s； 将数据元素e赋值给s-&gt;data; 单链表的插入标准语句s-&gt;next = p-&gt;next; p-&gt;next = s; 返回成功。 单链表的删除单链表第i个数据删除结点的算法思路： 声明一指针p指向链表头指针，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，将欲删除的结点p-&gt;next赋值给q； 单链表的删除标准语句p-&gt;next = q-&gt;next; 将q结点中的数据赋值给e，作为返回； 释放q结点。 返回成功。 单链表的整表创建头插法 尾插法 单链表的整表删除单链表整表删除的算法思路如下： 声明一节点p和q； 将第一个结点赋值给p； 循环： 将下一个结点赋值给q； 释放p； 将q赋值给p。 单链表结构与顺序存储结构优缺点存储分配方式 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。 单链表采用链式存储结构，用一组任意的存储单元存放线性表中的元素。 时间性能 查找 顺序存储结构O(1) 单链表O(n) 插入和删除 顺序存储结构需要平均移动表长一半的元素，时间为O(n) 单链表在显出某位置的指针后，插入和删除时间仅为O(1) 空间性能 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。 静态链表用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。 静态链表优缺点 优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 缺点： 没有解决连续存储分配带来的表长难以确定的问题。 失去了顺序存储结构随机性存取的特性。 循环链表将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)。 双向链表双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。","link":"/blog/DataStructurePart2/"},{"title":"Effective Objective-C 2.0（第2章）","text":"编写高质量iOS与OS X代码的52个有效方法第2章 对象、消息、运行期 6.理解“属性”这一概念 可以使用 @synthesize 语法来指定实例变量的名字。 @dynamic 关键字会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。而且，在编译器访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。 atomic同步锁会严重影响性能，并且并不能保证线程安全。所以使用nonatomic。 atomic为什么不能保证线程安全？例：一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。 7.在对象内部尽量直接访问实例变量在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写（set方法，为了触发KVO）。在初始化方法和dealloc方法中，总是应该直接通过实例变量来读写数据。使用懒加载时，需要通过属性来读取数据。（get方法） 8.理解“对象等同性”这一概念== 比较的是两个指针本身，而不是所指的对象。isEqual 比较的两个对象。相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。不要盲目地逐个检测每条属性，而是应该依照具体需求来制定监测方案。编写hash方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。 9.以“类族模式”隐藏实现细节 类族模式可以把实现细节隐藏在一套简单的公共接口后面。 系统框架中经常使用类族。 从类族的公共抽象基类中继承子类时要当心。 10.在既有类中使用关联对象存放自定义数据objc_setAssociatedObjectobjc_getAssociatedObjectobjc_removeAssociatedObject 11.理解objc_msgSend的作用 消息由接收者、选择子及参数构成。给某对象发送消息也就相当于在该对象上调用方法。 发给某对象的全部消息都要由动态消息派发系统来处理，该系统会查出对应的方法，并执行其代码。 12.理解消息转发机制 若对象无法响应某个选择子，则进入消息转发流程。 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的某些选择子转交给其他对象来处理。 经过上述两步后，如果还是没办法处理选择子，那就启动完整的消息转发机制。 13.用“方法调配技术”调试“黑盒方法” 在运行期，可以向类中新增或替换选择子所对应的方法实现。 使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常使用此技术向原有实现中添加新功能。 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 14.理解“类对象”的用意 每个实例都有一个指向Class对象的指针，用以表明其类型，而这些Class对象则构成了类的继承体系。 如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。","link":"/blog/EffectiveObjectiveCPart2/"},{"title":"Effective Objective-C 2.0（第5章）","text":"编写高质量iOS与OS X代码的52个有效方法第5章 内存管理 29.理解引用计数 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。 在对象的生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 30.以ARC简化引用计数 有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可以省去类中许多“样板代码”。 ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。 由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则。 ARC只负责管理Objective-C对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。 31.在dealloc方法中只释放引用并解除监听 在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观察”(KVO)或NSNotificationCenter等通知，不要做其他事情。 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法。 执行异步任务的方法不应在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。 32.编写“异常安全代码”时留意内存管理问题 捕获异常时，一定要注意将try块内所创立的对象清理干净。 在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 33.以弱引用避免保留环 将某些引用设为weak，可避免出现“保留环”。 weak引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着ARC而引人的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。 34.以“自动释放池块”降低内存峰值 自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。 合理运用自动释放池，可降低应用程序的内存峰值。 @autoreleasepool这种新式写法能创建出更为轻便的自动释放池。 35.用“僵尸对象”调试内存管理问题 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled可开启此功能。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 36.不要使用retainCount 对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”（absolute retain count）都无法反应对象生命周期的全貌。 引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。","link":"/blog/EffectiveObjectiveCPart5/"},{"title":"Effective Objective-C 2.0（第3章）","text":"编写高质量iOS与OS X代码的52个有效方法第3章 接口与API设计 15.用前缀避免命名空间冲突 选择与你的公司、应用程序或者二者皆有关联之名作为类名的前缀，并在所有代码中均使用这一前缀。 若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。 16.提供“全能初始化方法” 在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。 若全能初始化方法与超类不同，则需覆写超类中的对应方法。 如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。 17.实现description方法 实现description方法返回一个有意义的字符串，用以描述该实例。 若想在调试时打印出更详尽的对象描述信息，则应实现debugDescription方法。 18.尽量使用不可变对象 尽量创建不可变的对象。 若某属性仅可用于对象内部修改，则在“class-continuation分类”中将其由readonly属性扩展为readwrite属性。 不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。 19.使用清晰而协调的命名方式 起名时应遵从标准的Objective-C命名规范，这样创建出来的接口更容易为开发者所理解。 方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。 方法名里不要使用缩略后的类型名称。 给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。 20.为私有方法名加前缀 给私有方法的名称加上前缀，这样可以很容易的将其同公共方法区分开。 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。 21.理解 Objective-C错误模型 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。 在错误不那么严重的情况下，可以指派委托方法（delegate method）来处理错误，也可以把错误信息放在NSError对象里，经由“输出参数”返回给调用者。 22.理解 NSCopying协议 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。 如果自定义的对象分为可变版本和不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。 复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应尽量执行浅拷贝。 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。","link":"/blog/EffectiveObjectiveCPart3/"},{"title":"Effective Objective-C 2.0（第4章）","text":"编写高质量iOS与OS X代码的52个有效方法第4章 协议与分类 23.通过委托与数据源协议进行对象间通信 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式亦称“数据源协议”（data source protocal）。 若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。 24.将类的实现代码分散到便于管理的数个分类之中 使用分类机制把类的实现代码划分成易于管理的小块。 将应该视为“私有”的方法归入名叫Private的分类中，以隐藏实现细节。 25.总是为第三方类的分类名称加前缀 向第三方类中添加分类时，总应给其名称加上你专用的前缀。 向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。 26.勿在分类中声明属性 把封装数据所用的全部属性都定义在主接口里。 在“class-continuation分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性。 27.使用“class-continuation分类”隐藏实现细节 通过“class-continuation分类”向类中新增实例变量。 如果某属性在主接口中声明为“只读”，而类的内部又要用设置方法修改此属性，那么就在“class-continuation分类”中将其扩展为“可读写”。 把私有方法的原型声明在“class-continuation分类”里面。 若想使类所遵循的协议不为人所知，则可于“class-continuation分类”中声明。 28.通过协议提供匿名对象 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法。 使用匿名对象来隐藏类型名称（或类名）。 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示。","link":"/blog/EffectiveObjectiveCPart4/"},{"title":"Effective Objective-C 2.0（第7章）","text":"编写高质量iOS与OS X代码的52个有效方法第7章 系统框架 47.熟悉系统框架将一系列代码封装为动态库（dynamic library），并在其中放入描述其接口的头文件，这样做出来的东西就叫框架。有时为iOS平台构建的第三方框架所使用的是静态库（static library），这是因为iOS应用程序不允许在其中包含动态库。这些东西严格来讲并不是真正的框架，然而也经常视为框架。不过，所有iOS平台的系统框架仍然使用动态库。 要点 许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。 很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。 请记住：用纯C写成的框架与用Objective-C写成的一样重要，若想成为优秀的Objective-C开发者，应该掌握C语言的核心概念。 48.多用块枚举，少用for循环 for 循环 使用Objective-C 1.0 的 NSEnumerator来遍历 快速遍历 基于块的遍历方式1- (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block 要点 遍历collection有四种方式。最基本的办法是for循环，其次是NSEnumerator遍历法及快速遍历法，最新、最先进的方式是“块枚举法”。 “块枚举法”本身就能通过GCD来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。 若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。 49.对自定义其内存管理语义的collection使用无缝桥接__bridge 要点 通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。 在CoreFoundation层面创建collection时，可以指定许多回调函数，将其转换成具备特殊内存管理予以的Objective-C collection。 50.构建缓存时选用NSCache而非NSDictionaryNSCache是线程安全的。而NSDictionary则绝对不具备此优势，意思就是：在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问NSCache。 要点 实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是“线程安全的”，此外，它与字典不同，并不会拷贝键。 可以给NSCache对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”（hard limit），它们仅对NSCache起指导作用。 将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。 如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。 51.精简initialize与load的实现代码要点 在加载阶段，如果累实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。 首次使用到某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类。 load与initialize方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入“依赖环”（interdependency cycle）的几率。 无法在编译期设定的全局变量，可以放在initialize方法里初始化。 52.别忘了NSTimer会保留其目标对象要点 NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完成任务之后也会失效。 反复执行任务的计时器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定户籍导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。 可以扩充NSTimer的功能，用“块”来打破保留环。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。","link":"/blog/EffectiveObjectiveCPart7/"},{"title":"Markdown常用语法","text":"Markdown常用语法 1. 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 预览一级标题二级标题三级标题四级标题五级标题六级标题2. 列表2.1 无序列表123- 文本1- 文本2- 文本3 预览 文本1 文本2 文本3 2.2 有序列表1231. 文本12. 文本23. 文本3 预览 文本1 文本2 文本3 3. 引用在引用的文字前面加上&gt;就可以了 1&gt; 引用的文本 预览 引用的文本 4. 粗体和斜体、删除文本4.1 粗体用两个*包含一段文本即是粗体 4.2 斜体用一个*包含一段文本即是斜体 4.3 删除文本用~~包含一段文本即是删除文本123**粗体文本***斜体文本*~~删除文本~~ 预览粗体文本斜体文本删除文本 5. 代码引用5.1 单行代码引用代码时，如果引用的语句只有一行，可以用·(英文输入状态下左上角~下边的点)将语句包起来1`Markdown` 预览Markdown 5.2 多行代码引用多行代码时，使用···（英文输入状态下左上角~下边的点）置于这段代码的首行和末行12345···func printHello() { print(&quot;hello&quot;)}··· 预览123func printHello() { print(&quot;hello&quot;)} 6. 图片和链接6.1 图片使用![图片名字](图片链接地址) 6.2 链接使用[链接名字](链接地址) 示例12![头像](https://chanceli.com/images/avatar-small.png)[百度](https://www.baidu.com) 预览百度 7. 分割线***或--- 示例1--- 预览 8. 表格---上面表示表头，下面表示表身，:在左边表示居左，在两边表示居中，在右边表示居右，不写:的话表头默认居中，表身默认居左。 示例12345| 居左表头1 | 居中表头2 | 居右表头3 || :---------- |:---------: | -----: || 第1行文本 | 第1行文本 | 第1行文本 || 第2行文本 | 第2行文本 | 第2行文本 || 第3行文本 | 第3行文本 | 第3行文本 | 预览 居左表头1 居中表头2 居右表头3 第1行文本 第1行文本 第1行文本 第2行文本 第2行文本 第2行文本 第3行文本 第3行文本 第3行文本","link":"/blog/MarkdownUsage/"},{"title":"RunLoop总结","text":"Runloops是线程相关底层基础的一部分。它的本质和字面意思一样运行着的循环（事件处理的循环）。作用：接受循环事件和安排线程的工作。目的：让线程在有任务的时候忙于工作，而没有任务的时候处于休眠状态。 RunLoop概念Runloop运行循环iOS中通常所说的Runloop指的是NSRunloop（Foundation框架）或者CFRunloopRef（CoreFoundation框架），CFRunloopRef是纯C的函数，而NSRunloop仅仅是CFRunloopRef的一层OC封装。 RunLoop作用 保持程序的持续运行。 处理App中的各种事件。（如：touches触摸事件、NSTimer定时器事件、Selector事件） 节省CPU资源，提高程序性能（有事情就做事情，没事情就休息，资源释放） 负责渲染屏幕上的所有UI。 RunLoop开启&amp;退出在UIApplicationMain函数内部开启了一个和主线程相关的RunLoop (保证主线程不会被销毁)，导致 UIApplicationMain 不会返回，一直在运行中，也就保证了程序的持续运行。Runloop 的退出条件：App退出；线程关闭；设置最大时间到期。 RunLoop和线程关系 每条线程都有唯一的一个与之对应的Runloop对象。 主线程的RunLoop已经自动创建，子线程的RunLoop需要主动创建。 RunLoop在第一次获取时创建，在线程结束时销毁。 Runloop对象是利用字典来进行存储，Key：线程 Value：线程对应的Runloop。 创建子线程对应的RunLoopcurrentRunLoop RunLoop相关类 CFRunLoopRef: RunLoop本身 CFRunLoopModeRef: 运行模式 CFRunLoopSourceRef: 事件源 CFRunLoopTimerRef: Timer事件 CFRunLoopObserverRef: 观察者（监听者） 一条线程 对应一个 Runloop，Runloop 总是运行在某种特定的CFRunLoopModeRef（运行模式）下。 每个 Runloop 都可以包含若干个 Mode ，每个 Mode 又包含Source源 / Timer事件 / Observer观察者。 在 Runloop 中有多个运行模式，每次调用 RunLoop 的主函数__CFRunloopRun()时，只能指定其中一个 Mode（称 CurrentMode）运行， 如果需要切换 Mode，只能是退出 CurrentMode 切换到指定的 Mode 进入，目的以保证不同 Mode 下的 Source / Timer / Observer 互不影响。 Runloop 有效，mode 里面 至少 要有一个timer(定时器事件) 或者是source(源)。 Mode kCFRunLoopDefaultMode App的默认Mode，通常主线程是在这个Mode下运行。 UITrackingRunLoopMode 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动 UIInitializationRunLoopMode 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes 一种模式组合 Source Source0:非基于端口Port的事件（用于用户主动触发的事件，如：点击按钮或点击屏幕）。 Source：基于端口Port的事件（通过内核和其他线程互相发送消息） TimerNSTimer受RunLoop的Mode影响。GCD定时器不受RunLoop影响。 Observer消息循环中的监听器 RunLoop休眠RunLoop 最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。 RunLoop 的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件 Darwin 中的 Mach 来完成的。","link":"/blog/RunloopSummary/"},{"title":"Runtime总结","text":"一、Runtime是什么？ Runtime 运行时，就是系统在运行的时候的一些机制，其中最主要的是消息机制。Runtime 基本是用C和汇编编写的。 OC与C语言在函数调用上的区别：C语言： 函数的调用在编译的时候就决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。 C语言在编译阶段调用未实现的函数就会报错。 OC： 函数的调用称为消息发送。属于动态调用过程。 在编译的时候并不能决定真正调用哪个函数。在编译阶段，可以调用任何函数，只要函数声明过。 二、与Runtime系统交互：1. 通过OC源代码编译器会自动将OC代码转换成运行时代码，在运行时确定数据结构和函数。 2. NSObject类定义的方法-class-isKindOfClass -isMemberOfClass-respondsToSelector-confirmsToProtocol-methodForSelector 返回指定方法实现的地址 3. 直接调用 Runtime 库函数(Runtime 常用接口方法)object_getClass@selector()class_getClassMethodclass_getInstanceMethodclass_addMethod()class_replaceMethodmethod_exchangeImplementationsclass_copyPropertyListclass_copyMethodListclass_copyProtocolList 三、Runtime相关术语SELidClassMethodIvar 成员变量IMP 是一个函数指针，指向了方法的实现。Cache 四、消息发送和消息转发消息发送 objc_msgSend 通过isa指针找到所属类。 查找类的cache列表, 如果没有则下一步。 查找类的”方法列表”。 如果能找到与选择子名称相符的方法, 就跳至其实现代码。 找不到, 就沿着继承体系继续向上查找。 如果能找到与选择子名称相符的方法, 就跳至其实现代码。 找不到, 执行”消息转发”。 消息转发 动态方法解析 1+ (BOOL)resolveInstanceMethod:(SEL)selector 其他接收者 1- (id)forwardingTargetForSelector:(SEL)selector 消息签名 1- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 完整的消息转发 12- (void)forwardInvocation:(NSInvocation *)invocation// invocation : 封装了与那条尚未处理的消息相关的所有细节的对象 五、Runtime应用 动态添加一个类（KVO的实现原理） 获取一个类的所有属性（1）打印一个类的成员变量列表，属性列表，方法列表（2）动态改变变量的值。（3）在 NSObject 的分类中增加方法，判断是否有该属性，用于避免使用KVC赋值时崩溃。（4）自动归档和解档（5）字典转模型 动态交换方法（1）交换方法（2）替换系统方法（3）实现多继承的效果 动态添加方法 performSelector12resolveInstanceMethodclass_addMethod(self, @selector(eat), eat, &quot;v@:&quot;);","link":"/blog/RuntimeSummary/"},{"title":"我曾七次鄙视我的灵魂（卡里.纪伯伦）","text":"Seven times have I despised my soul: ——Kahlil Gibran The first time when I saw her being meek that she might attain height. The second time when I saw her limping before the crippled. The third time when she was given to choose between the hard and the easy, and she chose the easy. The fourth time when she committed a wrong, and comforted herself that others also commit wrong. The fifth time when she forbore for weakness, and attributed her patience to strength. The sixth time when she despised the ugliness of a face, and knew not that it was one of her own masks. And the seventh time when she sang a song of praise, and deemed it a virtue. 译文我曾七次鄙视我的灵魂 ——卡里.纪伯伦 第一次，当它本可进取时，却故作谦卑； 第二次，当它在空虚时，用爱欲来填充； 第三次，在困难和容易之间，它选择了容易； 第四次，它犯了错，却借由别人也会犯错来宽慰自己； 第五次，它自由软弱，却把它认为是生命的坚韧； 第六次，当它鄙夷一张丑恶的嘴脸时，却不知那正是自己面具中的一副； 第七次，它侧身于生活的污泥中，虽不甘心，却又畏首畏尾。","link":"/blog/SevenTimesHaveIDespisedMySoul/"},{"title":"关于","text":"iOS开发者。 多年iOS开发经验，熟练掌握Objective-C/Swift，开发过多款商业App，业余时间独立开发上架过几款商业App，涉及直播、互联网金融、酒店、医疗、电商等。 邮箱lc@chanceli.com 经历 联想佳沃 新毅 项目 718金融财富、借款、房毅贷 佳沃市集 业余时间独立开发项目：吆趣、酒店会、历真诊疗、医生端","link":"/blog/aboutme/"},{"title":"【iOS 开发】使用环信实现聊天遇到的一些坑","text":"使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。 问题1 聊天页面环信工具栏向上偏移问题描述：在聊天页面，点击输入框弹起键盘，点击IQKeyboardManager带的完成按钮或者点击空白页面收起键盘，反复操作多次后，会出现页面向上偏移，环信UI的工具栏移动到了页面最上边。 解决方案：在聊天页面禁用IQKeyboardManager。123456789101112131415- (void)viewDidAppear:(BOOL)animated{ [super viewDidAppear:animated]; IQKeyboardManager *keyboardManager = [IQKeyboardManager sharedManager]; keyboardManager.enable = NO; keyboardManager.enableAutoToolbar = NO;}- (void)viewWillDisappear:(BOOL)animated{ [super viewWillDisappear:animated]; IQKeyboardManager *keyboardManager = [IQKeyboardManager sharedManager]; keyboardManager.enable = YES; keyboardManager.enableAutoToolbar = YES;} 问题2 保存环信昵称头像到数据库失败问题描述：环信服务器不存储用户的昵称头像等用户数据。需要客户端自己来存储并展示在界面上。有几个时机是需要插入或更新一条包含昵称、头像的用户数据到数据库里，比如查看用户详情，在某个页面收到环信消息。我们服务器提供的查询用户信息接口返回的昵称和头像，之前是没有问题的，有一次出现了从用户信息界面进入聊天页面不显示昵称的问题。 问题原因：经排查，接口返回的用户头像字段的值是null，由于客户端之前没有做空处理，导致插入或更新一条数据失败。12DB Query: INSERT or REPLACE INTO t_huanxin (hxId,nickname,avatar) VALUES (?,?,?)Unknown error finalizing or resetting statement (19: NOT NULL constraint failed: t_huanxin.avatar) 解决方案：存储用户信息到本地数据库时增加安全判断。如果为空，就存入空字符串。避免插入或更新字段为null导致操作失败。12NSString *nickname = dic[@&quot;nickname&quot;]?:@&quot;&quot;;NSString *avatar = dic[@&quot;avatar&quot;]?:@&quot;&quot;; 问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息问题描述：使用环信Demo发送消息，首条消息发送后，下拉刷新，单聊页面会有两条重复的消息。操作步骤：1.点击单聊页面右上角的清空按钮，清空某个用户的消息。2.返回会话列表。3.首次进入该用户的单聊页面。4.发送首条消息。5.页面下拉刷新。6.出现了两条一摸一样的消息。 解决方案：在EMChatViewController的tableViewDidTriggerHeaderRefresh方法中增加如下判断。12345678910- (void)tableViewDidTriggerHeaderRefresh{ //解决首条消息发送后下拉刷新出现两条重复消息的BUG 开始 if (self.dataArray.count &amp;&amp; self.moreMsgId == nil) { [self tableViewDidFinishTriggerHeader:YES reload:NO]; return; } //解决首条消息发送后下拉刷新出现两条重复消息的BUG 结束 other code} 问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录问题描述：iOS环信Demo聊天页面，发送语音，点击“按住录音”，发送了0秒的聊天记录。 解决方案：在EMChatViewController的chatBarRecordAudioViewStopRecord:timeLength:方法中增加对录音时长的判断。123456789101112- (void)chatBarRecordAudioViewStopRecord:(NSString *)aPath timeLength:(NSInteger)aTimeLength{ EMVoiceMessageBody *body = [[EMVoiceMessageBody alloc] initWithLocalPath:aPath displayName:@&quot;audio&quot;]; body.duration = (int)aTimeLength; if (body.duration == 0) { NSLog(@&quot;录音时长为0&quot;); NSLog(@&quot;录制时间过短，不能发送&quot;); return; } [self _sendMessageWithBody:body ext:nil isUpload:YES];} 问题5 聊天页面点击查看图片，图片右上角按钮显示Done问题描述：聊天页面，点击查看图片，图片右上角的按钮显示Done，而不是”完成“。 解决方案：直接全局搜索Done,把环信UI里的Done,替换成”完成“即可。 问题6 如何实现推送消息内容自定义问题描述：不想使用环信默认的推送内容：”您有一条新消息”，或”xxx：消息内容”。想实现自定义的消息内容。 解决方案：发送消息扩展里添加字段em_apns_ext12345{nickname:&quot;王小二&quot;,avatar:&quot;http://www.baidu.com&quot;,em_apns_ext:{&quot;em_push_content&quot;:&quot;自定义推送内容&quot;}} 参考链接：环信APNs 内容解析文档 问题7 头像链接与路由短链冲突问题描述：项目里点击推送通知到落地页采用了路由模式，有一个场景是需要我们自己服务器发推送点击通知栏跳转到聊天页面。路由短链类似：page://chat?from=hxId_10086,由于某些原因，需要带上昵称和头像，加上头像链接后，短链变成了page://chat?from=hxId_10086&amp;avatar=http://www.baidu.com&amp;nickname=王小二，iOS 解析短链的方法是先把短链字符串转成了URL，加了avatar参数之后，转换失败，导致无法跳转。 解决方案： 方案1：由于短链中含有URL，其实违反了路由链接设计的初衷，可以把avatar的值用AES加密一下传输，避免出现链接。 方案2：不把短链字符串转换成URL，直接处理短链，去解析。","link":"/blog/imeasemob/"},{"title":"Hello World.","text":"Hello World.你好，世界。","link":"/blog/helloworld/"},{"title":"iOS 代码规范","text":"原则 长的、描述性的方法和变量命名是好的命名方式。不要使用简写，除非是一些大家都知道的场景比如 VIP。不要使用 bgView，推荐使用 backgroundView。 见名知意。含义清楚，做好不加注释代码自我表述能力强。（前提是代码足够规范） 不要过分追求技巧，降低代码可读性。 删除没必要的代码。比如我们新建一个控制器，里面会有一些不会用到的代码，或者注释起来的代码，如果这些代码不需要，那就删除它，留着偷懒吗？下次需要自己手写。 在方法内部不要重复计算某个值，适当的情况下可以将计算结果缓存起来。 尽量减少单例的使用。 提供一个统一的数据管理入口，不管是 MVC、MVVM、MVP 模块内提供一个统一的数据管理入口会使得代码变得更容易管理和维护。 除了 .m 文件中方法，其他的地方”{“不需要另起一行。 123456789101112131415161718- (void)getGooodsList{ // ...}- (void)doHomework{ if (self.hungry) { return; } if (self.thirsty) { return; } if (self.tired) { return; } papapa.then.over;} 变量 一个变量最好只有一个作用，切勿为了节省代码行数，觉得一个变量可以做多个用途。（单一原则） 方法内部如果有局部变量，那么局部变量应该靠近在使用的地方，而不是全部在顶部声明全部的局部变量。 运算符 1元运算符和变量之间不需要空格。例如：++n 2元运算符与变量之间需要空格隔开。例如： containerWidth = 0.3 * Screen_Width当有多个运算符的时候需要使用括号来明确正确的顺序，可读性较好。例如：2 &lt;&lt; (1 + 2 * 3 - 4) 条件表达式 当有条件过多、过长的时候需要换行，为了代码看起来整齐些。 123456789//goodif (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) { // Do something}//badif (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4(）) { // Do something } 在一个代码块里面有个可能的情况时善于使用 return 来结束异常的情况。 12345678910111213- (void)doHomework{ if (self.hungry) { return; } if (self.thirsty) { return; } if (self.tired) { return; } papapa.then.over;} 每个分支的实现都必须使用 {} 包含。 123456// badif (self.hungry) self.eat() // goodif (self.hungry) { self.eat()} 条件判断的时候应该是变量在左，条件在右。 if ( currentCursor == 2 ) { //… } switch 语句后面的每个分支都需要用大括号括起来。 switch 语句后面的 default 分支必须存在，除非是在对枚举进行 switch。123456789101112131415161718switch (menuType) { case menuTypeLeft: { // ... break; } case menuTypeRight: { // ... break; } case menuTypeTop: { // ... break; } case menuTypeBottom: { // ... break; }} 类名 大写驼峰式命名。每个单词首字母大写。比如「申请记录控制器」ApplyRecordsViewController 每个类型的命名以该类型结尾。 ViewController：使用 ViewController 结尾。例子：ApplyRecordsViewController View：使用 View 结尾。例子：分界线：boundaryView NSArray：使用 s 结尾。比如商品分类数据源。categories UITableViewCell：使用 Cell 结尾。比如 MyProfileCell Protocol：使用 Delegate 或者 Datasource 结尾。比如 XQScanViewDelegate Tool：工具类 代理类：Delegate Service 类：Service 类的注释有时候我们需要为我们创建的类设置一些注释。我们可以在类的下面添加。 枚举枚举的命名和类的命名相近。123456typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) { UIControlContentVerticalAlignmentCenter = 0, UIControlContentVerticalAlignmentTop = 1, UIControlContentVerticalAlignmentBottom = 2, UIControlContentVerticalAlignmentFill = 3,}; 宏 全部大写，单词与单词之间用 _ 连接。 以 K 开头。后面遵循大写驼峰命名。「不带参数」12#define HOME_PAGE_DID_SCROLL @&quot;com.xq.home.page.tableview.did.scroll&quot;#define KHomePageDidScroll @&quot;com.xq.home.page.tableview.did.scroll&quot; 属性书写规则，基本上就是 @property 之后空一格，括号，里面的 线程修饰词、内存修饰词、读写修饰词，空一格 类 对象名称 根据不同的场景选择合适的修饰符。1234@property (nonatomic, strong) UITableView *tableView;@property (nonatomic, assign, readonly) BOOL loading; @property (nonatomic, weak) id&lt;#delegate#&gt; delegate;@property (nonatomic, copy) &lt;#returnType#&gt; (^&lt;#Block#&gt;)(&lt;#parType#&gt;); 单例单例适合全局管理状态或者事件的场景。一旦创建，对象的指针保存在静态区，单例对象在堆内存中分配的内存空间只有程序销毁的时候才会释放。基于这种特点，那么我们类似 UIApplication 对象，需要全局访问唯一一个对象的情况才适合单例，或者访问频次较高的情况。我们的功能模块的生命周期肯定小于 App 的生命周期，如果多个单例对象的话，势必 App 的开销会很大，糟糕的情况系统会杀死 App。如果觉得非要用单例比较好，那么注意需要在合适的场合 tearDown 掉。 单例的使用场景概括如下： 控制资源的使用，通过线程同步来控制资源的并发访问。 控制实例的产生，以达到节约资源的目的。 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。 私有变量推荐以_开头，写在 .m 文件中。例如NSString * _somePrivateVariable 代理方法 类的实例必须作为方法的参数之一。 对于一些连续的状态的，可以加一些 will（将要）、did（已经） 以类的名称开头123- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath; 方法 方法与方法之间间隔一行 大量的方法尽量要以组的形式放在一起，比如生命周期函数、公有方法、私有方法、setter &amp;&amp; getter、代理方法.. 方法最后面的括号需要另起一行。遵循 Apple 的规范 对于其他场景的括号，括号不需要单独换行。比如 if 后面的括号。 如果方法参数过多过长，建议多行书写。用冒号进行对齐。 一个方法内的代码最好保持在50行以内，一般经验来看如果一个方法里面的代码行数过多，代码的阅读体验就很差（别问为什么，做过重构代码行数很长的人都有类似的心情） 一个函数只做一个事情，做到单一原则。所有的类、方法设计好后就可以类似搭积木一样实现一个系统。 对于有返回值的函数，且函数内有分支情况。确保每个分支都有返回值。 函数如果有多个参数，外部传入的参数需要检验参数的非空、数据类型的合法性，参数错误做一些措施：立即返回、断言。 多个函数如果有逻辑重复的代码，建议将重复的部分抽取出来，成为独立的函数进行调用 方法如果有多个参数的情况下需要注意是否需要介词和连词。很多时候在不知道如何抉择测时候思考下苹果的一些 API 的方法命名。 123456789//good- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//bad- (instancetype)initWithAge:(NSInteger)age andName:(NSString *)name;- (void)tableView:(UITableView *)tableView :(NSIndexPath *)indexPath; .m 文件中的私有方法需要在顶部进行声明 方法组之间也有个顺序问题。 在文件最顶部实现属性的声明、私有方法的声明（很多人省去这一步，问题不大，但是蛮多第三方的库都写了，看起来还是会很方便，建议书写）。 在生命周期的方法里面，比如 viewDidLoad 里面只做界面的添加，而不是做界面的初始化，所有的 view 初始化建议放在 getter 里面去做。往往 view 的初始化的代码长度会比较长、且一般会有多个 view 所以 getter 和 setter 一般建议放在最下面，这样子顶部就可以很清楚的看到代码的主要逻辑。 所有button、gestureRecognizer 的响应事件都放在这个区域里面，不要到处乱放。 文件基本上就是123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129#import &quot;ViewController.h&quot;/*ViewController*//*View&amp;&amp;Util*//*model*//*NetWork InterFace*//*Vender*/@interface ViewController ()@end@implementation ViewController#pragma mark - life cycle- (void)viewWillAppear:(BOOL)animated{[super viewDidAppear:animated];}- (void)viewDidAppear:(BOOL)animated{[super viewDidAppear:animated];}- (void)viewDidLoad{[super viewDidLoad];self.title = @&quot;标准模版&quot;;}- (void)viewWillDisappear:(BOOL)animated{[super viewDidAppear:animated];}- (void)viewDidDisappear:(BOOL)animated{[super viewDidAppear:animated];}- (void)dealloc{NSLog(@&quot;%s&quot;,__func__);}#pragma mark - public Method#pragma mark - private method#pragma mark - event response#pragma mark - UITableViewDelegate#pragma mark - UITableViewDataSource//...(多个代理方法依次往下写)#pragma mark - getters and setters@end 图片资源 单个文件的命名 文件资源的命名也需要一定的规范，形式为：功能模块名_类别_功能_状态@nx.png Setting_Button_search_selected@2x.png、Setting_Button_search_selected@3x.png Setting_Button_search_unselected@2x.png、Setting_Button_search_unselected@3x.png 资源的文件夹命名 最好也参考 App 按照功能模块建立对应的实体文件夹目录，最后到对应的目录下添加相应的资源文件。 注释 对于类的注释写在当前类文件的顶部 对于属性的注释需要写在属性后面的地方。 //**&lt;userId*/ 对于 .h 文件中方法的注释，一律按快捷键 command+option+/。三个快捷键解决。按需在旁边对方法进行说明解释、返回值、参数的说明和解释 对于 .m 文件中的方法的注释，在方法的旁边添加 //。 注释符和注释内容需要间隔一个空格。 例如： // fetch goods list 版本规范采用 A.B.C 三位数字命名，比如：1.0.2，当有更新的情况下按照下面的依据 版本号示例A.b.c属于重大内容的更新1.0.2 -&gt; 2.0.0a.B.c属于小部分内容的更新1.0.2 -&gt; 1.1.1a.b.C属于补丁更新1.0.2 -&gt; 1.0.3 原文链接：有了这些你们团队的代码肯定规范","link":"/blog/CodingGuidelines/"},{"title":"Effective Objective-C 2.0（第6章）","text":"编写高质量iOS与OS X代码的52个有效方法第6章 块与大中枢派发 37.理解“块”这一概念 块是C、C++、Objective-C 中的词法闭包。 块可接受参数，也可返回值。 块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。 38.为常用的块类型创建 typedef 以typedef重新定义块类型，可令块变量用起来更加简单。 定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应的 typedef 中的块签名即可，无须改动其他typedef。 39.用 handler 块降低代码分散程度 在创建对象时，可以使用内联的 handler 块将相关业务逻辑一并声明。 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handler 块来实现，则可直接将块与相关对象放在一起。 设计 API 时如果用到了 handler 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行。 40.用块引用其所属对象时不要出现保留环123456- (void)p_requestCompleted { if (_completionHandler) { _completionHandler(_downloadedData); } self.completionHandler = nil;} 只要下载请求执行完毕，保留环就解除了，而获取器对象也将会在必要时为系统所回收。 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。 一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。 41.多用派发队列，少用同步锁锁 同步块（synchronization block） 12345- (void)synchronizedMethod { @synchronized(self) { //Safe }} NSLock锁对象 NSRecursiveLock递归锁 123456_lock = [[NSLock alloc] init];- (void)synchronizedMethod { [_lock lock]; //Safe [_lock unlock];} 缺陷： 在极端情况下，同步块会导致死锁。 效率不见得很高。 直接使用锁对象，一旦遇到死锁，就会非常麻烦。 用atomic来修饰属性，只能提供某种程度的线程安全，无法保证访问该对象时绝对是线程安全的。使用属性时，必然能从中获取到有效值，然而在同一线程上多次调用获取方法（getter），每次获取到的结果未必相同。在两次访问操作之间，其他线程可能会写入新的属性值。 GCD 串行同步队列（serial synchronization queue）12345678910111213_syncQueue = dispatch_queue_create(&quot;com.effectiveObjectivec.syncQueue&quot;,NULL);- (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString;}- (void)setSomeString:(NSString *)someString { dispatch_sync(_syncQueue, ^{ _someString = someString; });} 思路是：把设置操作与获取操作都安排在序列化的队列里执行，这样的话，所有针对属性的访问操作就都同步了。全部加锁任务都在GCD中处理。并发队列（concurrent queue）栅栏（barrier）在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。并发队列如果发现接下来要处理的块是个栅栏块，那么久一直要等栅栏块执行过后，再按正常方式继续向下处理。 要点 派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用@synchronized 块或 NSLock 对象更简单。 将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。 使用同步队列及栅栏块，可以令同步行为更加高效。 42.多用GCD，少用 performSelector 系列方法 performSelector 可能内存泄漏 performSelector 调用了一个方法。编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用ARC的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。 有局限性。 返回值只能是void或对象类型。 参数类型是id，所以只能传入对象。此外，最多只能接受两个参数。 dispatch_syncdispatch_asyncdispatch_after 要点 performSelector 系列方法在内存管理方面容易有疏忽。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。 performSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都收到限制。 如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。 43.掌握GCD及操作队列的使用时机GCD与NSOperationQueue 操作队列在底层是用GCD来实现的。 GCD是纯C的API，而操作队列则是Objective-C的对象。 在GCD中，任务用块来表示，而块是一个轻量级的数据结构。预支相反，“操作”（operation）则是个更为重量级的Objective-C对象。 使用NSOperation及NSOperationQueue的好处： 取消某个操作。运行任务之前，可以在NSOperation对象上调用cancel方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。若是不使用操作队列，而是把块安排在GCD队列，那就无法取消了。开发者可以在应用程序层自己来实现取消功能，不过这样做需要编写很多代码，而那些代码其实已经由操作队列实现好了。 指定操作间的依赖关系。 通过键值观察机制监控NSOperation对象的属性。如isCancelled、isFinished。如果想在某个任务变更其状态时得到通知，或是想用比GCD更为精细的方式来控制所要执行的任务，那么键值观察机制会很有用。 指定操作的优先级。GCD只有队列的优先级，没有任务的优先级。NSOpetation对象也有线程优先级，这决定了运行此操作的线程处在何种优先级上。GCD可以实现此功能，然而操作队列更简单，只需设置一个属性。 重用NSOperation对象。系统的NSNotificationCenter API选用了操作队列而非派发队列，开发者可通过其中的方法来注册监听器，以便在发生相关事件时得到通知，而这个方法接受的参数是块，不是选择子。 要点 在解决多线程与任务管理问题时，派发队列并非唯一方案。 操作队列提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。 44.通过 Dispatch Group 机制，根据系统资源状况来执行任务要点 一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。 通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。 45. 使用dispatch_once来执行只需运行一次的线程安全代码实现单例12345678+ (id)sharedInstance { static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance;} 要点 经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过GCD所提供的 dispatch_once 函数，很容易就能实现此功能。 标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的。 46.不要使用 dispatch_get_current_queue要点 dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试之用。 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。 dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。","link":"/blog/EffectiveObjectiveCPart6/"}],"tags":[{"name":"Effective Objective-C 2.0","slug":"Effective-Objective-C-2-0","link":"/blog/tags/Effective-Objective-C-2-0/"},{"name":"学习笔记","slug":"学习笔记","link":"/blog/tags/学习笔记/"},{"name":"Markdown","slug":"Markdown","link":"/blog/tags/Markdown/"},{"name":"iOS开发","slug":"iOS开发","link":"/blog/tags/iOS开发/"},{"name":"诗和远方","slug":"诗和远方","link":"/blog/tags/诗和远方/"},{"name":"个人简介","slug":"个人简介","link":"/blog/tags/个人简介/"},{"name":"iOS 开发","slug":"iOS-开发","link":"/blog/tags/iOS-开发/"},{"name":"Hello World","slug":"Hello-World","link":"/blog/tags/Hello-World/"},{"name":"代码规范","slug":"代码规范","link":"/blog/tags/代码规范/"}],"categories":[{"name":"Effective Objective-C 2.0","slug":"Effective-Objective-C-2-0","link":"/blog/categories/Effective-Objective-C-2-0/"},{"name":"《大话数据结构》","slug":"《大话数据结构》","link":"/blog/categories/《大话数据结构》/"},{"name":"Markdown","slug":"Markdown","link":"/blog/categories/Markdown/"},{"name":"iOS开发","slug":"iOS开发","link":"/blog/categories/iOS开发/"},{"name":"诗和远方","slug":"诗和远方","link":"/blog/categories/诗和远方/"},{"name":"关于","slug":"关于","link":"/blog/categories/关于/"},{"name":"iOS 开发","slug":"iOS-开发","link":"/blog/categories/iOS-开发/"},{"name":"Hello World","slug":"Hello-World","link":"/blog/categories/Hello-World/"},{"name":"代码规范","slug":"代码规范","link":"/blog/categories/代码规范/"}]}