<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ObjC.vip</title>
  <icon>https://www.gravatar.com/avatar/7f3b33261dd48600587207c66a04554c</icon>
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://objcvip.github.io/"/>
  <updated>2019-09-04T06:56:36.079Z</updated>
  <id>https://objcvip.github.io/</id>
  
  <author>
    <name>ObjC.vip</name>
    <email>objcvip@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题讨论（2019.09.03）</title>
    <link href="https://objcvip.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%A8%E8%AE%BA9.3/"/>
    <id>https://objcvip.github.io/面试题讨论9.3/</id>
    <published>2019-09-03T07:47:00.000Z</published>
    <updated>2019-09-04T06:56:36.079Z</updated>
    
    <content type="html"><![CDATA[<p>面试题讨论9.3</p><a id="more"></a><ol><li>函数和方法的区别。</li><li>地铁离线二维码的实现。</li><li>固定的宽度，如何展示较长的文本。</li><li>消息发送，转发流程，Runtime 交换方法的应用。</li><li>线程间的通信。</li><li>主线程使用同步方法插入同步线程造成阻塞。</li><li>同步、异步与串行、并行  异步与并行的区别。</li><li>怎么理解OC面向对象中的封装？</li><li>NSInterger 占多少个字节。</li><li>self = [super init] 为什么要写 [super init]。</li><li>Block 有几种？</li><li>深拷贝与浅拷贝 NSArray 是深拷贝还是浅拷贝？NSMutableArray 是深拷贝还是浅拷贝？</li><li>[self class] 与 [super class]。</li><li>tableView 的优化，离屏渲染。</li><li>tableView 的复用机制  屏幕上有6个 cell  复用池里有几个 cell 。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试题讨论9.3&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】使用环信实现聊天遇到的一些坑</title>
    <link href="https://objcvip.github.io/imeasemob/"/>
    <id>https://objcvip.github.io/imeasemob/</id>
    <published>2019-08-26T07:47:00.000Z</published>
    <updated>2019-08-27T05:20:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。<br><a id="more"></a></p><h2 id="问题1-聊天页面环信工具栏向上偏移"><a href="#问题1-聊天页面环信工具栏向上偏移" class="headerlink" title="问题1 聊天页面环信工具栏向上偏移"></a>问题1 聊天页面环信工具栏向上偏移</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在聊天页面，点击输入框弹起键盘，点击<code>IQKeyboardManager</code>带的完成按钮或者点击空白页面收起键盘，反复操作多次后，会出现页面向上偏移，环信<code>UI</code>的工具栏移动到了页面最上边。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在聊天页面禁用<code>IQKeyboardManager</code>。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    IQKeyboardManager *keyboardManager =  [IQKeyboardManager sharedManager];</span><br><span class="line">    keyboardManager.enable = NO;</span><br><span class="line">    keyboardManager.enableAutoToolbar = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    IQKeyboardManager *keyboardManager =  [IQKeyboardManager sharedManager];</span><br><span class="line">    keyboardManager.enable = YES;</span><br><span class="line">    keyboardManager.enableAutoToolbar = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题2-保存环信昵称头像到数据库失败"><a href="#问题2-保存环信昵称头像到数据库失败" class="headerlink" title="问题2 保存环信昵称头像到数据库失败"></a>问题2 保存环信昵称头像到数据库失败</h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p>环信服务器不存储用户的昵称头像等用户数据。需要客户端自己来存储并展示在界面上。有几个时机是需要插入或更新一条包含昵称、头像的用户数据到数据库里，比如查看用户详情，在某个页面收到环信消息。我们服务器提供的查询用户信息接口返回的昵称和头像，之前是没有问题的，有一次出现了从用户信息界面进入聊天页面不显示昵称的问题。</p><h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p>经排查，接口返回的用户头像字段的值是<code>null</code>，由于客户端之前没有做空处理，导致插入或更新一条数据失败。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB Query: INSERT or REPLACE INTO t_huanxin (hxId,nickname,avatar) VALUES (?,?,?)</span><br><span class="line">Unknown error finalizing or resetting statement (19: NOT NULL constraint failed: t_huanxin.avatar)</span><br></pre></td></tr></table></figure></p><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>存储用户信息到本地数据库时增加安全判断。如果为空，就存入空字符串。避免插入或更新字段为<code>null</code>导致操作失败。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *nickname = dic[@&quot;nickname&quot;]?:@&quot;&quot;;</span><br><span class="line">NSString *avatar = dic[@&quot;avatar&quot;]?:@&quot;&quot;;</span><br></pre></td></tr></table></figure></p><h2 id="问题3-聊天页面发送首条消息后下拉刷新出现两条重复消息"><a href="#问题3-聊天页面发送首条消息后下拉刷新出现两条重复消息" class="headerlink" title="问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息"></a>问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息</h2><h3 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a>问题描述：</h3><p>使用环信<code>Demo</code>发送消息，首条消息发送后，下拉刷新，单聊页面会有两条重复的消息。<br>操作步骤：1.点击单聊页面右上角的清空按钮，清空某个用户的消息。2.返回会话列表。3.首次进入该用户的单聊页面。4.发送首条消息。5.页面下拉刷新。6.出现了两条一摸一样的消息。</p><h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMChatViewController</code>的<code>tableViewDidTriggerHeaderRefresh</code>方法中增加如下判断。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableViewDidTriggerHeaderRefresh</span><br><span class="line">&#123;</span><br><span class="line">    //解决首条消息发送后下拉刷新出现两条重复消息的BUG 开始</span><br><span class="line">    if (self.dataArray.count &amp;&amp; self.moreMsgId == nil) &#123;</span><br><span class="line">        [self tableViewDidFinishTriggerHeader:YES reload:NO];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //解决首条消息发送后下拉刷新出现两条重复消息的BUG 结束</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题4-聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录"><a href="#问题4-聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录" class="headerlink" title="问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录"></a>问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录</h2><h3 id="问题描述：-3"><a href="#问题描述：-3" class="headerlink" title="问题描述："></a>问题描述：</h3><p><code>iOS</code>环信<code>Demo</code>聊天页面，发送语音，点击“按住录音”，发送了0秒的聊天记录。</p><h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMChatViewController</code>的<code>chatBarRecordAudioViewStopRecord:timeLength:</code>方法中增加对录音时长的判断。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)chatBarRecordAudioViewStopRecord:(NSString *)aPath</span><br><span class="line">                              timeLength:(NSInteger)aTimeLength</span><br><span class="line">&#123;</span><br><span class="line">    EMVoiceMessageBody *body = [[EMVoiceMessageBody alloc] initWithLocalPath:aPath displayName:@&quot;audio&quot;];</span><br><span class="line">    body.duration = (int)aTimeLength;</span><br><span class="line">    if (body.duration == 0) &#123;</span><br><span class="line">        NSLog(@&quot;录音时长为0&quot;);</span><br><span class="line">        NSLog(@&quot;录制时间过短，不能发送&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self _sendMessageWithBody:body ext:nil isUpload:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题5-聊天页面点击查看图片，图片右上角按钮显示Done"><a href="#问题5-聊天页面点击查看图片，图片右上角按钮显示Done" class="headerlink" title="问题5 聊天页面点击查看图片，图片右上角按钮显示Done"></a>问题5 聊天页面点击查看图片，图片右上角按钮显示<code>Done</code></h2><h3 id="问题描述：-4"><a href="#问题描述：-4" class="headerlink" title="问题描述："></a>问题描述：</h3><p>聊天页面，点击查看图片，图片右上角的按钮显示<code>Done</code>，而不是”完成“。</p><h3 id="解决方案：-4"><a href="#解决方案：-4" class="headerlink" title="解决方案："></a>解决方案：</h3><p>直接全局搜索<code>Done</code>,把环信<code>UI</code>里的<code>Done</code>,替换成”完成“即可。</p><h2 id="问题6-如何实现推送消息内容自定义"><a href="#问题6-如何实现推送消息内容自定义" class="headerlink" title="问题6 如何实现推送消息内容自定义"></a>问题6 如何实现推送消息内容自定义</h2><h3 id="问题描述：-5"><a href="#问题描述：-5" class="headerlink" title="问题描述："></a>问题描述：</h3><p>不想使用环信默认的推送内容：”您有一条新消息”，或”xxx：消息内容”。想实现自定义的消息内容。</p><h3 id="解决方案：-5"><a href="#解决方案：-5" class="headerlink" title="解决方案："></a>解决方案：</h3><p>发送消息扩展里添加字段<code>em_apns_ext</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">nickname:&quot;王小二&quot;,</span><br><span class="line">avatar:&quot;http://www.baidu.com&quot;,</span><br><span class="line">em_apns_ext:&#123;&quot;em_push_content&quot;:&quot;自定义推送内容&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="http://docs-im.easemob.com/im/ios/apns/content" target="_blank" rel="noopener">环信 APNs 内容解析文档</a></p><h2 id="问题7-头像链接与路由短链冲突"><a href="#问题7-头像链接与路由短链冲突" class="headerlink" title="问题7 头像链接与路由短链冲突"></a>问题7 头像链接与路由短链冲突</h2><h3 id="问题描述：-6"><a href="#问题描述：-6" class="headerlink" title="问题描述："></a>问题描述：</h3><p>项目里点击推送通知到落地页采用了路由模式，有一个场景是需要我们自己服务器发推送点击通知栏跳转到聊天页面。路由短链类似：<code>page://chat?from=hxId_10086</code>,由于某些原因，需要带上昵称和头像，加上头像链接后，短链变成了<code>page://chat?from=hxId_10086&amp;avatar=http://www.baidu.com&amp;nickname=王小二</code>，<code>iOS</code> 解析短链的方法是先把短链字符串转成了<code>URL</code>，加了<code>avatar</code>参数之后，转换失败，导致无法跳转。</p><h3 id="解决方案：-6"><a href="#解决方案：-6" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>方案1：<br>由于短链中含有<code>URL</code>，其实违反了路由链接设计的初衷，可以把<code>avatar</code>的值用<code>AES</code>加密一下传输，避免出现链接。</li><li>方案2：<br>不把短链字符串转换成<code>URL</code>，直接处理短链，去解析。</li></ul><h2 id="问题8-小程序发的语音消息iOS无法播放"><a href="#问题8-小程序发的语音消息iOS无法播放" class="headerlink" title="问题8 小程序发的语音消息iOS无法播放"></a>问题8 小程序发的语音消息<code>iOS</code>无法播放</h2><h3 id="问题描述：-7"><a href="#问题描述：-7" class="headerlink" title="问题描述："></a>问题描述：</h3><p>小程序发过来的语音消息<code>iOS</code>无法播放。</p><h3 id="问题原因：-1"><a href="#问题原因：-1" class="headerlink" title="问题原因："></a>问题原因：</h3><p><code>Android</code>和<code>iOS</code>发的语音格式都是<code>AMR</code>，小程序发的语音格式是<code>MP3</code>，<code>iOS</code>收到音频后，会先调用<code>_convertAudioFile:</code>方法转换格式，该方法内部实现实现里有一行代码是判断路径是否是<code>MP3</code>文件的，<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[EMAudioPlayerHelper isMP3File:retPath]</span><br></pre></td></tr></table></figure></p><p>这个判断方法有问题，发过来的是<code>MP3</code>，却判断不是<code>MP3</code>，接着音频被当成<code>AMR</code>去转换<code>WAV</code> ，转换音频格式失败，播放失败。</p><h3 id="解决方案：-7"><a href="#解决方案：-7" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMAudioPlayerHelper</code>类中的<code>startPlayerWithPath:model:completion:</code>方法中增加判断，如果含有<code>.mp3</code>，就不转换，直接去播放。不含<code>.mp3</code>，就照旧走<code>_convertAudioFile:</code>转换格式方法。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ([aPath containsString:@&quot;.mp3&quot;]) &#123;</span><br><span class="line">   //不转换</span><br><span class="line">&#125;else &#123;</span><br><span class="line">   aPath = [self _convertAudioFile:aPath];</span><br><span class="line">&#125;</span><br><span class="line">// aPath = [self _convertAudioFile:aPath];</span><br></pre></td></tr></table></figure></p><h3 id="问题扩展："><a href="#问题扩展：" class="headerlink" title="问题扩展："></a>问题扩展：</h3><p><code>iOS</code>发的语音消息，<code>Web</code>/小程序收到后无法播放？<br><code>App</code>端发来的文件是<code>AMR</code>格式的，小程序需要下载的时候转成<code>MP3</code>格式去播放。转换方法如下：<br>参考链接：<a href="http://docs-im.easemob.com/im/web/basics/message#%E9%9F%B3%E9%A2%91%E6%B6%88%E6%81%AF" target="_blank" rel="noopener">环信 Web IM 音频消息文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="https://objcvip.github.io/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="https://objcvip.github.io/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="环信" scheme="https://objcvip.github.io/tags/%E7%8E%AF%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》二</title>
    <link href="https://objcvip.github.io/DataStructurePart2/"/>
    <id>https://objcvip.github.io/DataStructurePart2/</id>
    <published>2019-05-29T09:46:00.000Z</published>
    <updated>2019-09-04T06:58:25.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-线性表"><a href="#第3章-线性表" class="headerlink" title="第3章 线性表"></a>第3章 线性表</h1><p>线性表：零个或多个数据元素的有限序列。</p><a id="more"></a><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><blockquote><p>线性表(List):零个或多个数据元素的有限序列。</p></blockquote><p>线性表元素的个数 n (n&gt;=0) 定义为线性表的长度，当 n = 0时，称为空表。</p><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>ADT 线性表(List)<br>Data<br>​    线性表的数据对象集合为{a<sub>1</sub>,a<sub>2</sub>,……,a<sub>n</sub>},每个元素的类型均为DataType。其中，除第一个元素a<sub>1</sub>外，每一个元素有且只有一个直接前驱元素，除了最后一个元素a<sub>n</sub>外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</p><p>Operation</p><p>​    InitList (*L):初始化操作，建立一个空的线性表L。</p><p>​    ListEmpty(L)：若线性表为空，返回true，否则返回false。</p><p>​    ClearList(*L)：将线性表清空。</p><p>​    GetElem(L,i,*e)：在线性表L中的第i个位置元素值返回给e。</p><p>​    LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败。</p><p>​    ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。</p><p>​    ListDelete(<em>L,i, </em>e)：删除线性表L中的第i个位置元素，并用e返回其值。</p><p>​    ListLength(L)：返回线性表L的元素个数。</p><p>endADT</p><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h3><blockquote><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><p>一维数组来实现顺序存储结构。</p><h3 id="数组长度与线性表长度区别"><a href="#数组长度与线性表长度区别" class="headerlink" title="数组长度与线性表长度区别"></a>数组长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度。线性表的长度是线性表中数据元素的个数。在任意时刻，线性表的长度应该小于等于数组的长度。</p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>存储器中每个存储单元都有自己的编号，这个编号称为地址。</p><p>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i-1)*c</p><p>存取的时间性能为O(1)。</p><h2 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h2><h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>只要i的数值在数组的下标范围内，就是把数组的第i-1下标的值返回即可。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表的长度大于等于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；</li><li>将要插入元素填入位置i处；</li><li>表长加1。</li></ul><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；</li><li>表长减1。</li></ul><p>插入和删除的时间复杂度，最好情况为O(1)，最坏情况为O(n)，平均时间复杂度为O(n)。</p><h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><p>优点：</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间。</li><li>可以快速地存取表中任一位置的元素。</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素。</li><li>当线性表长度变化较大时，难以确定存储空间的容量。</li><li>造成存储空间的”碎片”。</li></ul><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><p>​    为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素a<sub>i</sub>的存储映像，称为结点(Node)。</p><p>​    n个结点(a<sub>i</sub>的存储映像)链结成一个链表，即为线性表(a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。</p><p>​    链表中的第一个结点的存储位置叫做头指针。在单链表的第一个结点前附设一个结点，称为头结点。头结点的指针域存储指向第一个结点的指针。</p><h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p>单链表中，我们在C语言中可用结构指针来描述。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*线性表的单链表存储结构*/</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span> <span class="hljs-comment">/*定义LinkList*/</span></span><br></pre></td></tr></table></figure><h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>获取链表第i个数据的算法思路：</p><ol><li>声明一个指针p指向链表的第一个结点，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，返回结点p的数据。</li></ol><h3 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h3><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>单链表第i个数据插入结点的算法思路：</p><ol><li>声明一指针p指向链表头结点，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，在系统中生成一个空节点s；</li><li>将数据元素e赋值给s-&gt;data;</li><li>单链表的插入标准语句s-&gt;next = p-&gt;next; p-&gt;next = s;</li><li>返回成功。</li></ol><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p>单链表第i个数据删除结点的算法思路：</p><ol><li>声明一指针p指向链表头指针，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q；</li><li>单链表的删除标准语句p-&gt;next = q-&gt;next;</li><li>将q结点中的数据赋值给e，作为返回；</li><li>释放q结点。</li><li>返回成功。</li></ol><h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>头插法</p><p>尾插法</p><h2 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p><ol><li>声明一节点p和q；</li><li>将第一个结点赋值给p；</li><li>循环：<ul><li>将下一个结点赋值给q；</li><li>释放p；</li><li>将q赋值给p。</li></ul></li></ol><h2 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h2><p>存储分配方式</p><ul><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表中的元素。</li></ul><p>时间性能</p><ul><li>查找 顺序存储结构O(1) 单链表O(n)</li><li>插入和删除 顺序存储结构需要平均移动表长一半的元素，时间为O(n) 单链表在显出某位置的指针后，插入和删除时间仅为O(1)</li></ul><p>空间性能</p><ul><li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</li></ul><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。</p><p>静态链表优缺点</p><p>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p><p>缺点：</p><ul><li>没有解决连续存储分配带来的表长难以确定的问题。</li><li>失去了顺序存储结构随机性存取的特性。</li></ul><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-线性表&quot;&gt;&lt;a href=&quot;#第3章-线性表&quot; class=&quot;headerlink&quot; title=&quot;第3章 线性表&quot;&gt;&lt;/a&gt;第3章 线性表&lt;/h1&gt;&lt;p&gt;线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="https://objcvip.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="https://objcvip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》一</title>
    <link href="https://objcvip.github.io/DataStructurePart1/"/>
    <id>https://objcvip.github.io/DataStructurePart1/</id>
    <published>2019-03-05T15:41:00.000Z</published>
    <updated>2019-09-04T06:58:05.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-数据结构绪论"><a href="#第1章-数据结构绪论" class="headerlink" title="第1章 数据结构绪论"></a>第1章 数据结构绪论</h1><a id="more"></a><ul><li>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</li><li>数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</li><li>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</li><li>数据对象：是性质相同的数据元素的集合，是数据的子集。</li><li>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</li></ul><h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><h4 id="1-逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种："><a href="#1-逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种：" class="headerlink" title="1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种："></a>1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种：</h4><ul><li>集合机构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ul><h4 id="2-物理结构：是指数据的逻辑结构在计算机中的存储形式。"><a href="#2-物理结构：是指数据的逻辑结构在计算机中的存储形式。" class="headerlink" title="2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。"></a>2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。</h4><ul><li>顺序存储结构：是把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</li><li>链式存储结构：是把数据元素存放在任意的存储单元里，这组单元可以是连续的，也可以是不连续的。</li></ul><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>数据类型：是指一组性质相同的值得集合及定义在此集合上的一些操作的总称。<br>C语言中，按照取值的不同，可以分为两类：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数组组成的。</li></ul><p>抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。</p><h1 id="第2章-算法"><a href="#第2章-算法" class="headerlink" title="第2章 算法"></a>第2章 算法</h1><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。</p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><ol><li>输入输出</li><li>有穷性</li><li>确定性</li><li>可行性</li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>时间效率高和存储量低</li></ol><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><ol><li>事后统计方法（不科学、不准确）</li><li>事前分析估算方法</li></ol><h2 id="函数的渐近式增长"><a href="#函数的渐近式增长" class="headerlink" title="函数的渐近式增长"></a>函数的渐近式增长</h2><p>函数的渐近增长：给定两个函数 f(n) 和 g(n), 如果存在一个整数N，使得对于所有的 n &gt; N, f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。</p><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><p>在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。</p><h2 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h2><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶存在且不是 1，则去除与这个项相乘的常数。<br>得到的结果就是大 O 阶。</li></ol><h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章-数据结构绪论&quot;&gt;&lt;a href=&quot;#第1章-数据结构绪论&quot; class=&quot;headerlink&quot; title=&quot;第1章 数据结构绪论&quot;&gt;&lt;/a&gt;第1章 数据结构绪论&lt;/h1&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="https://objcvip.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="https://objcvip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代码规范</title>
    <link href="https://objcvip.github.io/CodingGuidelines/"/>
    <id>https://objcvip.github.io/CodingGuidelines/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-09-04T05:59:56.028Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 开发的代码规范。<br><a id="more"></a><br>原文链接：<a href="https://juejin.im/post/5c7c7e0cf265da2ddb298123" target="_blank" rel="noopener">有了这些你们团队的代码肯定规范</a></p><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><ol><li>长的、描述性的方法和变量命名是好的命名方式。不要使用简写，除非是一些大家都知道的场景比如 VIP。不要使用 bgView，推荐使用 backgroundView。</li><li>见名知意。含义清楚，做好不加注释代码自我表述能力强。（前提是代码足够规范）</li><li>不要过分追求技巧，降低代码可读性。</li><li>删除没必要的代码。比如我们新建一个控制器，里面会有一些不会用到的代码，或者注释起来的代码，如果这些代码不需要，那就删除它，留着偷懒吗？下次需要自己手写。</li><li>在方法内部不要重复计算某个值，适当的情况下可以将计算结果缓存起来。</li><li>尽量减少单例的使用。</li><li>提供一个统一的数据管理入口，不管是 MVC、MVVM、MVP 模块内提供一个统一的数据管理入口会使得代码变得更容易管理和维护。</li><li>除了 .m 文件中方法，其他的地方”{“不需要另起一行。</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)getGooodsList</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doHomework</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hungry) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.thirsty) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.tired) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    papapa.then.over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li>一个变量最好只有一个作用，切勿为了节省代码行数，觉得一个变量可以做多个用途。（单一原则）</li><li>方法内部如果有局部变量，那么局部变量应该靠近在使用的地方，而不是全部在顶部声明全部的局部变量。</li></ol><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol><li>1元运算符和变量之间不需要空格。例如：<code>++n</code></li><li>2元运算符与变量之间需要空格隔开。例如： <code>containerWidth = 0.3 * Screen_Width</code><br>当有多个运算符的时候需要使用括号来明确正确的顺序，可读性较好。例如：<code>2 &lt;&lt; (1 + 2 * 3 - 4)</code></li></ol><h1 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h1><ol><li><p>当有条件过多、过长的时候需要换行，为了代码看起来整齐些。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//good</span><br><span class="line">if (condition1() &amp;&amp; </span><br><span class="line">    condition2() &amp;&amp; </span><br><span class="line">    condition3() &amp;&amp; </span><br><span class="line">    condition4()) &#123;</span><br><span class="line">  // Do something</span><br><span class="line">&#125;</span><br><span class="line">//bad</span><br><span class="line">if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4(）) &#123; // Do something &#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个代码块里面有个可能的情况时善于使用 return 来结束异常的情况。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)doHomework</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hungry) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.thirsty) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.tired) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    papapa.then.over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个分支的实现都必须使用 {} 包含。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (self.hungry) self.eat() </span><br><span class="line">// good</span><br><span class="line">if (self.hungry) &#123;</span><br><span class="line">    self.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断的时候应该是变量在左，条件在右。 if ( currentCursor == 2 ) { //… }</p></li><li>switch 语句后面的每个分支都需要用大括号括起来。</li><li>switch 语句后面的 default 分支必须存在，除非是在对枚举进行 switch。<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch (menuType) &#123;  </span><br><span class="line">  case menuTypeLeft: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">   &#125;</span><br><span class="line">  case menuTypeRight: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">  case menuTypeTop: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">  case menuTypeBottom: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h1><ol><li>大写驼峰式命名。每个单词首字母大写。比如「申请记录控制器」ApplyRecordsViewController</li><li>每个类型的命名以该类型结尾。</li></ol><ul><li>ViewController：使用 ViewController 结尾。例子：ApplyRecordsViewController</li><li>View：使用 View 结尾。例子：分界线：boundaryView</li><li>NSArray：使用 s 结尾。比如商品分类数据源。categories</li><li>UITableViewCell：使用 Cell 结尾。比如 MyProfileCell</li><li>Protocol：使用 Delegate 或者 Datasource 结尾。比如 XQScanViewDelegate</li><li>Tool：工具类</li><li>代理类：Delegate</li><li>Service 类：Service</li></ul><h1 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h1><p>有时候我们需要为我们创建的类设置一些注释。我们可以在类的下面添加。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举的命名和类的命名相近。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123;</span><br><span class="line">    UIControlContentVerticalAlignmentCenter  = 0,</span><br><span class="line">    UIControlContentVerticalAlignmentTop     = 1,</span><br><span class="line">    UIControlContentVerticalAlignmentBottom  = 2,</span><br><span class="line">    UIControlContentVerticalAlignmentFill    = 3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><ol><li>全部大写，单词与单词之间用 _ 连接。</li><li>以 K 开头。后面遵循大写驼峰命名。「不带参数」<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define HOME_PAGE_DID_SCROLL @&quot;com.xq.home.page.tableview.did.scroll&quot;</span><br><span class="line">#define KHomePageDidScroll @&quot;com.xq.home.page.tableview.did.scroll&quot;</span><br></pre></td></tr></table></figure></li></ol><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>书写规则，基本上就是 @property 之后空一格，括号，里面的 线程修饰词、内存修饰词、读写修饰词，空一格 类 对象名称 根据不同的场景选择合适的修饰符。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UITableView *tableView;</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL loading;   </span><br><span class="line">@property (nonatomic, weak) id&lt;#delegate#&gt; delegate;</span><br><span class="line">@property (nonatomic, copy) &lt;#returnType#&gt; (^&lt;#Block#&gt;)(&lt;#parType#&gt;);</span><br></pre></td></tr></table></figure></p><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>单例适合全局管理状态或者事件的场景。一旦创建，对象的指针保存在静态区，单例对象在堆内存中分配的内存空间只有程序销毁的时候才会释放。基于这种特点，那么我们类似 UIApplication 对象，需要全局访问唯一一个对象的情况才适合单例，或者访问频次较高的情况。我们的功能模块的生命周期肯定小于 App 的生命周期，如果多个单例对象的话，势必 App 的开销会很大，糟糕的情况系统会杀死 App。如果觉得非要用单例比较好，那么注意需要在合适的场合 tearDown 掉。</p><p>单例的使用场景概括如下：</p><ul><li>控制资源的使用，通过线程同步来控制资源的并发访问。</li><li>控制实例的产生，以达到节约资源的目的。</li><li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</li></ul><h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1><p>推荐以<code>_</code>开头，写在 .m 文件中。例如<code>NSString * _somePrivateVariable</code></p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ol><li>类的实例必须作为方法的参数之一。</li><li>对于一些连续的状态的，可以加一些 will（将要）、did（已经）</li><li>以类的名称开头<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>方法与方法之间间隔一行</li><li>大量的方法尽量要以组的形式放在一起，比如生命周期函数、公有方法、私有方法、setter &amp;&amp; getter、代理方法..</li><li>方法最后面的括号需要另起一行。遵循 Apple 的规范</li><li>对于其他场景的括号，括号不需要单独换行。比如 if 后面的括号。</li><li>如果方法参数过多过长，建议多行书写。用冒号进行对齐。</li><li>一个方法内的代码最好保持在50行以内，一般经验来看如果一个方法里面的代码行数过多，代码的阅读体验就很差（别问为什么，做过重构代码行数很长的人都有类似的心情）</li><li>一个函数只做一个事情，做到单一原则。所有的类、方法设计好后就可以类似搭积木一样实现一个系统。</li><li>对于有返回值的函数，且函数内有分支情况。确保每个分支都有返回值。</li><li>函数如果有多个参数，外部传入的参数需要检验参数的非空、数据类型的合法性，参数错误做一些措施：立即返回、断言。</li><li>多个函数如果有逻辑重复的代码，建议将重复的部分抽取出来，成为独立的函数进行调用</li><li><p>方法如果有多个参数的情况下需要注意是否需要介词和连词。很多时候在不知道如何抉择测时候思考下苹果的一些 API 的方法命名。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//good</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//bad</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age andName:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView :(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></li><li><p>.m 文件中的私有方法需要在顶部进行声明 </p></li><li>方法组之间也有个顺序问题。</li></ol><ul><li>在文件最顶部实现属性的声明、私有方法的声明（很多人省去这一步，问题不大，但是蛮多第三方的库都写了，看起来还是会很方便，建议书写）。</li><li>在生命周期的方法里面，比如 viewDidLoad 里面只做界面的添加，而不是做界面的初始化，所有的 view 初始化建议放在 getter 里面去做。往往 view 的初始化的代码长度会比较长、且一般会有多个 view 所以 getter 和 setter 一般建议放在最下面，这样子顶部就可以很清楚的看到代码的主要逻辑。</li><li>所有button、gestureRecognizer 的响应事件都放在这个区域里面，不要到处乱放。</li></ul><p>文件基本上就是<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">/*ViewController*/</span><br><span class="line"></span><br><span class="line">/*View&amp;&amp;Util*/</span><br><span class="line"></span><br><span class="line">/*model*/</span><br><span class="line"></span><br><span class="line">/*NetWork InterFace*/</span><br><span class="line"></span><br><span class="line">/*Vender*/</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">#pragma mark - life cycle</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">self.title = @&quot;标准模版&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - public Method</span><br><span class="line"></span><br><span class="line">#pragma mark - private method</span><br><span class="line"></span><br><span class="line">#pragma mark - event response</span><br><span class="line"></span><br><span class="line">#pragma mark - UITableViewDelegate</span><br><span class="line"></span><br><span class="line">#pragma mark - UITableViewDataSource</span><br><span class="line"></span><br><span class="line">//...(多个代理方法依次往下写)</span><br><span class="line"></span><br><span class="line">#pragma mark - getters and setters</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><ol><li>单个文件的命名 文件资源的命名也需要一定的规范，形式为：<code>功能模块名_类别_功能_状态</code><br>@nx.png <a href="mailto:Setting_Button_search_selected@2x.png" target="_blank" rel="noopener">Setting_Button_search_selected@2x.png</a>、<a href="mailto:Setting_Button_search_selected@3x.png" target="_blank" rel="noopener">Setting_Button_search_selected@3x.png</a> <a href="mailto:Setting_Button_search_unselected@2x.png" target="_blank" rel="noopener">Setting_Button_search_unselected@2x.png</a>、<a href="mailto:Setting_Button_search_unselected@3x.png" target="_blank" rel="noopener">Setting_Button_search_unselected@3x.png</a></li><li>资源的文件夹命名 最好也参考 App 按照功能模块建立对应的实体文件夹目录，最后到对应的目录下添加相应的资源文件。</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li>对于类的注释写在当前类文件的顶部</li><li>对于属性的注释需要写在属性后面的地方。 <code>//**&lt;userId*/</code></li><li>对于 .h 文件中方法的注释，一律按快捷键 <code>command+option+/</code>。三个快捷键解决。按需在旁边对方法进行说明解释、返回值、参数的说明和解释 </li><li>对于 .m 文件中的方法的注释，在方法的旁边添加 //。 </li><li>注释符和注释内容需要间隔一个空格。 例如： // fetch goods list</li></ol><h2 id="版本规范"><a href="#版本规范" class="headerlink" title="版本规范"></a>版本规范</h2><p>采用 A.B.C 三位数字命名，比如：1.0.2，当有更新的情况下按照下面的依据</p><p>版本号示例<br>A.b.c属于重大内容的更新1.0.2 -&gt; 2.0.0<br>a.B.c属于小部分内容的更新1.0.2 -&gt; 1.1.1<br>a.b.C属于补丁更新1.0.2 -&gt; 1.0.3</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 开发的代码规范。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="代码规范" scheme="https://objcvip.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="https://objcvip.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>【算法】用两个栈实现队列</title>
    <link href="https://objcvip.github.io/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://objcvip.github.io/用两个栈实现队列/</id>
    <published>2018-03-06T07:47:00.000Z</published>
    <updated>2019-09-04T05:53:52.842Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈实现队列。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; class Queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        CQueue(void);</span><br><span class="line">        ~CQueue(void);</span><br><span class="line">        void appendTail(const T&amp; node);</span><br><span class="line">        T deleteHead();</span><br><span class="line">private:</span><br><span class="line">        stack&lt;T&gt; stack1;</span><br><span class="line">        stack&lt;T&gt; stack2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">      stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">      if(stack2.size() &lt;= 0)</span><br><span class="line">      &#123;</span><br><span class="line">            while(stack1.size()&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                  T&amp; data = stack1.top();</span><br><span class="line">                  stack1.pop();</span><br><span class="line">                  stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(stack2.size() == 0)</span><br><span class="line">           throw new exception(&quot;queue is empty&quot;);</span><br><span class="line">      T head = stack2.top();</span><br><span class="line">      stack2.pop();</span><br><span class="line">      return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个栈实现队列。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://objcvip.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://objcvip.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【算法】用队列实现栈</title>
    <link href="https://objcvip.github.io/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://objcvip.github.io/用队列实现栈/</id>
    <published>2018-03-05T07:47:00.000Z</published>
    <updated>2019-09-04T05:53:35.557Z</updated>
    
    <content type="html"><![CDATA[<p>用队列实现栈。<br><a id="more"></a><br>思路：每次取值要取队列的队尾元素，数据队列A出队到辅助队列B，留下最后一个元素返回，辅助队列再把元素出队到数据队列。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> queueA: <span class="hljs-type">Queue</span></span><br><span class="line">    <span class="hljs-keyword">var</span> queueB: <span class="hljs-type">Queue</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">init</span>() &#123;</span><br><span class="line">        queueA = <span class="hljs-type">Queue</span>()</span><br><span class="line">        queueB = <span class="hljs-type">Queue</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> isEmpty: <span class="hljs-type">Bool</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> queueA.isEmpty &amp;&amp; queueB.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> peek: <span class="hljs-type">Any</span>? &#123;</span><br><span class="line">        <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">            shift()</span><br><span class="line">            <span class="hljs-keyword">let</span> peekObj = queueA.peek</span><br><span class="line">            queueB.enqueue(queueA.dequeue()!)</span><br><span class="line">            <span class="hljs-built_in">swap</span>()</span><br><span class="line">            <span class="hljs-keyword">return</span> peekObj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> queueA.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(object: <span class="hljs-keyword">Any</span>)</span></span> &#123;</span><br><span class="line">        queueA.enqueue(object)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Any</span>? &#123;</span><br><span class="line">        shift()</span><br><span class="line">        <span class="hljs-keyword">let</span> popObject = queueA.dequeue()</span><br><span class="line">        <span class="hljs-built_in">swap</span>()</span><br><span class="line">        <span class="hljs-keyword">return</span> popObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shift</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> queueA.size != <span class="hljs-number">1</span> &#123;</span><br><span class="line">            queueB.enqueue(queueA.dequeue()!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        (queueA, queueB) = (queueB, queueA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用队列实现栈。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】连续子数组的最大和</title>
    <link href="https://objcvip.github.io/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>https://objcvip.github.io/连续子数组的最大和/</id>
    <published>2018-03-04T07:47:00.000Z</published>
    <updated>2019-09-04T05:53:06.229Z</updated>
    
    <content type="html"><![CDATA[<p>连续子数组的最大和。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。<br>例如，输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为{3, 10, -4, 7, 2}，因此输出该子数组的和 18。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool g_InvalidInput = false;</span><br><span class="line"></span><br><span class="line">int FindGreatestSumOfSubArray(int *pData, int nLength)</span><br><span class="line">&#123;</span><br><span class="line">    if(pData == nullptr) || (nLength &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = true;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    g_InvalidInput = false;</span><br><span class="line">    </span><br><span class="line">    int nCurSum = 0;</span><br><span class="line">    int nGreatestSum = 0x80000000;</span><br><span class="line">    for(int i = 0; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nCurSum &lt;= 0)</span><br><span class="line">            nCurSum = pData[i];</span><br><span class="line">        else</span><br><span class="line">            nCurSum += pData[i];</span><br><span class="line">        if(nCurSum &gt; nGreatestSum)</span><br><span class="line">            nGreatestSum = nCurSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nGreatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;连续子数组的最大和。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】Swift 用数组实现栈</title>
    <link href="https://objcvip.github.io/Swift%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://objcvip.github.io/Swift用数组实现栈/</id>
    <published>2018-03-03T07:47:00.000Z</published>
    <updated>2019-09-04T05:52:20.511Z</updated>
    
    <content type="html"><![CDATA[<p>用数组实现栈。<br><a id="more"></a><br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> stack: [<span class="hljs-type">AnyObject</span>]</span><br><span class="line">    <span class="hljs-keyword">var</span> isEmpty: <span class="hljs-type">Bool</span> &#123; <span class="hljs-keyword">return</span> stack.isEmpty &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> peek: <span class="hljs-type">AnyObject</span>? &#123; <span class="hljs-keyword">return</span> stack.last &#125;</span><br><span class="line">    </span><br><span class="line">    int() &#123;</span><br><span class="line">      stack = [<span class="hljs-type">AnyObject</span>]()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">        stack.append(object)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!isEmpty) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> stack.removeLast()</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用数组实现栈。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://objcvip.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【算法】合并两个数组并去重</title>
    <link href="https://objcvip.github.io/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B9%B6%E5%8E%BB%E9%87%8D/"/>
    <id>https://objcvip.github.io/合并两个数组并去重/</id>
    <published>2018-03-02T07:47:00.000Z</published>
    <updated>2019-09-04T05:52:20.611Z</updated>
    
    <content type="html"><![CDATA[<p>合并两个数组并去重。<br><a id="more"></a><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 合并两个含有nA、nB个元素的有序数组</span><br><span class="line">void Merge(int *a, int *b, int *c, int nA, int nB, int&amp; nCout)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0 ;</span><br><span class="line">    int j = 0 ;</span><br><span class="line">    int k = 0 ;</span><br><span class="line">     </span><br><span class="line">    while (i &lt; nA &amp;&amp; j &lt; nB)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[i] &lt; b[j])// 如果a的元素小，则插入a中元素到c</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = a[i] ;</span><br><span class="line">            ++i ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (a[i] == b[j])// 如果a和b元素相等，则插入二者皆可，这里插入a</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = a[i] ;</span><br><span class="line">            ++i ;</span><br><span class="line">            ++j ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">        else // a[i] &gt; b[j] // 如果b中元素小，则插入b中元素到c</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = b[j] ;</span><br><span class="line">            ++j ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    if (i == nA) // 若a遍历完毕，处理b中剩下的元素</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m = j; m &lt; nB; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = b[m] ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else//j == n, 若b遍历完毕，处理a中剩下的元素</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m = i; m &lt; nA; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = a[m] ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合并两个数组并去重。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】翻转字符串</title>
    <link href="https://objcvip.github.io/%E7%BF%BB%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://objcvip.github.io/翻转字符串/</id>
    <published>2018-03-01T07:47:00.000Z</published>
    <updated>2019-09-04T05:52:05.114Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目：翻转单词顺序。"><a href="#题目：翻转单词顺序。" class="headerlink" title="题目：翻转单词顺序。"></a>题目：翻转单词顺序。</h1><p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。<br><a id="more"></a></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>第一步先翻转句子中所有的字符，比如翻转”I am a student.”中所有的字符得到”.tneduts a ma I”，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词中字符的顺序，就得到了”student. am I”。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void Reverse(char *pBegin, char *pEnd)</span><br><span class="line">&#123;</span><br><span class="line">      if(pBegin == nullptr || pEnd == nullptr)</span><br><span class="line">          return;</span><br><span class="line">      while(pBegin &lt; pEnd)</span><br><span class="line">      &#123;</span><br><span class="line">              char temp = *pBegin;</span><br><span class="line">              *pBegin = *pEnd;</span><br><span class="line">              *pEnd = temp;</span><br><span class="line">              </span><br><span class="line">              pBegin ++, pEnd --;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">char* ReverseSentence(char *pData)</span><br><span class="line">&#123;</span><br><span class="line">    if(pData == nullptr)</span><br><span class="line">          return nullptr;</span><br><span class="line">    char *pBegin = pData;</span><br><span class="line">    char *pEnd = pData;</span><br><span class="line">    while(*pEnd != &apos;\0&apos;)</span><br><span class="line">            pEnd ++;</span><br><span class="line">     pEnd--;</span><br><span class="line"></span><br><span class="line">    //翻转整个句子</span><br><span class="line">    Reverse(pBegin,pEnd);</span><br><span class="line">    </span><br><span class="line">    //翻转句子中的每个单词</span><br><span class="line">    pBegin = pEnd = pData;</span><br><span class="line">    while(*pBegin != &apos;\0&apos;)</span><br><span class="line">    &#123;</span><br><span class="line">          if(*pBegin == &apos;&apos;)</span><br><span class="line">          &#123;</span><br><span class="line">              pBegin ++;</span><br><span class="line">              pEnd ++;</span><br><span class="line">          &#125;</span><br><span class="line">          else if(*pEnd == &apos;&apos; || *pEnd == &apos;\0&apos;)</span><br><span class="line">          &#123;</span><br><span class="line">              Reverse(pBegin,--pEnd);</span><br><span class="line">              pBegin = ++pEnd;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">          &#123;</span><br><span class="line">              pEnd ++;</span><br><span class="line">          &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return pData;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在英语句子中，单词背空格符号分割，因此我们可以通过扫描空格来确定每个单词的起始位置和终止位置。在上述代码的翻转每个单词阶段，指针 pBegin 指向单词的第一个字符，而指针 pEnd 指向单词的最后一个字符。</p><h1 id="Swift实现"><a href="#Swift实现" class="headerlink" title="Swift实现"></a>Swift实现</h1><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">fileprivate</span> <span class="hljs-function"><span class="hljs-keyword">func</span> _reverse&lt;T&gt;<span class="hljs-params">(<span class="hljs-number">_</span> chars: <span class="hljs-keyword">inout</span> [T], <span class="hljs-number">_</span> start: Int, <span class="hljs-number">_</span> end: Int)</span></span> &#123;</span><br><span class="line">  <span class="hljs-keyword">var</span> start = start, end = end</span><br><span class="line">  <span class="hljs-keyword">while</span> start &lt; end &#123;</span><br><span class="line">      _swap(&amp;chars, start, end)</span><br><span class="line">      start += <span class="hljs-number">1</span></span><br><span class="line">      end -= <span class="hljs-number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(s: String?)</span></span> -&gt; <span class="hljs-type">String</span>? &#123;</span><br><span class="line">    <span class="hljs-keyword">guard</span> <span class="hljs-keyword">let</span> s = s <span class="hljs-keyword">else</span> &#123;</span><br><span class="line">         <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> chars = <span class="hljs-type">Array</span>(s.characters), start = <span class="hljs-number">0</span></span><br><span class="line">    _reverse(&amp;chars, <span class="hljs-number">0</span>, chars.<span class="hljs-built_in">count</span> - <span class="hljs-number">1</span>)</span><br><span class="line">    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-number">0</span> ..&lt; chars.<span class="hljs-built_in">count</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> i == chars.<span class="hljs-built_in">count</span> - <span class="hljs-number">1</span> || chars[i + <span class="hljs-number">1</span>] == <span class="hljs-string">" "</span> &#123;</span><br><span class="line">            _reverse(&amp;chars, start, i)</span><br><span class="line">            start = i + <span class="hljs-number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-type">String</span>(chars)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度为O(n)。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目：翻转单词顺序。&quot;&gt;&lt;a href=&quot;#题目：翻转单词顺序。&quot; class=&quot;headerlink&quot; title=&quot;题目：翻转单词顺序。&quot;&gt;&lt;/a&gt;题目：翻转单词顺序。&lt;/h1&gt;&lt;p&gt;输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】斐波那切数列</title>
    <link href="https://objcvip.github.io/%E6%96%90%E6%B3%A2%E9%82%A3%E5%88%87%E6%95%B0%E5%88%97/"/>
    <id>https://objcvip.github.io/斐波那切数列/</id>
    <published>2018-03-01T07:47:00.000Z</published>
    <updated>2019-09-04T05:56:13.059Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目：求斐波那切数列的第-n-项。"><a href="#题目：求斐波那切数列的第-n-项。" class="headerlink" title="题目：求斐波那切数列的第 n 项。"></a>题目：求斐波那切数列的第 n 项。</h1><a id="more"></a><h1 id="解法1："><a href="#解法1：" class="headerlink" title="解法1："></a>解法1：</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">long long Fibonacci(unsigned int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n &lt;= 0)</span><br><span class="line">        return 0;</span><br><span class="line">    if(n == 1)</span><br><span class="line">        return 1;</span><br><span class="line">   return Fibonacci(n-1) + Fibonacci(n-2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归代码之所以慢，是因为重复的计算太多，我们只要想办法避免重复计算就行了。</p><h1 id="解法2："><a href="#解法2：" class="headerlink" title="解法2："></a>解法2：</h1><p>该解法是从下往上计算，首先根据 f(0) 和 f(1) 计算出 f(2)，再根据 f(1) 和 f(2) 算出 f(3)……以此类推就可以算出第 n 项了。很容易理解，这种思路时间复杂度是 O(n)。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">long long Fibonacci(unsigned n)</span><br><span class="line">&#123;</span><br><span class="line">    int result[2] = &#123;0, 1&#125;;</span><br><span class="line">    if(n &lt; 2)</span><br><span class="line">        return result[n];</span><br><span class="line">    long long fibNMinusOne = 1;</span><br><span class="line">    long long fibNMinusTwo = 0;</span><br><span class="line">    long long fibN = 0;</span><br><span class="line">    for(unsigned int i = 2; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">          fibN = fibNMinusOne + fibNMinusTwo;</span><br><span class="line">          fibNMinusTwo = fibNMinusOne;</span><br><span class="line">          fibNMinusOne = fibN;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">      return fibN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目：求斐波那切数列的第-n-项。&quot;&gt;&lt;a href=&quot;#题目：求斐波那切数列的第-n-项。&quot; class=&quot;headerlink&quot; title=&quot;题目：求斐波那切数列的第 n 项。&quot;&gt;&lt;/a&gt;题目：求斐波那切数列的第 n 项。&lt;/h1&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】二分查找</title>
    <link href="https://objcvip.github.io/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://objcvip.github.io/二分查找/</id>
    <published>2018-02-05T07:47:00.000Z</published>
    <updated>2019-09-04T06:11:18.026Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。</p><a id="more"></a><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(log2n)</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">binarySearch</span>&lt;T: Comparable&gt;<span class="hljs-params">(<span class="hljs-number">_</span> a: [T], key: T)</span></span> -&gt; <span class="hljs-type">Int</span>? &#123;    </span><br><span class="line">    <span class="hljs-keyword">var</span> lowerBound = <span class="hljs-number">0</span>    </span><br><span class="line">    <span class="hljs-keyword">var</span> upperBound = a.<span class="hljs-built_in">count</span>    </span><br><span class="line">    <span class="hljs-keyword">while</span> lowerBound &lt; upperBound &#123;        </span><br><span class="line">        <span class="hljs-keyword">let</span> midIndex = lowerBound + (upperBound - lowerBound) / <span class="hljs-number">2</span>        </span><br><span class="line">        <span class="hljs-keyword">if</span> a[midIndex] == key &#123;            </span><br><span class="line">            <span class="hljs-keyword">return</span> midIndex        </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> a[midIndex] &lt; key &#123;            </span><br><span class="line">            lowerBound = midIndex + <span class="hljs-number">1</span>        </span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> &#123;            </span><br><span class="line">            upperBound = midIndex        </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="https://objcvip.github.io/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】选择排序</title>
    <link href="https://objcvip.github.io/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>https://objcvip.github.io/选择排序/</id>
    <published>2018-02-04T07:47:00.000Z</published>
    <updated>2019-09-04T05:48:22.251Z</updated>
    
    <content type="html"><![CDATA[<p>选择排序。<br><a id="more"></a></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果：</p><ol><li>初始状态：无序区为R[1..n]，有序区为空。</li><li><p>第1趟排序:<br>在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。<br>……</p></li><li><p>第i趟排序<br>第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。</p></li></ol><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>平均复杂度为O(n^2)</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">void select_sort(int*a,int n)</span><br><span class="line">&#123;</span><br><span class="line"> </span><br><span class="line">    register int i,j,min,t;</span><br><span class="line"> </span><br><span class="line">    for(i=0;i&lt;n-1;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min=i;//查找最小值</span><br><span class="line"></span><br><span class="line">        for(j=i+1;j&lt;n;j++)</span><br><span class="line"> </span><br><span class="line">            if(a[min]&gt;a[j])</span><br><span class="line"> </span><br><span class="line">                min=j;//交换</span><br><span class="line"> </span><br><span class="line">        if(min!=i)</span><br><span class="line">        &#123;</span><br><span class="line"> </span><br><span class="line">            t=a[min];</span><br><span class="line"> </span><br><span class="line">            a[min]=a[i];</span><br><span class="line"> </span><br><span class="line">            a[i]=t;</span><br><span class="line"> </span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;选择排序。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="选择排序" scheme="https://objcvip.github.io/tags/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法】快速排序</title>
    <link href="https://objcvip.github.io/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>https://objcvip.github.io/快速排序/</id>
    <published>2018-02-03T07:47:00.000Z</published>
    <updated>2019-09-04T05:43:53.225Z</updated>
    
    <content type="html"><![CDATA[<p>快速排序算法。<br><a id="more"></a></p><h1 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h1><p>通过一趟排序将要排序的数分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对着两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><ol><li>设置两个变量i、j，排序开始的时候：i = 0，j = N-1;</li><li>以数组的第一个元素作为关键数据，赋值给key，即key = A[0];</li><li>从j开始向前搜索，即由后开始向前搜索（j–）,找到第一个小于key的值A[j],将A[j]和A[i]互换。</li><li>从i开始向后搜索，即由前开始向后搜索(i++),找到第一个大于key的值A[i],将A[i]和A[j]互换。</li><li>重复第3、4步，直到i=j。<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1>最优情况下，时间复杂度为O(nlogn)。<br>最坏情况下，时间复杂度为O(n^2)。<br>平均情况时间复杂度为O(nlogn)。<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">void sort (int *a, int left, int right)</span><br><span class="line">&#123;</span><br><span class="line">    if (left &gt;= right) //如果左边索引大于或等于右边的索引就代表已经整理完成了。</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = left;</span><br><span class="line">    int j = right;</span><br><span class="line">    int key = a[left];</span><br><span class="line">    while (i &lt; j) </span><br><span class="line">    &#123;</span><br><span class="line">      while (i &lt; j &amp;&amp; key &lt;= a[j])</span><br><span class="line">      &#123;</span><br><span class="line">          j--;</span><br><span class="line">      &#125;</span><br><span class="line">      a[i] = a[j];</span><br><span class="line">      while (i &lt; j &amp;&amp; key &gt;= a[i])</span><br><span class="line">      &#123; </span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">      a[j] = a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    a[i] = key;</span><br><span class="line">    sort (a, left i-1);</span><br><span class="line">    sort (a, i+1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;快速排序算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://objcvip.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法】冒泡排序</title>
    <link href="https://objcvip.github.io/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>https://objcvip.github.io/冒泡排序/</id>
    <published>2018-02-02T07:47:00.000Z</published>
    <updated>2019-09-04T05:47:06.293Z</updated>
    
    <content type="html"><![CDATA[<p>冒泡排序。<br><a id="more"></a></p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><ol><li>比较相邻的元素。如果第一个比第二个大，就交换两个元素。</li><li>对每一对相邻的元素做同样的工作，从开始第一对到结尾最后一对。一次循环后，最后的元素应该会是最大的数。</li><li>针对所有元素重复以上步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><p>外层循环控制数组的容量，内层循环一个一个比较交换排序。</p><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>冒泡排序最好的时间复杂度是O(n)<br>最坏时间复杂度是O(n^2)<br>平均复杂度为O(n^2)<br>冒泡排序是一种稳定的排序算法。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void bubble_sort (int a[], int n);</span><br><span class="line">void bubble_sort (int a[], int n)</span><br><span class="line">&#123; </span><br><span class="line">      int i, j, temp;</span><br><span class="line">      for ( j = 0; j &lt; n; j++) &#123;</span><br><span class="line">          for ( i = 0; i &lt; n-1-j; i++) &#123;</span><br><span class="line">              if (a[i] &gt; a[i + 1]) &#123;</span><br><span class="line">                    temp = a[i];</span><br><span class="line">                    a[i] = a[i + 1];</span><br><span class="line">                    a[i + 1] = temp;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C"></a>Objective-C</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)sort:(NSMutableArray *)array &#123;</span><br><span class="line">for (int i = 0; i &lt; array.count; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; array.count-1-j; j++) &#123;</span><br><span class="line">      NSInteger left = [array[j] integerValue];</span><br><span class="line">      NSInteger right = [array[j+1] integerValue];</span><br><span class="line">      if (left &lt; right) &#123;</span><br><span class="line">        [array exchangeObjectAtIndex:j withObjectAtIndex:j+1];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">NSLog(@&quot;%@&quot;,array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Swift"><a href="#Swift" class="headerlink" title="Swift"></a>Swift</h2><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func bubbleSort(_ array: inout [Int]) &#123;</span><br><span class="line">    let n = array.count</span><br><span class="line">    for i in 0..&lt;n &#123;</span><br><span class="line">      for j in 0..&lt; (n-1-j) &#123;</span><br><span class="line">          if array[j] &gt; array[j+1] &#123;</span><br><span class="line">             array.swapAt (j, j+1)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print(array)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;冒泡排序。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="冒泡排序" scheme="https://objcvip.github.io/tags/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>【算法】排序算法</title>
    <link href="https://objcvip.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>https://objcvip.github.io/排序算法/</id>
    <published>2018-02-01T07:47:00.000Z</published>
    <updated>2019-09-04T05:47:16.286Z</updated>
    
    <content type="html"><![CDATA[<p>排序算法。<br><a id="more"></a></p><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><p><img src="https://upload-images.jianshu.io/upload_images/822370-cf39c6e47bc8a0cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="排序算法"></p><h2 id="非线性时间比较类排序"><a href="#非线性时间比较类排序" class="headerlink" title="非线性时间比较类排序"></a>非线性时间比较类排序</h2><h3 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h3><ul><li><a href="https://www.jianshu.com/p/9621dc5ff1a4" target="_blank" rel="noopener">冒泡排序</a></li><li><a href="https://www.jianshu.com/p/c76f04ece973" target="_blank" rel="noopener">快速排序</a><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3></li><li><a href="">插入排序</a></li><li><a href="">希尔排序</a><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3></li><li><a href="https://www.jianshu.com/p/4b1bfc1a1581" target="_blank" rel="noopener">简单选择排序</a></li><li><a href="">堆排序</a><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3></li><li><a href="">二路归并排序</a></li><li><a href="">多路归并排序</a><h2 id="线性时间非比较类排序"><a href="#线性时间非比较类排序" class="headerlink" title="线性时间非比较类排序"></a>线性时间非比较类排序</h2></li><li><a href="">计数排序</a></li><li><a href="">桶排序</a></li><li><a href="">基数排序</a><h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><img src="https://upload-images.jianshu.io/upload_images/822370-e8734d4bca578ccc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="时间复杂度"><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">十大经典排序算法</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;排序算法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="排序" scheme="https://objcvip.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第7章）</title>
    <link href="https://objcvip.github.io/EffectiveObjectiveCPart7/"/>
    <id>https://objcvip.github.io/EffectiveObjectiveCPart7/</id>
    <published>2018-01-06T16:07:00.000Z</published>
    <updated>2018-12-06T10:04:13.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第7章-系统框架"><a href="#第7章-系统框架" class="headerlink" title="第7章 系统框架"></a>第7章 系统框架</h3><a id="more"></a><h4 id="47-熟悉系统框架"><a href="#47-熟悉系统框架" class="headerlink" title="47.熟悉系统框架"></a>47.熟悉系统框架</h4><p>将一系列代码封装为动态库（dynamic library），并在其中放入描述其接口的头文件，这样做出来的东西就叫框架。有时为iOS平台构建的第三方框架所使用的是静态库（static library），这是因为iOS应用程序不允许在其中包含动态库。这些东西严格来讲并不是真正的框架，然而也经常视为框架。不过，所有iOS平台的系统框架仍然使用动态库。</p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ul><li>许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。</li><li>很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。</li><li>请记住：用纯C写成的框架与用Objective-C写成的一样重要，若想成为优秀的Objective-C开发者，应该掌握C语言的核心概念。</li></ul><h4 id="48-多用块枚举，少用for循环"><a href="#48-多用块枚举，少用for循环" class="headerlink" title="48.多用块枚举，少用for循环"></a>48.多用块枚举，少用for循环</h4><ul><li>for 循环</li><li>使用Objective-C 1.0 的 NSEnumerator来遍历</li><li>快速遍历</li><li>基于块的遍历方式<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block</span><br></pre></td></tr></table></figure></li></ul><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ul><li>遍历collection有四种方式。最基本的办法是for循环，其次是NSEnumerator遍历法及快速遍历法，最新、最先进的方式是“块枚举法”。</li><li>“块枚举法”本身就能通过GCD来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。</li><li>若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。</li></ul><h4 id="49-对自定义其内存管理语义的collection使用无缝桥接"><a href="#49-对自定义其内存管理语义的collection使用无缝桥接" class="headerlink" title="49.对自定义其内存管理语义的collection使用无缝桥接"></a>49.对自定义其内存管理语义的collection使用无缝桥接</h4><p>__bridge</p><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ul><li>通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。</li><li>在CoreFoundation层面创建collection时，可以指定许多回调函数，将其转换成具备特殊内存管理予以的Objective-C collection。</li></ul><h4 id="50-构建缓存时选用NSCache而非NSDictionary"><a href="#50-构建缓存时选用NSCache而非NSDictionary" class="headerlink" title="50.构建缓存时选用NSCache而非NSDictionary"></a>50.构建缓存时选用NSCache而非NSDictionary</h4><p>NSCache是线程安全的。而NSDictionary则绝对不具备此优势，意思就是：在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问NSCache。</p><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ul><li>实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是“线程安全的”，此外，它与字典不同，并不会拷贝键。</li><li>可以给NSCache对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”（hard limit），它们仅对NSCache起指导作用。</li><li>将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。</li><li>如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</li></ul><h4 id="51-精简initialize与load的实现代码"><a href="#51-精简initialize与load的实现代码" class="headerlink" title="51.精简initialize与load的实现代码"></a>51.精简initialize与load的实现代码</h4><h5 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h5><ul><li>在加载阶段，如果累实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。</li><li>首次使用到某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类。</li><li>load与initialize方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入“依赖环”（interdependency cycle）的几率。</li><li>无法在编译期设定的全局变量，可以放在initialize方法里初始化。</li></ul><h4 id="52-别忘了NSTimer会保留其目标对象"><a href="#52-别忘了NSTimer会保留其目标对象" class="headerlink" title="52.别忘了NSTimer会保留其目标对象"></a>52.别忘了NSTimer会保留其目标对象</h4><h5 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h5><ul><li>NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完成任务之后也会失效。</li><li>反复执行任务的计时器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定户籍导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。</li><li>可以扩充NSTimer的功能，用“块”来打破保留环。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第7章-系统框架&quot;&gt;&lt;a href=&quot;#第7章-系统框架&quot; class=&quot;headerlink&quot; title=&quot;第7章 系统框架&quot;&gt;&lt;/a&gt;第7章 系统框架&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="https://objcvip.github.io/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="https://objcvip.github.io/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第6章）</title>
    <link href="https://objcvip.github.io/EffectiveObjectiveCPart6/"/>
    <id>https://objcvip.github.io/EffectiveObjectiveCPart6/</id>
    <published>2018-01-05T16:06:00.000Z</published>
    <updated>2018-12-06T10:03:56.385Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第6章-块与大中枢派发"><a href="#第6章-块与大中枢派发" class="headerlink" title="第6章 块与大中枢派发"></a>第6章 块与大中枢派发</h3><a id="more"></a><h4 id="37-理解“块”这一概念"><a href="#37-理解“块”这一概念" class="headerlink" title="37.理解“块”这一概念"></a>37.理解“块”这一概念</h4><ul><li>块是C、C++、Objective-C 中的词法闭包。</li><li>块可接受参数，也可返回值。</li><li>块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。</li></ul><h4 id="38-为常用的块类型创建-typedef"><a href="#38-为常用的块类型创建-typedef" class="headerlink" title="38.为常用的块类型创建 typedef"></a>38.为常用的块类型创建 typedef</h4><ul><li>以typedef重新定义块类型，可令块变量用起来更加简单。</li><li>定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。</li><li>不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应的 typedef 中的块签名即可，无须改动其他typedef。</li></ul><h4 id="39-用-handler-块降低代码分散程度"><a href="#39-用-handler-块降低代码分散程度" class="headerlink" title="39.用 handler 块降低代码分散程度"></a>39.用 handler 块降低代码分散程度</h4><ul><li>在创建对象时，可以使用内联的 handler 块将相关业务逻辑一并声明。</li><li>在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handler 块来实现，则可直接将块与相关对象放在一起。</li><li>设计 API 时如果用到了 handler 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行。</li></ul><h4 id="40-用块引用其所属对象时不要出现保留环"><a href="#40-用块引用其所属对象时不要出现保留环" class="headerlink" title="40.用块引用其所属对象时不要出现保留环"></a>40.用块引用其所属对象时不要出现保留环</h4><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)p_requestCompleted &#123;</span><br><span class="line">    if (_completionHandler) &#123;</span><br><span class="line">        _completionHandler(_downloadedData);</span><br><span class="line">  &#125;</span><br><span class="line">  self.completionHandler = nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要下载请求执行完毕，保留环就解除了，而获取器对象也将会在必要时为系统所回收。</p><ul><li>如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。</li><li>一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。</li></ul><h4 id="41-多用派发队列，少用同步锁"><a href="#41-多用派发队列，少用同步锁" class="headerlink" title="41.多用派发队列，少用同步锁"></a>41.多用派发队列，少用同步锁</h4><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><ol><li><p>同步块（synchronization block）</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">          //Safe</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>NSLock锁对象  NSRecursiveLock递归锁</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_lock = [[NSLock alloc] init];</span><br><span class="line">- (void)synchronizedMethod &#123;</span><br><span class="line">    [_lock lock];</span><br><span class="line">    //Safe</span><br><span class="line">    [_lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>缺陷：</p><ul><li>在极端情况下，同步块会导致死锁。</li><li>效率不见得很高。</li><li>直接使用锁对象，一旦遇到死锁，就会非常麻烦。</li><li>用atomic来修饰属性，只能提供某种程度的线程安全，无法保证访问该对象时绝对是线程安全的。使用属性时，必然能从中获取到有效值，然而在同一线程上多次调用获取方法（getter），每次获取到的结果未必相同。在两次访问操作之间，其他线程可能会写入新的属性值。</li></ul><ol start="3"><li>GCD<br> 串行同步队列（serial synchronization queue）<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">_syncQueue = dispatch_queue_create(&quot;com.effectiveObjectivec.syncQueue&quot;,NULL);</span><br><span class="line">- (NSString *)someString &#123;</span><br><span class="line">  __block NSString *localSomeString;</span><br><span class="line"> dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">      localSomeString = _someString;</span><br><span class="line">    &#125;);</span><br><span class="line">    return localSomeString;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setSomeString:(NSString *)someString &#123;</span><br><span class="line">    dispatch_sync(_syncQueue, ^&#123;</span><br><span class="line">          _someString = someString;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>思路是：把设置操作与获取操作都安排在序列化的队列里执行，这样的话，所有针对属性的访问操作就都同步了。全部加锁任务都在GCD中处理。<br>并发队列（concurrent queue）<br>栅栏（barrier）<br>在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。并发队列如果发现接下来要处理的块是个栅栏块，那么久一直要等栅栏块执行过后，再按正常方式继续向下处理。</p><h5 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h5><ul><li>派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用@synchronized 块或 NSLock 对象更简单。</li><li>将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。</li><li>使用同步队列及栅栏块，可以令同步行为更加高效。</li></ul><h4 id="42-多用GCD，少用-performSelector-系列方法"><a href="#42-多用GCD，少用-performSelector-系列方法" class="headerlink" title="42.多用GCD，少用 performSelector 系列方法"></a>42.多用GCD，少用 performSelector 系列方法</h4><ol><li>performSelector 可能内存泄漏<br> performSelector 调用了一个方法。编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用ARC的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。</li><li>有局限性。</li></ol><ul><li>返回值只能是void或对象类型。</li><li>参数类型是id，所以只能传入对象。此外，最多只能接受两个参数。</li></ul><p>dispatch_sync<br>dispatch_async<br>dispatch_after</p><h5 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h5><ul><li>performSelector 系列方法在内存管理方面容易有疏忽。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。</li><li>performSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都收到限制。</li><li>如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。</li></ul><h4 id="43-掌握GCD及操作队列的使用时机"><a href="#43-掌握GCD及操作队列的使用时机" class="headerlink" title="43.掌握GCD及操作队列的使用时机"></a>43.掌握GCD及操作队列的使用时机</h4><h5 id="GCD与NSOperationQueue"><a href="#GCD与NSOperationQueue" class="headerlink" title="GCD与NSOperationQueue"></a>GCD与NSOperationQueue</h5><ul><li>操作队列在底层是用GCD来实现的。</li><li>GCD是纯C的API，而操作队列则是Objective-C的对象。</li><li>在GCD中，任务用块来表示，而块是一个轻量级的数据结构。预支相反，“操作”（operation）则是个更为重量级的Objective-C对象。</li></ul><h5 id="使用NSOperation及NSOperationQueue的好处："><a href="#使用NSOperation及NSOperationQueue的好处：" class="headerlink" title="使用NSOperation及NSOperationQueue的好处："></a>使用NSOperation及NSOperationQueue的好处：</h5><ul><li>取消某个操作。运行任务之前，可以在NSOperation对象上调用cancel方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。若是不使用操作队列，而是把块安排在GCD队列，那就无法取消了。开发者可以在应用程序层自己来实现取消功能，不过这样做需要编写很多代码，而那些代码其实已经由操作队列实现好了。</li><li>指定操作间的依赖关系。</li><li>通过键值观察机制监控NSOperation对象的属性。如isCancelled、isFinished。如果想在某个任务变更其状态时得到通知，或是想用比GCD更为精细的方式来控制所要执行的任务，那么键值观察机制会很有用。</li><li>指定操作的优先级。GCD只有队列的优先级，没有任务的优先级。NSOpetation对象也有线程优先级，这决定了运行此操作的线程处在何种优先级上。GCD可以实现此功能，然而操作队列更简单，只需设置一个属性。</li><li>重用NSOperation对象。<br>系统的NSNotificationCenter API选用了操作队列而非派发队列，开发者可通过其中的方法来注册监听器，以便在发生相关事件时得到通知，而这个方法接受的参数是块，不是选择子。</li></ul><h5 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h5><ul><li>在解决多线程与任务管理问题时，派发队列并非唯一方案。</li><li>操作队列提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。</li></ul><h4 id="44-通过-Dispatch-Group-机制，根据系统资源状况来执行任务"><a href="#44-通过-Dispatch-Group-机制，根据系统资源状况来执行任务" class="headerlink" title="44.通过 Dispatch Group 机制，根据系统资源状况来执行任务"></a>44.通过 Dispatch Group 机制，根据系统资源状况来执行任务</h4><h5 id="要点-3"><a href="#要点-3" class="headerlink" title="要点"></a>要点</h5><ul><li>一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。</li><li>通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。</li></ul><h4 id="45-使用dispatch-once来执行只需运行一次的线程安全代码"><a href="#45-使用dispatch-once来执行只需运行一次的线程安全代码" class="headerlink" title="45. 使用dispatch_once来执行只需运行一次的线程安全代码"></a>45. 使用dispatch_once来执行只需运行一次的线程安全代码</h4><h5 id="实现单例"><a href="#实现单例" class="headerlink" title="实现单例"></a>实现单例</h5><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">+ (id)sharedInstance &#123;</span><br><span class="line">    static EOCClass *sharedInstance = nil;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">          sharedInstance = [[self alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return sharedInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="要点-4"><a href="#要点-4" class="headerlink" title="要点"></a>要点</h5><ul><li>经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过GCD所提供的 dispatch_once 函数，很容易就能实现此功能。</li><li>标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的。</li></ul><h4 id="46-不要使用-dispatch-get-current-queue"><a href="#46-不要使用-dispatch-get-current-queue" class="headerlink" title="46.不要使用 dispatch_get_current_queue"></a>46.不要使用 dispatch_get_current_queue</h4><h5 id="要点-5"><a href="#要点-5" class="headerlink" title="要点"></a>要点</h5><ul><li>dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试之用。</li><li>由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。</li><li>dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第6章-块与大中枢派发&quot;&gt;&lt;a href=&quot;#第6章-块与大中枢派发&quot; class=&quot;headerlink&quot; title=&quot;第6章 块与大中枢派发&quot;&gt;&lt;/a&gt;第6章 块与大中枢派发&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="https://objcvip.github.io/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="https://objcvip.github.io/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
  <entry>
    <title>Effective Objective-C 2.0（第5章）</title>
    <link href="https://objcvip.github.io/EffectiveObjectiveCPart5/"/>
    <id>https://objcvip.github.io/EffectiveObjectiveCPart5/</id>
    <published>2018-01-04T16:05:00.000Z</published>
    <updated>2018-12-06T10:03:45.635Z</updated>
    
    <content type="html"><![CDATA[<h2 id="编写高质量iOS与OS-X代码的52个有效方法"><a href="#编写高质量iOS与OS-X代码的52个有效方法" class="headerlink" title="编写高质量iOS与OS X代码的52个有效方法"></a>编写高质量iOS与OS X代码的52个有效方法</h2><h3 id="第5章-内存管理"><a href="#第5章-内存管理" class="headerlink" title="第5章 内存管理"></a>第5章 内存管理</h3><a id="more"></a><h4 id="29-理解引用计数"><a href="#29-理解引用计数" class="headerlink" title="29.理解引用计数"></a>29.理解引用计数</h4><ul><li>引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。</li><li>在对象的生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。</li></ul><h4 id="30-以ARC简化引用计数"><a href="#30-以ARC简化引用计数" class="headerlink" title="30.以ARC简化引用计数"></a>30.以ARC简化引用计数</h4><ul><li>有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可以省去类中许多“样板代码”。</li><li>ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。</li><li>由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则。</li><li>ARC只负责管理Objective-C对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。</li></ul><h4 id="31-在dealloc方法中只释放引用并解除监听"><a href="#31-在dealloc方法中只释放引用并解除监听" class="headerlink" title="31.在dealloc方法中只释放引用并解除监听"></a>31.在dealloc方法中只释放引用并解除监听</h4><ul><li>在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观察”(KVO)或NSNotificationCenter等通知，不要做其他事情。</li><li>如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法。</li><li>执行异步任务的方法不应在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。</li></ul><h4 id="32-编写“异常安全代码”时留意内存管理问题"><a href="#32-编写“异常安全代码”时留意内存管理问题" class="headerlink" title="32.编写“异常安全代码”时留意内存管理问题"></a>32.编写“异常安全代码”时留意内存管理问题</h4><ul><li>捕获异常时，一定要注意将try块内所创立的对象清理干净。</li><li>在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。</li></ul><h4 id="33-以弱引用避免保留环"><a href="#33-以弱引用避免保留环" class="headerlink" title="33.以弱引用避免保留环"></a>33.以弱引用避免保留环</h4><ul><li>将某些引用设为weak，可避免出现“保留环”。</li><li>weak引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着ARC而引人的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。</li></ul><h4 id="34-以“自动释放池块”降低内存峰值"><a href="#34-以“自动释放池块”降低内存峰值" class="headerlink" title="34.以“自动释放池块”降低内存峰值"></a>34.以“自动释放池块”降低内存峰值</h4><ul><li>自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。</li><li>合理运用自动释放池，可降低应用程序的内存峰值。</li><li>@autoreleasepool这种新式写法能创建出更为轻便的自动释放池。</li></ul><h4 id="35-用“僵尸对象”调试内存管理问题"><a href="#35-用“僵尸对象”调试内存管理问题" class="headerlink" title="35.用“僵尸对象”调试内存管理问题"></a>35.用“僵尸对象”调试内存管理问题</h4><ul><li>系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled可开启此功能。</li><li>系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。</li></ul><h4 id="36-不要使用retainCount"><a href="#36-不要使用retainCount" class="headerlink" title="36.不要使用retainCount"></a>36.不要使用retainCount</h4><ul><li>对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”（absolute retain count）都无法反应对象生命周期的全貌。</li><li>引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;编写高质量iOS与OS-X代码的52个有效方法&quot;&gt;&lt;a href=&quot;#编写高质量iOS与OS-X代码的52个有效方法&quot; class=&quot;headerlink&quot; title=&quot;编写高质量iOS与OS X代码的52个有效方法&quot;&gt;&lt;/a&gt;编写高质量iOS与OS X代码的52个有效方法&lt;/h2&gt;&lt;h3 id=&quot;第5章-内存管理&quot;&gt;&lt;a href=&quot;#第5章-内存管理&quot; class=&quot;headerlink&quot; title=&quot;第5章 内存管理&quot;&gt;&lt;/a&gt;第5章 内存管理&lt;/h3&gt;
    
    </summary>
    
      <category term="Effective Objective-C 2.0" scheme="https://objcvip.github.io/categories/Effective-Objective-C-2-0/"/>
    
    
      <category term="Effective Objective-C 2.0" scheme="https://objcvip.github.io/tags/Effective-Objective-C-2-0/"/>
    
  </entry>
  
</feed>
