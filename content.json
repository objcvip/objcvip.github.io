{"pages":[{"title":"Links","text":"Apple Developer苹果开发者https://developer.apple.com 力扣刷题必备https://leetcode-cn.com/ FlutterFlutter官网https://flutter.dev React Native中文网使用JavaScript和React编写原生移动应用https://reactnative.cn 菜鸟教程学的不仅是技术，更是梦想https://www.runoob.com 水寒的博客物联网应用开发、Android应用开发、Web前端开发技术https://dp2px.com EllaElla的技术博客https://www.sunhong.vip","link":"/links/index.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"关于","text":"ObjC.vip - Become a better  developerObjC.vip - Objective-C 私享菜 - 成为更好的苹果开发者 欢迎分享互帮互助：https://objc.vip 初心记录 iOS 面试题。不论角色是候选人还是面试官，都希望能帮助大家更好的面试与被面试。 联系我们有任何意见或建议、投稿请发邮件到：objcvip@163.com","link":"/about/index.html"},{"title":"标签","text":"","link":"/tags/index.html"}],"posts":[{"title":"《大话数据结构》一","text":"第1章 数据结构绪论 数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。 数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。 数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。 数据对象：是性质相同的数据元素的集合，是数据的子集。 数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。 逻辑结构与物理结构1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种： 集合机构 线性结构 树形结构 图形结构 2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。 顺序存储结构：是把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。 链式存储结构：是把数据元素存放在任意的存储单元里，这组单元可以是连续的，也可以是不连续的。 抽象数据类型数据类型：是指一组性质相同的值得集合及定义在此集合上的一些操作的总称。C语言中，按照取值的不同，可以分为两类： 原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。 结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数组组成的。 抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。 第2章 算法算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。 算法的特性 输入输出 有穷性 确定性 可行性 算法设计的要求 正确性 可读性 健壮性 时间效率高和存储量低 算法效率的度量方法 事后统计方法（不科学、不准确） 事前分析估算方法 函数的渐近式增长函数的渐近增长：给定两个函数 f(n) 和 g(n), 如果存在一个整数N，使得对于所有的 n &gt; N, f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。 算法时间复杂度在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。 推导大 O 阶方法 用常数 1 取代运行时间中的所有加法常数。 在修改后的运行次数函数中，只保留最高阶项。 如果最高阶存在且不是 1，则去除与这个项相乘的常数。得到的结果就是大 O 阶。 常见的时间复杂度O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)","link":"/DataStructurePart1/"},{"title":"《大话数据结构》二","text":"第3章 线性表线性表：零个或多个数据元素的有限序列。 线性表的定义 线性表(List):零个或多个数据元素的有限序列。 线性表元素的个数 n (n&gt;=0) 定义为线性表的长度，当 n = 0时，称为空表。 线性表的抽象数据类型ADT 线性表(List)Data​ 线性表的数据对象集合为{a1,a2,……,an},每个元素的类型均为DataType。其中，除第一个元素a1外，每一个元素有且只有一个直接前驱元素，除了最后一个元素an外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。 Operation ​ InitList (*L):初始化操作，建立一个空的线性表L。 ​ ListEmpty(L)：若线性表为空，返回true，否则返回false。 ​ ClearList(*L)：将线性表清空。 ​ GetElem(L,i,*e)：在线性表L中的第i个位置元素值返回给e。 ​ LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败。 ​ ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。 ​ ListDelete(L,i, e)：删除线性表L中的第i个位置元素，并用e返回其值。 ​ ListLength(L)：返回线性表L的元素个数。 endADT 线性表的顺序存储结构顺序存储定义 线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。 顺序存储方式一维数组来实现顺序存储结构。 数组长度与线性表长度区别数组的长度是存放线性表的存储空间的长度。线性表的长度是线性表中数据元素的个数。在任意时刻，线性表的长度应该小于等于数组的长度。 地址计算方法存储器中每个存储单元都有自己的编号，这个编号称为地址。 LOC(ai) = LOC(a1) + (i-1)*c 存取的时间性能为O(1)。 顺序存储结构的插入与删除获得元素操作只要i的数值在数组的下标范围内，就是把数组的第i-1下标的值返回即可。 插入操作插入算法的思路： 如果插入位置不合理，抛出异常； 如果线性表的长度大于等于数组长度，则抛出异常或动态增加容量； 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置； 将要插入元素填入位置i处； 表长加1。 删除操作删除算法的思路： 如果删除位置不合理，抛出异常； 取出删除元素； 从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置； 表长减1。 插入和删除的时间复杂度，最好情况为O(1)，最坏情况为O(n)，平均时间复杂度为O(n)。 线性表顺序存储结构的优缺点优点： 无须为表示表中元素之间的逻辑关系而增加额外的存储空间。 可以快速地存取表中任一位置的元素。 缺点： 插入和删除操作需要移动大量元素。 当线性表长度变化较大时，难以确定存储空间的容量。 造成存储空间的”碎片”。 线性表的链式存储结构线性表链式存储结构定义​ 为了表示每个数据元素ai与其直接后继数据元素ai+1之间的逻辑关系，对数据元素ai来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素ai的存储映像，称为结点(Node)。 ​ n个结点(ai的存储映像)链结成一个链表，即为线性表(a1,a2,…,an)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。 ​ 链表中的第一个结点的存储位置叫做头指针。在单链表的第一个结点前附设一个结点，称为头结点。头结点的指针域存储指向第一个结点的指针。 线性表链式存储结构代码描述单链表中，我们在C语言中可用结构指针来描述。 1234567/*线性表的单链表存储结构*/typedef struct Node{ ElemType data; struct Node *next;} Node;typedef struct Node *LinkList; /*定义LinkList*/ 单链表的读取获取链表第i个数据的算法思路： 声明一个指针p指向链表的第一个结点，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，返回结点p的数据。 单链表的插入与删除单链表的插入单链表第i个数据插入结点的算法思路： 声明一指针p指向链表头结点，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，在系统中生成一个空节点s； 将数据元素e赋值给s-&gt;data; 单链表的插入标准语句s-&gt;next = p-&gt;next; p-&gt;next = s; 返回成功。 单链表的删除单链表第i个数据删除结点的算法思路： 声明一指针p指向链表头指针，初始化j从1开始； 当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1； 若到链表末尾p为空，则说明第i个结点不存在； 否则查找成功，将欲删除的结点p-&gt;next赋值给q； 单链表的删除标准语句p-&gt;next = q-&gt;next; 将q结点中的数据赋值给e，作为返回； 释放q结点。 返回成功。 单链表的整表创建头插法 尾插法 单链表的整表删除单链表整表删除的算法思路如下： 声明一节点p和q； 将第一个结点赋值给p； 循环： 将下一个结点赋值给q； 释放p； 将q赋值给p。 单链表结构与顺序存储结构优缺点存储分配方式 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。 单链表采用链式存储结构，用一组任意的存储单元存放线性表中的元素。 时间性能 查找 顺序存储结构O(1) 单链表O(n) 插入和删除 顺序存储结构需要平均移动表长一半的元素，时间为O(n) 单链表在显出某位置的指针后，插入和删除时间仅为O(1) 空间性能 顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。 单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。 静态链表用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。 静态链表优缺点 优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的插入和删除操作需要移动大量元素的缺点。 缺点： 没有解决连续存储分配带来的表长难以确定的问题。 失去了顺序存储结构随机性存取的特性。 循环链表将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)。 双向链表双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。","link":"/DataStructurePart2/"},{"title":"《大话数据结构》三","text":"第4章 栈与队列栈是限定仅在表尾进行插入和删除操作的线性表。队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表。 栈的定义 栈（stack）是限定仅在表尾进行插入和删除操作的线性表。 我们把允许插入和删除的一端称为栈顶（top），另一端称为栈底（bottom），不含任何数据元素的栈称为空栈。栈又称为后进先出（Last In First Out）的线性表，简称 LIFO 结构。 栈的插入操作，叫做进栈，也称压栈、入栈。栈的删除操作，叫做出栈，也有的叫弹栈。 进栈出栈的变化形式元素数量多个，出栈次序会有很多种可能。 栈的抽象数据类型12345678910111213ADT 栈Data 同线性表。元素具有相同的类型，相邻元素具有前驱和后继关系。Operation InitStack(*S):初始化操作，建立一个空栈S。 DestroyStack(*S):若栈存在，则销毁它。ClearStack(*S):将栈清空。 StackEmpty(S):若栈为空，返回 true ，否则返回 false。 GetTop(S,*e):若栈存在且非空，用e返回S的栈顶元素。 Push(*S,e):若栈S存在，插入新元素e到栈S中并成为栈顶元素。 Pop(*S,e):删除栈S中的栈顶元素，并用e返回其值。 StackLength(S):返回栈S的元素个数。endADT 栈的顺序存储结构及实现栈的顺序存储结构栈的结构定义123456typedef init SElemType;typedef struct{ SElemType data[MAXSIZE] int top; /* 用于栈顶指针 */}SqStack; 栈的顺序存储结构——进栈操作进栈操作 push，其代码如下：12345678910Status Push (SqStack *S, SElemType e){ if (S-&gt;top == MAXSIZE - 1) /* 栈满 */ { return ERROR; } S-&gt;top++; /* 栈顶指针增加一 */ S-&gt;data[S-&gt;top]=e; /* 将新插入元素赋值给栈顶空间 */ return OK;} 栈的顺序存储结构——出栈操作出栈操作 pop，其代码如下：12345678Status Pop (SqStack *S, SElemType *e){ if(S-&gt;top==-1) return ERROR; *e=S-&gt;data[S-&gt;top]; /* 将要删除的栈顶元素赋值给e */ S-&gt;top--; /* 栈顶指针减一 */ return OK;} 进栈和出栈没有涉及到任何循环语句，因此时间复杂度均是 O(1)。 两栈共享空间使用这样的数据结构，通常都是当两个栈的空间需求有相反关系时，也就是一个栈增长时另一个栈在缩短的情况。 栈的链式存储结构及实现栈的链式存储结构栈的链式存储结构，简称为链栈。链栈的结构代码如下：1234567891011typedef struct StackNode{ SElemType data; struct StackNode *next;}StackNode, *LinkStackPtr;typedef struct LinkStack{ LinkStackPtr top; int count;} 栈的链式存储结构——进栈操作12345678910/* 插入元素 e 为新的栈顶元素 */Status Push (LinkStack *S, SElemType e){ LinkStackPtr s = (LinkStackPtr)malloc(sizeof(StackNode)); s-&gt;data = e; s-&gt;next = s-&gt;top; /* 把当前的栈顶元素赋值给新结点的直接后继 */ S-&gt;top = s; /* 将新的结点s赋值给栈顶指针 */ S-&gt;count++; return OK;} 栈的链式存储结构——出栈操作假设变量 p 用来存储要删除的栈顶结点，将栈顶指针下移一位，最后释放 p 即可。123456789101112Status Pop (LinkStack *S, SElemType *e){ LinkStackPtr p; if (StackEmpty(*S)) return ERROR; *e = S-&gt;top-&gt;data; p=S-&gt;top; /* 将栈顶结点赋值给p */ S-&gt;top=S-&gt;top-&gt;next; /* 使得栈顶指针下移一位，指向后一结点 */ free(p); /* 释放结点 p */ S-&gt;count--; return OK;} 链栈的进栈 push 和出栈 pop 操作没有任何循环操作，时间复杂度均为O(1)。如果栈的使用过程中元素变化不可预料，有时很小，有时非常大，那么最好是用链栈，反之，如果它的变化在可控范围内，建议使用顺序栈会更好一些。 栈的作用栈的引入简化了程序设计的问题，划分了不同关注层次，使得思考范围缩小，更加聚焦于我们要解决的问题核心。 栈的应用——递归斐波那切数列实现12345678910111213int Fbi (int i){ if (i &lt; 2) return i == 0 ? 0 : 1; return Fbi(i-1) + Fbi(i-2);}int main(){ int i; for (int i = 0;i &lt; 40; i++) printf(\"%d \", Fbi(i)); return 0;} 递归定义在高级语言中，调用自己和其他函数并没有本质的不同。我们把一个直接调用自己或通过一系列的调用语句间接地调用自己的函数，称做递归函数。每个递归定义必须至少有一个条件，满足递归不再进行，即不再引用自身而是返回值退出。 栈的应用——四则运算表达式求值 将中缀表达式转化为后缀表达式（栈用来进出运算的符号）。 将后缀表达式进行运算得出结果（栈用来进出运算的数字）。 队列的定义 队列（queue）是只允许在一端进行插入操作，而在另一端进行删除操作的线性表。 队列是一种先进先出（First In First Out）的线性表，简称FIFO。允许插入的一端称为队尾，允许删除的一端称为队头。 队列的抽象数据类型1234567891011121314ADT 队列（Queue）Data 同线性表。元素具有相同的类型，相邻元素具有前缀和后继关系。Operation InitQueue(*Q):初始化操作，建立一个空队列Q。 DestroyQueue(*Q):若队列Q存在，则销毁它。 ClearQueue(*Q):将队列Q清空。 QueueEmpty(*Q):若队列Q为空，返回 true，否则返回 false。 GetHead(Q,*e):若队列Q存在且非空，用e返回队列Q的队头元素。 EnQueue(*Q,e):若队列Q存在，插入新元素e到队列Q中并成为队尾元素。 DeQueue(*Q,*e):删除队列Q中队头元素，并用e返回其值。 QueueLength(Q):返回队列Q的元素个数。endADT 循环队列循环队列定义我们把队列的这种头尾相接的顺序存储结构称为循环队列。 队列的链式存储结构及实现队列的链式存储结构，其实就是线性表的单链表，只不过它只能尾进头出而已，我们把它简称为链队列。链队列的结构为：123456789101112typedef int QElemType;typedef struct QNode /* 节点结构 */{ QElemType data; struct QNode *next;}QNode,*QueuePtr;typedef struct /* 队列的链表结构 */{ QueuePtr front,rear; /* 队头、队尾指针 */}LinkQueue; 队列的链式存储结构——入队操作1234567891011Status EnQueue(LinkQueue *Q, QElemType e){ QueuePtr s = (QueuePtr)malloc(sizeof(QNode)); if(!s) /* 存储分配失败 */ exit(OVERFLOW); s-&gt;data = e; s-&gt;next = NULL; Q-&gt;rear-&gt;next = s; /* 把拥有元素e新结点s赋值给原队尾节点的后继 */ Q-&gt;rear = s; /* 把当前的s设置为队尾结点，rear指向s */ return OK;} 队列的链式存储结构——出队操作12345678910111213Status DeQueue(LinkQueue *Q, QElemType *e){ QueuePtr p; if(Q-&gt;front==Q-&gt;rear) return ERROR; p=Q-&gt;front-&gt;next; /* 将欲删除的队头结点暂存给p */ *e=p-&gt;data; /* 将欲删除的队头结点的值赋值给e */ Q-&gt;front-&gt;next=p-&gt;next; /* 将原队头结点后继p-&gt;next赋值给头结点后缀 */ if(Q-&gt;rear==p) /* 若队头是队尾，则删除后将rear指向头结点 */ Q-&gt;rear=Q-&gt;front; free(p); return OK;} 在可以确定队列长度最大值的情况下，建议用循环队列，如果你无法预估队列的长度时，则用链队列。","link":"/DataStructurePart3/"},{"title":"Effective Objective-C 2.0（第3章）","text":"编写高质量iOS与OS X代码的52个有效方法第3章 接口与API设计 15.用前缀避免命名空间冲突 选择与你的公司、应用程序或者二者皆有关联之名作为类名的前缀，并在所有代码中均使用这一前缀。 若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。 16.提供“全能初始化方法” 在类中提供一个全能初始化方法，并于文档里指明。其他初始化方法均应调用此方法。 若全能初始化方法与超类不同，则需覆写超类中的对应方法。 如果超类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。 17.实现description方法 实现description方法返回一个有意义的字符串，用以描述该实例。 若想在调试时打印出更详尽的对象描述信息，则应实现debugDescription方法。 18.尽量使用不可变对象 尽量创建不可变的对象。 若某属性仅可用于对象内部修改，则在“class-continuation分类”中将其由readonly属性扩展为readwrite属性。 不要把可变的collection作为属性公开，而应提供相关方法，以此修改对象中的可变collection。 19.使用清晰而协调的命名方式 起名时应遵从标准的Objective-C命名规范，这样创建出来的接口更容易为开发者所理解。 方法名要言简意赅，从左至右读起来要像个日常用语中的句子才好。 方法名里不要使用缩略后的类型名称。 给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。 20.为私有方法名加前缀 给私有方法的名称加上前缀，这样可以很容易的将其同公共方法区分开。 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。 21.理解 Objective-C错误模型 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。 在错误不那么严重的情况下，可以指派委托方法（delegate method）来处理错误，也可以把错误信息放在NSError对象里，经由“输出参数”返回给调用者。 22.理解 NSCopying协议 若想令自己所写的对象具有拷贝功能，则需实现NSCopying协议。 如果自定义的对象分为可变版本和不可变版本，那么就要同时实现NSCopying与NSMutableCopying协议。 复制对象时需决定采用浅拷贝还是深拷贝，一般情况下应尽量执行浅拷贝。 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。","link":"/EffectiveObjectiveCPart3/"},{"title":"《大话数据结构》四","text":"第5章 串串（string）是由零个或多个字符组成的有限序列，又名叫字符串。 串的定义 串（string）是由零个或多个字符组成的有限序列，又名叫字符串。 串的比较给定两个串：s= “a1a2……an“, t= “b1b2……bm“, 当满足以下条件之一时，s&lt;t。 n&lt;m，且ai=bi（i=1, 2, ……, n）。 存在某个k&lt;min(m, n), 使得ai=bi（i=1，2，……，k-1）ak&lt;bk 串的抽象数据类型1234567891011121314151617ADT 串（string）Data 串中元素仅由一个字符组成，相邻元素具有前驱和后继关系。Operation StrAssign(T,*chars):生成一个其值等于字符串常量chars的串T。 StrCopy(T,S):串S存在，由串复制得串T。 ClearString(S):串S存在，将串清空。 StringEmpty(S):若串为空，返回true，否则返回false。 StrLength(S):返回串S的元素个数，即串的长度。 StrCompare(S,T):若S&gt;T，返回值&gt;0,若S=T，返回0，若S&lt;T，返回值&lt;0. Concat(T,S1,S2):用T返回由S1和S2联接而成的新串。 SubString(Sub,S,pos,len):串S存在，1&lt;=pos&lt;=StrLength(S)，且0&lt;=len&lt;=StrLength(S)-pos+1,用Sub返回串S的第pos个字符长度为len的子串。 Index(S,T,pos):串S和T存在，T是非空串，1&lt;=pos&lt;=StrLength(S)。若主串S中存在和串T值相同的子串，则返回它在主串S中第pos个字符之后第一次出现的位置，否则返回0。 Replace(S,T,V):串S、T和V存在，T是非空串。用V替换主串S中出现的所有与T相等的不重叠的子串。 StrInsert(S,pos,T):串S和T存在，1&lt;=pos&lt;=StrLength(S)+1。在串S的第pos个字符之前插入串T。 StrDelete(S,pos,len):串S存在，1&lt;=pos&lt;=StrLength(S)-len+1。从串S中删除第pos个字符起长度为len的子串。endADT Index 的实现算法123456789101112131415161718192021/* T为非空串。若主串S中第pos个字符之后存在与T相等的子串，则返回第一个这样的子串在S中的位置，否则返回0 */int Index(String S, String T, int pos){ int n,m,i; String sub; if (pos &gt; 0) { n = StrLength(S); m = StrLength(T); i = pos; while ( i &lt;= n-m+1) { SubString(sub,S,i,m); /* 取主串第i个位置 长度与T相等子串给sub */ if (StrCompare(sub,T) != 0) /* 如果两串不相等 */ ++i; else /* 如果两串相等 */ return i; } } return 0; /* 若无子串与T相等，返回0 */} 当中用到了 StrLength、SubString、StrCompare 等基本操作来实现。 串的存储结构串的顺序存储结构串的顺序存储结构是用一组地址连续的存储单元来存储串中的字符序列的。按照预定义的大小，为每个定义的串变量分配一个固定长度的存储区。一般使用定长数组来定义。 串的链式存储结构对于串的链式存储结构，与线性表是相似的，但由于串结构的特殊性，结构中的每个元素数据是一个字符，如果也简单的应用链表存储串值，一个结点对应一个字符，就会存在很大的空间浪费。因此，一个结点可以存放一个字符，也可以考虑存放多个字符，最后一个结点若是未被占满时，可以用“#”或其他非串值字符补全。 串的链式存储结构除了在链接串与串操作时有一定方便外，总的来说不如顺序存储灵活，性能也不如顺序存储结构好。 朴素的模式匹配算法子串的定位操作通常称做串的模式匹配。假设我们要从下面的主串S=“goodgoogle”中，找到T=“google这个子串的位置”。简单的来说，就是对主串的每一个字符作为子串开头，与要匹配的字符串进行匹配。对主串做大循环，每个字符开头做T的长度的小循环，直到匹配成功或全部遍历完成为止。最好的情况，时间复杂度为O(1)。稍差一些的情况，时间复杂度为O(n+m)，其中n为主串长度，m为要匹配的子串长度。根据等概率原则，平均是(n+m)/2次查找，时间复杂度为O(n+m)。 KMP模式匹配算法D.E.Knuth、J.H.Morris 和 V.R.Pratt 发表一个模式匹配算法，可以大大避免重复遍历的情况，我们把它称之为克努特-莫里斯-普拉特算法，简称 KMP 算法。","link":"/DataStructurePart4/"},{"title":"Effective Objective-C 2.0（第1章）","text":"编写高质量iOS与OS X代码的52个有效方法第1章 熟悉Objective-C 1.了解Objective-C 语言的起源Objective-C使用消息结构messaging structure，而非函数调用function calling。消息结构：运行时所运行的代码是由运行环境决定的。运行时才会去查找所要执行的方法。函数调用：编译器决定。Objective-C是C语言的超集，使用动态绑定的消息结构，在运行时才会检查对象类型。接收到一条消息后，究竟该执行何种代码，由运行时环境而非编译器决定。对象所占内存总是分配在堆上。 要点 Objective-C 为C语言添加了面向对象特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会检查对象类型。接受一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。 理解C语言的核心概念有助于写好Objective-C程序。尤其要掌握内存模型与指针。 2.在类的头文件中尽量少引入其他头文件@class的作用：（1）可以将引入头文件的时机延后，只在确实有需要的时候才引入，可以减少类的使用者所需引入的头文件数量，减少编译时间。（2）解决两个类相互引用的问题。相互引用会导致循环引用，两个类里有一个无法被正确编译。 要点 除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合(coupling)。 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。 3.多用字面量语法，少用与之等价的方法字面量语法简明扼要。创建数组或字典时使用字面量语法能够尽早发现插入nil的问题。 使用字面量语法创建出来的字符串、数组、字典对象都是不可变的（immutable）​。若想要可变版本的对象，则需复制一份：1NSMutableArray *mutable = [@[@1,@2,@3,@4,@5]mutableCopy]; 要点 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。 应该通过取下标操作来访问数组下标或字典中的键所对应的元素。 用字面量语法创建数组或字典时，若值中有nil，则会抛出异常。因此，务必确保值里不含nil。 4.多用类型常量，少用#define预处理命令 不要使用预处理指令定义常量。（1）这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。（2）如果被其他人重新定义了常量值，编译器不会报警告，这将导致常量值不一致。 在实现文件里使用static const来定义此类中使用的常量。由于此类常量不在全局符号表中，所以无须为其名称加前缀。 在头文件中使用extern来声明全局变量，并在实现文件中定义其值。这种常量会出现在全局符号表中，所以名称最好加上与之相关的类名做前缀。 5.用枚举表示状态、选项、状态码要点 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将个选项值定义为2的幂，以便通过按位或操作将其组合起来。 用NS_ENUM与NS_OPTIONS宏来定义枚举类型，并指明其底层数据结构。这样做可以确保枚举类型是用开发者所选的底层数据结构实现出来的，而不会采用编译器所选的类型。 在处理枚举类型的switch语句中不要实现default分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch语句并未处理所有枚举。","link":"/EffectiveObjectiveCPart1/"},{"title":"Effective Objective-C 2.0（第4章）","text":"编写高质量iOS与OS X代码的52个有效方法第4章 协议与分类 23.通过委托与数据源协议进行对象间通信 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。这种情境下，该模式亦称“数据源协议”（data source protocal）。 若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。 24.将类的实现代码分散到便于管理的数个分类之中 使用分类机制把类的实现代码划分成易于管理的小块。 将应该视为“私有”的方法归入名叫Private的分类中，以隐藏实现细节。 25.总是为第三方类的分类名称加前缀 向第三方类中添加分类时，总应给其名称加上你专用的前缀。 向第三方类中添加分类时，总应给其中的方法名加上你专用的前缀。 26.勿在分类中声明属性 把封装数据所用的全部属性都定义在主接口里。 在“class-continuation分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性。 27.使用“class-continuation分类”隐藏实现细节 通过“class-continuation分类”向类中新增实例变量。 如果某属性在主接口中声明为“只读”，而类的内部又要用设置方法修改此属性，那么就在“class-continuation分类”中将其扩展为“可读写”。 把私有方法的原型声明在“class-continuation分类”里面。 若想使类所遵循的协议不为人所知，则可于“class-continuation分类”中声明。 28.通过协议提供匿名对象 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的id类型，协议里规定了对象所应实现的方法。 使用匿名对象来隐藏类型名称（或类名）。 如果具体类型不重要，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示。","link":"/EffectiveObjectiveCPart4/"},{"title":"Effective Objective-C 2.0（第5章）","text":"编写高质量iOS与OS X代码的52个有效方法第5章 内存管理 29.理解引用计数 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留计数至少为1。若保留计数为正，则对象继续存活。当保留计数降为0时，对象就被销毁了。 在对象的生命周期中，其余对象通过引用来保留或释放此对象。保留与释放操作分别会递增及递减保留计数。 30.以ARC简化引用计数 有ARC之后，程序员就无须担心内存管理问题了。使用ARC来编程，可以省去类中许多“样板代码”。 ARC管理对象生命期的办法基本上就是：在合适的地方插入“保留”及“释放”操作。在ARC环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及“释放”操作。 由方法所返回的对象，其内存管理语义总是通过方法名来体现。ARC将此确定为开发者必须遵守的规则。 ARC只负责管理Objective-C对象的内存。尤其要注意：CoreFoundation对象不归ARC管理，开发者必须适时调用CFRetain/CFRelease。 31.在dealloc方法中只释放引用并解除监听 在dealloc方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的“键值观察”(KVO)或NSNotificationCenter等通知，不要做其他事情。 如果对象持有文件描述符等系统资源，那么应该专门编写一个方法来释放此种资源。这样的类要和其使用者约定：用完资源后必须调用close方法。 执行异步任务的方法不应在dealloc里调用；只能在正常状态下执行的那些方法也不应在dealloc里调用，因为此时对象已处于正在回收的状态了。 32.编写“异常安全代码”时留意内存管理问题 捕获异常时，一定要注意将try块内所创立的对象清理干净。 在默认情况下，ARC不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。 33.以弱引用避免保留环 将某些引用设为weak，可避免出现“保留环”。 weak引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着ARC而引人的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。 34.以“自动释放池块”降低内存峰值 自动释放池排布在栈中，对象收到autorelease消息后，系统将其放入最顶端的池里。 合理运用自动释放池，可降低应用程序的内存峰值。 @autoreleasepool这种新式写法能创建出更为轻便的自动释放池。 35.用“僵尸对象”调试内存管理问题 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量NSZombieEnabled可开启此功能。 系统会修改对象的isa指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接收者的消息，然后终止应用程序。 36.不要使用retainCount 对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”（absolute retain count）都无法反应对象生命周期的全貌。 引入ARC之后，retainCount方法就正式废止了，在ARC下调用该方法会导致编译器报错。","link":"/EffectiveObjectiveCPart5/"},{"title":"Effective Objective-C 2.0（第7章）","text":"编写高质量iOS与OS X代码的52个有效方法第7章 系统框架 47.熟悉系统框架将一系列代码封装为动态库（dynamic library），并在其中放入描述其接口的头文件，这样做出来的东西就叫框架。有时为iOS平台构建的第三方框架所使用的是静态库（static library），这是因为iOS应用程序不允许在其中包含动态库。这些东西严格来讲并不是真正的框架，然而也经常视为框架。不过，所有iOS平台的系统框架仍然使用动态库。 要点 许多系统框架都可以直接使用。其中最重要的是Foundation与CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。 很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。 请记住：用纯C写成的框架与用Objective-C写成的一样重要，若想成为优秀的Objective-C开发者，应该掌握C语言的核心概念。 48.多用块枚举，少用for循环 for 循环 使用Objective-C 1.0 的 NSEnumerator来遍历 快速遍历 基于块的遍历方式1- (void)enumerateObjectsUsingBlock:(void(^)(id object, NSUInteger idx, BOOL *stop))block 要点 遍历collection有四种方式。最基本的办法是for循环，其次是NSEnumerator遍历法及快速遍历法，最新、最先进的方式是“块枚举法”。 “块枚举法”本身就能通过GCD来并发执行遍历操作，无须另行编写代码。而采用其他遍历方式则无法轻易实现这一点。 若提前知道待遍历的collection含有何种对象，则应修改块签名，指出对象的具体类型。 49.对自定义其内存管理语义的collection使用无缝桥接__bridge 要点 通过无缝桥接技术，可以在Foundation框架中的Objective-C对象与CoreFoundation框架中的C语言数据结构之间来回转换。 在CoreFoundation层面创建collection时，可以指定许多回调函数，将其转换成具备特殊内存管理予以的Objective-C collection。 50.构建缓存时选用NSCache而非NSDictionaryNSCache是线程安全的。而NSDictionary则绝对不具备此优势，意思就是：在开发者自己不编写加锁代码的前提下，多个线程便可以同时访问NSCache。 要点 实现缓存时应选用NSCache而非NSDictionary对象。因为NSCache可以提供优雅的自动删减功能，而且是“线程安全的”，此外，它与字典不同，并不会拷贝键。 可以给NSCache对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”（hard limit），它们仅对NSCache起指导作用。 将NSPurgeableData与NSCache搭配使用，可实现自动清除数据的功能，也就是说，当NSPurgeableData对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。 如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。 51.精简initialize与load的实现代码要点 在加载阶段，如果累实现了load方法，那么系统就会调用它。分类里也可以定义此方法，类的load方法要比分类中的先调用。与其他方法不同，load方法不参与覆写机制。 首次使用到某个类之前，系统会向其发送initialize消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的是哪个类。 load与initialize方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入“依赖环”（interdependency cycle）的几率。 无法在编译期设定的全局变量，可以放在initialize方法里初始化。 52.别忘了NSTimer会保留其目标对象要点 NSTimer对象会保留其目标，直到计时器本身失效为止，调用invalidate方法可令计时器失效，另外，一次性的计时器在触发完成任务之后也会失效。 反复执行任务的计时器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定户籍导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。 可以扩充NSTimer的功能，用“块”来打破保留环。不过，除非NSTimer将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。","link":"/EffectiveObjectiveCPart7/"},{"title":"Markdown常用语法","text":"Markdown常用语法 1. 标题123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 预览一级标题二级标题三级标题四级标题五级标题六级标题2. 列表2.1 无序列表123- 文本1- 文本2- 文本3 预览 文本1 文本2 文本3 2.2 有序列表1231. 文本12. 文本23. 文本3 预览 文本1 文本2 文本3 3. 引用在引用的文字前面加上&gt;就可以了 1&gt; 引用的文本 预览 引用的文本 4. 粗体和斜体、删除文本4.1 粗体用两个*包含一段文本即是粗体 4.2 斜体用一个*包含一段文本即是斜体 4.3 删除文本用~~包含一段文本即是删除文本123**粗体文本***斜体文本*~~删除文本~~ 预览粗体文本斜体文本删除文本 5. 代码引用5.1 单行代码引用代码时，如果引用的语句只有一行，可以用·(英文输入状态下左上角~下边的点)将语句包起来1`Markdown` 预览Markdown 5.2 多行代码引用多行代码时，使用···（英文输入状态下左上角~下边的点）置于这段代码的首行和末行12345···func printHello() { print(&quot;hello&quot;)}··· 预览123func printHello() { print(&quot;hello&quot;)} 6. 图片和链接6.1 图片使用![图片名字](图片链接地址) 6.2 链接使用[链接名字](链接地址) 示例12![LOGO](https://objc.vip/images/og_image.png)[百度](https://www.baidu.com) 预览百度 7. 分割线***或--- 示例1--- 预览 8. 表格---上面表示表头，下面表示表身，:在左边表示居左，在两边表示居中，在右边表示居右，不写:的话表头默认居中，表身默认居左。 示例12345| 居左表头1 | 居中表头2 | 居右表头3 || :---------- |:---------: | -----: || 第1行文本 | 第1行文本 | 第1行文本 || 第2行文本 | 第2行文本 | 第2行文本 || 第3行文本 | 第3行文本 | 第3行文本 | 预览 居左表头1 居中表头2 居右表头3 第1行文本 第1行文本 第1行文本 第2行文本 第2行文本 第2行文本 第3行文本 第3行文本 第3行文本","link":"/MarkdownUsage/"},{"title":"【iOS 开发】RunLoop 总结","text":"Runloops是线程相关底层基础的一部分。它的本质和字面意思一样运行着的循环（事件处理的循环）。作用：接受循环事件和安排线程的工作。目的：让线程在有任务的时候忙于工作，而没有任务的时候处于休眠状态。 RunLoop概念Runloop运行循环iOS中通常所说的Runloop指的是NSRunloop（Foundation框架）或者CFRunloopRef（CoreFoundation框架），CFRunloopRef是纯C的函数，而NSRunloop仅仅是CFRunloopRef的一层OC封装。 RunLoop作用 保持程序的持续运行。 处理App中的各种事件。（如：touches触摸事件、NSTimer定时器事件、Selector事件） 节省CPU资源，提高程序性能（有事情就做事情，没事情就休息，资源释放） 负责渲染屏幕上的所有UI。 RunLoop开启&amp;退出在UIApplicationMain函数内部开启了一个和主线程相关的RunLoop (保证主线程不会被销毁)，导致 UIApplicationMain 不会返回，一直在运行中，也就保证了程序的持续运行。Runloop 的退出条件：App退出；线程关闭；设置最大时间到期。 RunLoop和线程关系 每条线程都有唯一的一个与之对应的Runloop对象。 主线程的RunLoop已经自动创建，子线程的RunLoop需要主动创建。 RunLoop在第一次获取时创建，在线程结束时销毁。 Runloop对象是利用字典来进行存储，Key：线程 Value：线程对应的Runloop。 创建子线程对应的RunLoopcurrentRunLoop RunLoop相关类 CFRunLoopRef: RunLoop本身 CFRunLoopModeRef: 运行模式 CFRunLoopSourceRef: 事件源 CFRunLoopTimerRef: Timer事件 CFRunLoopObserverRef: 观察者（监听者） 一条线程 对应一个 Runloop，Runloop 总是运行在某种特定的CFRunLoopModeRef（运行模式）下。 每个 Runloop 都可以包含若干个 Mode ，每个 Mode 又包含Source源 / Timer事件 / Observer观察者。 在 Runloop 中有多个运行模式，每次调用 RunLoop 的主函数__CFRunloopRun()时，只能指定其中一个 Mode（称 CurrentMode）运行， 如果需要切换 Mode，只能是退出 CurrentMode 切换到指定的 Mode 进入，目的以保证不同 Mode 下的 Source / Timer / Observer 互不影响。 Runloop 有效，mode 里面 至少 要有一个timer(定时器事件) 或者是source(源)。 Mode kCFRunLoopDefaultMode App的默认Mode，通常主线程是在这个Mode下运行。 UITrackingRunLoopMode 界面跟踪 Mode，用于 ScrollView 追踪触摸滑动 UIInitializationRunLoopMode 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用。 GSEventReceiveRunLoopMode 接受系统事件的内部 Mode，通常用不到。 kCFRunLoopCommonModes 一种模式组合 Source Source0:非基于端口Port的事件（用于用户主动触发的事件，如：点击按钮或点击屏幕）。 Source：基于端口Port的事件（通过内核和其他线程互相发送消息） TimerNSTimer受RunLoop的Mode影响。GCD定时器不受RunLoop影响。 Observer消息循环中的监听器 RunLoop休眠RunLoop 最核心的事情就是保证线程在没有消息时休眠以避免占用系统资源，有消息时能够及时唤醒。 RunLoop 的这个机制完全依靠系统内核来完成，具体来说是苹果操作系统核心组件 Darwin 中的 Mach 来完成的。","link":"/RunloopSummary/"},{"title":"【iOS 开发】Runtime 总结","text":"一、Runtime是什么？ Runtime 运行时，就是系统在运行的时候的一些机制，其中最主要的是消息机制。Runtime 基本是用C和汇编编写的。 OC与C语言在函数调用上的区别：C语言： 函数的调用在编译的时候就决定调用哪个函数，编译完成之后直接顺序执行，无任何二义性。 C语言在编译阶段调用未实现的函数就会报错。 OC： 函数的调用称为消息发送。属于动态调用过程。 在编译的时候并不能决定真正调用哪个函数。在编译阶段，可以调用任何函数，只要函数声明过。 二、与Runtime系统交互：1. 通过OC源代码编译器会自动将OC代码转换成运行时代码，在运行时确定数据结构和函数。 2. NSObject类定义的方法-class-isKindOfClass -isMemberOfClass-respondsToSelector-confirmsToProtocol-methodForSelector 返回指定方法实现的地址 3. 直接调用 Runtime 库函数(Runtime 常用接口方法)object_getClass@selector()class_getClassMethodclass_getInstanceMethodclass_addMethod()class_replaceMethodmethod_exchangeImplementationsclass_copyPropertyListclass_copyMethodListclass_copyProtocolList 三、Runtime相关术语SELidClassMethodIvar 成员变量IMP 是一个函数指针，指向了方法的实现。Cache 四、消息发送和消息转发消息发送 objc_msgSend 通过isa指针找到所属类。 查找类的cache列表, 如果没有则下一步。 查找类的”方法列表”。 如果能找到与选择子名称相符的方法, 就跳至其实现代码。 找不到, 就沿着继承体系继续向上查找。 如果能找到与选择子名称相符的方法, 就跳至其实现代码。 找不到, 执行”消息转发”。 消息转发 动态方法解析 1+ (BOOL)resolveInstanceMethod:(SEL)selector 其他接收者 1- (id)forwardingTargetForSelector:(SEL)selector 消息签名 1- (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector 完整的消息转发 12- (void)forwardInvocation:(NSInvocation *)invocation// invocation : 封装了与那条尚未处理的消息相关的所有细节的对象 五、Runtime应用 动态添加一个类（KVO的实现原理） 获取一个类的所有属性（1）打印一个类的成员变量列表，属性列表，方法列表（2）动态改变变量的值。（3）在 NSObject 的分类中增加方法，判断是否有该属性，用于避免使用KVC赋值时崩溃。（4）自动归档和解档（5）字典转模型 动态交换方法（1）交换方法（2）替换系统方法（3）实现多继承的效果 动态添加方法 performSelector12resolveInstanceMethodclass_addMethod(self, @selector(eat), eat, \"v@:\");","link":"/RuntimeSummary/"},{"title":"Hello World.","text":"Hello World.你好，世界。","link":"/helloworld/"},{"title":"【算法】Swift 用数组实现栈","text":"用数组实现栈。123456789101112131415161718192021class Stack { var stack: [AnyObject] var isEmpty: Bool { return stack.isEmpty } var peek: AnyObject? { return stack.last } int() { stack = [AnyObject]() } func push(object: AnyObject) { stack.append(object) } func pop() -&gt; AnyObject? { if (!isEmpty) { return stack.removeLast() }else { return nil } }}","link":"/Swift用数组实现栈/"},{"title":"ofo面试题","text":"ofo面试题 1、block 的底层实现? 2、block 的类型有哪几种? 3、你碰到的 block 的循环引用? 4、为什么你在用 Masonry , AFNetworking 的 block 回调不需要对 self 进行 __weak? 5、出现野指针的情况大概有哪些？ 6、Swift 里的闭包和 OC 的 block 的区别。 7、Sqlite 使用的时候需要注意什么。","link":"/ofo面试题/"},{"title":"《三年高考五年模拟》系列之好未来篇","text":"当我们在问面试题时，我们究竟在问什么？OBJC.VIP 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到objcvip@163.com斧正。本期带来《三年高考五年模拟》系列之好未来篇。 题目链接：好未来面试题 1. 一面1、说一下optional。（？ ！ ？？ 几种解包方式 if let、guard、？？等） 2、说一下闭包。 3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？( KVO 效率最低，因为 Runtime ） 4、NSString 和 String 的区别？（ String 是值类型，NSString 是引用类型） 5、Swift 跟 OC 的区别？（ OC 是动态的语言，Swift 是静态的语言）OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？ 6、说一下 MRC ？自动释放池？自动释放池什么时候释放？（我说 drain ） 7、说一下多线程？（我提到了 dispatch_once 单例） 8、分别用 OC 和 Swift 手写一下单例。（ Swift 的单例我忘记写 static 了，但是经提醒立马说出来了） 9、SnaptKit 内部看过吗？ 10、链式语法的实现。 UIView.top.equalTo().offSet(10) UIView.left.equalTo().offSet(10) 为什么能写成UIView.top.left.offSet(10) 2. 二面主要是手写算法题： 1、用两个栈实现队列。 2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。 3. 三面项目经理聊项目 4. 四面HR问了很多问题，包括个人优缺点，在前公司3年的成长等等。","link":"/《三年高考五年模拟》系列之好未来篇/"},{"title":"【iOS 开发】使用环信实现聊天遇到的一些坑","text":"使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。 问题1 聊天页面环信工具栏向上偏移问题描述：在聊天页面，点击输入框弹起键盘，点击IQKeyboardManager带的完成按钮或者点击空白页面收起键盘，反复操作多次后，会出现页面向上偏移，环信UI的工具栏移动到了页面最上边。 解决方案：在聊天页面禁用IQKeyboardManager。123456789101112131415- (void)viewDidAppear:(BOOL)animated{ [super viewDidAppear:animated]; IQKeyboardManager *keyboardManager = [IQKeyboardManager sharedManager]; keyboardManager.enable = NO; keyboardManager.enableAutoToolbar = NO;}- (void)viewWillDisappear:(BOOL)animated{ [super viewWillDisappear:animated]; IQKeyboardManager *keyboardManager = [IQKeyboardManager sharedManager]; keyboardManager.enable = YES; keyboardManager.enableAutoToolbar = YES;} 问题2 保存环信昵称头像到数据库失败问题描述：环信服务器不存储用户的昵称头像等用户数据。需要客户端自己来存储并展示在界面上。有几个时机是需要插入或更新一条包含昵称、头像的用户数据到数据库里，比如查看用户详情，在某个页面收到环信消息。我们服务器提供的查询用户信息接口返回的昵称和头像，之前是没有问题的，有一次出现了从用户信息界面进入聊天页面不显示昵称的问题。 问题原因：经排查，接口返回的用户头像字段的值是null，由于客户端之前没有做空处理，导致插入或更新一条数据失败。12DB Query: INSERT or REPLACE INTO t_huanxin (hxId,nickname,avatar) VALUES (?,?,?)Unknown error finalizing or resetting statement (19: NOT NULL constraint failed: t_huanxin.avatar) 解决方案：存储用户信息到本地数据库时增加安全判断。如果为空，就存入空字符串。避免插入或更新字段为null导致操作失败。12NSString *nickname = dic[@\"nickname\"]?:@\"\";NSString *avatar = dic[@\"avatar\"]?:@\"\"; 问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息问题描述：使用环信Demo发送消息，首条消息发送后，下拉刷新，单聊页面会有两条重复的消息。操作步骤：1.点击单聊页面右上角的清空按钮，清空某个用户的消息。2.返回会话列表。3.首次进入该用户的单聊页面。4.发送首条消息。5.页面下拉刷新。6.出现了两条一摸一样的消息。 解决方案：在EMChatViewController的tableViewDidTriggerHeaderRefresh方法中增加如下判断。12345678910- (void)tableViewDidTriggerHeaderRefresh{ //解决首条消息发送后下拉刷新出现两条重复消息的BUG 开始 if (self.dataArray.count &amp;&amp; self.moreMsgId == nil) { [self tableViewDidFinishTriggerHeader:YES reload:NO]; return; } //解决首条消息发送后下拉刷新出现两条重复消息的BUG 结束 other code} 问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录问题描述：iOS环信Demo聊天页面，发送语音，点击“按住录音”，发送了0秒的聊天记录。 解决方案：在EMChatViewController的chatBarRecordAudioViewStopRecord:timeLength:方法中增加对录音时长的判断。123456789101112- (void)chatBarRecordAudioViewStopRecord:(NSString *)aPath timeLength:(NSInteger)aTimeLength{ EMVoiceMessageBody *body = [[EMVoiceMessageBody alloc] initWithLocalPath:aPath displayName:@\"audio\"]; body.duration = (int)aTimeLength; if (body.duration == 0) { NSLog(@\"录音时长为0\"); NSLog(@\"录制时间过短，不能发送\"); return; } [self _sendMessageWithBody:body ext:nil isUpload:YES];} 问题5 聊天页面点击查看图片，图片右上角按钮显示Done问题描述：聊天页面，点击查看图片，图片右上角的按钮显示Done，而不是”完成“。 解决方案：直接全局搜索Done,把环信UI里的Done,替换成”完成“即可。 问题6 如何实现推送消息内容自定义问题描述：不想使用环信默认的推送内容：”您有一条新消息”，或”xxx：消息内容”。想实现自定义的消息内容。 解决方案：发送消息扩展里添加字段em_apns_ext12345{nickname:\"王小二\",avatar:\"http://www.baidu.com\",em_apns_ext:{\"em_push_content\":\"自定义推送内容\"}} 参考链接：环信 APNs 内容解析文档 问题7 头像链接与路由短链冲突问题描述：项目里点击推送通知到落地页采用了路由模式，有一个场景是需要我们自己服务器发推送点击通知栏跳转到聊天页面。路由短链类似：page://chat?from=hxId_10086,由于某些原因，需要带上昵称和头像，加上头像链接后，短链变成了page://chat?from=hxId_10086&amp;avatar=http://www.baidu.com&amp;nickname=王小二，iOS 解析短链的方法是先把短链字符串转成了URL，加了avatar参数之后，转换失败，导致无法跳转。 解决方案： 方案1：由于短链中含有URL，其实违反了路由链接设计的初衷，可以把avatar的值用AES加密一下传输，避免出现链接。 方案2：不把短链字符串转换成URL，直接处理短链，去解析。 问题8 小程序发的语音消息iOS无法播放问题描述：小程序发过来的语音消息iOS无法播放。 问题原因：Android和iOS发的语音格式都是AMR，小程序发的语音格式是MP3，iOS收到音频后，会先调用_convertAudioFile:方法转换格式，该方法内部实现实现里有一行代码是判断路径是否是MP3文件的，1[EMAudioPlayerHelper isMP3File:retPath] 这个判断方法有问题，发过来的是MP3，却判断不是MP3，接着音频被当成AMR去转换WAV ，转换音频格式失败，播放失败。 解决方案：在EMAudioPlayerHelper类中的startPlayerWithPath:model:completion:方法中增加判断，如果含有.mp3，就不转换，直接去播放。不含.mp3，就照旧走_convertAudioFile:转换格式方法。123456if ([aPath containsString:@\".mp3\"]) { //不转换}else { aPath = [self _convertAudioFile:aPath];}// aPath = [self _convertAudioFile:aPath]; 问题扩展：iOS发的语音消息，Web/小程序收到后无法播放？App端发来的文件是AMR格式的，小程序需要下载的时候转成MP3格式去播放。转换方法如下：参考链接：环信 Web IM 音频消息文档","link":"/imeasemob/"},{"title":"《三年高考五年模拟》系列之微店篇","text":"当我们在问面试题时，我们究竟在问什么？OBJC.VIP 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到objcvip@163.com斧正。本期带来《三年高考五年模拟》系列之微店篇。 题目链接：微店面试题 1. 一面1、说项目里的有价值的东西？ 2、HTTPS 过程是怎么样的？非对称加密 3、Swift 中逃逸闭包和非逃逸闭包的区别？ 4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？ 5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？ 6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？ 7、GCD 内部实现？ 8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？ 9、KVO 的原理？具体 NSObject 的两个方法？ 10、消息转发流程？使用场景？ 11、数据库减字段怎么容错？ 12、有没有打包过私有库？ 13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？ 14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？ 15、说一下一个项目的架构？ 16、组件化？ 17、手写冒泡排序算法？算法复杂度？ 2. 二面1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？ 2、写一下其中一个项目的项目架构？写一下用到的第三方库。 3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？ 4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？ 5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？ 6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图） 7、加密算法，对称加密和非对称加密？ 8、如何理解 OC 是动态语言？ 9、Runtime？用 Runtime 做过什么？ 10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？ 11、内存管理？内存优化？ 12、卡顿？ 13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d） 14、从点击 App 图标，到显示界面流程？ 15、组件化？ 16、编译过程？某一个东西是属于哪一步骤的？ 17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图） 18、RN、Week？内部是怎么用 JS 调用原生的？ 19、日志记录？ 20、遇到的闪退？Bug？ 21、竞争同一个资源？ 22、进程线程与 App 的关系。 23、Git rebase","link":"/《三年高考五年模拟》系列之微店篇/"},{"title":"《三年高考五年模拟》系列之滴滴出行篇","text":"当我们在问面试题时，我们究竟在问什么？OBJC.VIP 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到objcvip@163.com斧正。本期带来《三年高考五年模拟》系列之滴滴出行篇。 题目链接： 滴滴笔试题 滴滴面试题 1. 笔试题0.姓名？日期。 1.C语言实现字符串反转：void reverse(char *str, int length) {} 2.实现一个字符串数组去重函数。 3.描述OC中对象的实现原理。 4.编写代码，实现 NSObject 中添加一个属性 p1 5.KVO 的实现原理和注意事项。 6.下面的代码有哪些问题？ 123456789101112131415@interface Demo : NSObject@property (nonatomic, assign) BOOL *p1;@property (nonatomic, strong) NSString *p2;@end@implementation Demo@dynamic p1;- (void)setP2:(NSString *)p2;{ self.p1 = YES; self.p2 = p2;}@end 7.JS 和 Native 的通讯方式。 8.网络5层模型是哪5层？ 9.把t1表中 name 为 mike 的记录中 status 值改为1 10.常用的 Linux 命令。 11.用过的包/库管理工具。 2. 一面1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？ 2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？ 3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？ 4、你觉得自己是什么级别的？优势和不足主要是哪方面？ 5、GCD 平时项目里怎么用的？我提到了回到主线程操作 UI 需要 dispatch_get_mainQueue 6、为什么操作 UI 需要在主线程？ 7、哪些是你独立开发的项目？ 8、问了一下上家公司的情况 9、之后有什么打算？ 10、上家薪资多少？你还有啥想问的吗？ 3. 二面1、自定义封装控件需要注意什么？有什么规范？ 2、说一下你了解的设计模式。 3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？ 4、内存优化是怎么做的？我提到了内存泄漏。什么情况会发生内存泄漏？ 5、App 启动时间优化？ 6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？ 7、AFNetworking 内部是怎么样的一个过程？ 8、你还有什么想问我的？","link":"/《三年高考五年模拟》系列之滴滴出行篇/"},{"title":"《三年高考五年模拟》系列之美团篇","text":"当我们在问面试题时，我们究竟在问什么？OBJC.VIP 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到objcvip@163.com斧正。本期带来《三年高考五年模拟》系列之美团篇。 题目链接：美团面试题 1、Block 的底层原理，结构，内存以及需要注意的地方。2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？3、Runtime。4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。7、做过什么动画。8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。9、网络层级，TCP 和 UDP 的区别。10、SDWebImage 的框架结构，缓存机制。11、Git 的 rebase 的原理。Git 流程。12、对组件化的了解，组件化是为了解决什么问题。13、JSPatch 的原理。14、单例是为了处理什么问题而使用的，单例和全局变量的区别。15、对设计模式的掌握。16、分层打印二叉树。","link":"/《三年高考五年模拟》系列之美团篇/"},{"title":"《三年高考五年模拟》系列之苏宁篇","text":"当我们在问面试题时，我们究竟在问什么？OBJC.VIP 特别推出《三年高考五年模拟》系列文章，祝大家早日面向大厂进阶。笔者意在抛砖引玉，答案勘误及建议欢迎在下方评论或发邮件到objcvip@163.com斧正。本期带来《三年高考五年模拟》系列之苏宁篇。 题目链接：苏宁面试题 1. 笔试题1.1 冒泡排序Objective-C 实现如下：1234567891011121314- (void)bubbleSort:(NSMutableArray *)array { for (int i = 0; i &lt; array.count; i++) { for (int j = 0; j &lt; array.count-1-i; j++) { NSInteger left = [array[j] integerValue]; NSInteger right = [array[j+1] integerValue]; if (left &lt; right) { [array exchangeObjectAtIndex:j withObjectAtIndex:j+1]; } } } NSLog(@&quot;%@&quot;,array);} 参考链接：【算法】冒泡排序 1.2 二分查找Swift实现如下：123456789101112131415func binarySearch&lt;T: comparable&gt;(_a: [T], key: T) -&gt; Int? { var lowerBound = 0 var upperBound = a.count while lowerBound &lt; upperBound { let midIndex = lowerBound + (upperBound - lowerBound) / 2 if a[midIndex] == key { return midIndex } else if a[midIndex] &lt; key { lowerBound = midIndex + 1 } else { upperBound = midIndex } } return nil} 参考链接：【算法】二分查找 1.3 合并两个数组去重参考链接：【算法】合并两个数组并去重 1.4 两个大数相加参考链接：大数相加算法 2. 一面2.1 SDWebImage 的缓存机制？LRU 说一下。SDWebImage加载图片拿到url会先把url的MD5值作为key从内存中查找，如果内存中有，则直接取图片显示；如果内存中没有，会从磁盘中查找。磁盘中没有，会走下载流程。LRU 最近最少使用。缓存容量满时，会先清理最近最少的缓存。 2.2 数据库升级，比如从 1.0 升级到 2.0，增加了字段。做好兼容处理。 2.3 性能优化2.3.1 优化启动时间 将一些耗时操作延迟执行。比如SDK的初始化，界面的创建。 不能延迟执行的，尽量放到后台执行。比如数据读取，原始 JSON 数据转对象，日志发送。 减少动态库、合并动态库，定期清理不必要的动态库。 减少类、分类的数量，合并Category和功能类似的类。删除不必要的方法和类、分类。 将不必须在+load中做的事延时到+initialize中。 2.3.2 减少CPU、GPU资源消耗 cell复用，header、footer复用。 尽量把view设置不透明。 减少视图的层级。 尽量避免调整视图层次、添加和移除视图。 合理选择加载图片的方式，UIImage imageNamed: ImageAssets 用于多个地方重复使用，UIImage imageWithContentsOfFile 一般用在图片数据很大，一般不需要多次使用的情况。 图片大小最好和UIImageView的大小相同。 不要阻塞主线程，耗时操作放在子线程进行。 懒加载。 缓存，缓存图片SDWebImage，缓存行高，NSCache缓存。 复用高开销对象NSDateFormatter和NSCalendar。 减少离屏渲染，优化圆角、阴影。 使用正确的数据存储。 2.3.3 内存优化 减少内存泄漏。 降低内存使用峰值。 懒加载。 灵活运用图片和文件加载。 拉长文件处理机制，逐步处理文件。 2.3.4 耗电优化耗电功率是个比较综合的指标，影响因素很多。密集的网络请求，长链接，密集的CPU操作（比如大量的复杂计算）都会使耗电功率增加。网络状况（流畅的Wi-Fi还是信号不好的3G）都会影响。 优化网络。 减少、压缩网络数据。 若多次网络请求结果相同，尽量使用缓存。 网络不可用时，不进行网络请求。 优化CPU、GPU消耗。 优化I/O操作，使用dispatch_io。 定位优化 尽量降低定位精度，如不要使用精度最高的KCLLocationAccuracyBest。 如果只是需要快速确定用户位置，用 CLLocationManager 的 requestLocation 方法定位，定位完成后，定位硬件会自动断电。 2.4 Git 开发流程。 master develop dev-xx 具体开发人员分支 开发完成后发起PR。项目提审打Tag 2.5 微信登录流程。注册微信的AppKey与AppSecret。使用微信SDK方法调起微信，回调拿到一些参数，把包含openId等协定好的参数传给服务器，由服务器判断该用户是否注册过，如果注册过，返回登录成功后的用户相关信息。 2.6 WebView 与 JS 交互。H5调用原生采用拦截协议的方式。执行JS方法：evaluateScript也可以使用JSBridge等方式。 2.7 说一下Runloop，苹果设计 Runloop 的初衷是什么？Runloop 运行循环。让线程在有任务的时候忙任务，没任务的时候休眠。参考链接：【iOS 开发】RunLoop 总结 2.8 Delegate代理用assign修饰。 2.9 GCD参考链接：GCD 的 API 2.10 深拷贝与浅拷贝深拷贝是拷贝整个对象。浅拷贝只拷贝对象的指针。copy用于修饰NSArray、NSDictionary、NSString。如果=右边赋值的对象是可变的，copy是深拷贝，拷贝对象的本身。如果赋值的对象是不可变的，copy是浅拷贝，只拷贝对象的指针。用copy和用strong的区别？用copy更安全，避免赋的值是可变的。如果能确保赋的值是不可变的，那么用strong和用copy都是浅拷贝，copy只是多了一个判断，判断可变还是不可变，其他是一样的。NSMutableArray、NSMutableDictionary用Strong修饰，如果用copy，就会拷贝一份，变成不可变的，如果增删数据，就会发生错误。 2.11 进程间通信URL Schemes 2.12 线程间通信，两个线程怎么切换？performSelectorOnThread 2.13 多态多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。子类继承父类后，子类重写父类的方法，实现多态。 2.14 HTTP 三次握手，四次挥手。3. 二面3.1 有没有复杂点的页面。3.2 （这个部门是做智能硬件的）蓝牙有哪些API。3.3 播放音频，展示音频的曲线，具体怎么做？4. 三面","link":"/《三年高考五年模拟》系列之苏宁篇/"},{"title":"京东面试题","text":"京东面试题 1、AFNetworking 是如何实现多线程的。 2、如何自己控制 AFNetWorking 的多线程，如果解决上传多张图片引起的内存剧增的问题。 3、模块化的实现过程。 4、自动化测试。 5、数据库的升级（当前数据库不能满足业务了，1.0-&gt;2.0-&gt;3.0…..）。","link":"/京东面试题/"},{"title":"【算法】二分查找","text":"二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用顺序存储结构，而且表中元素按关键字有序排列。 基本思想首先，假设表中元素是按升序排列，将表中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表分成前、后两个子表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一子表。重复以上过程，直到找到满足条件的记录，使查找成功，或直到子表不存在为止，此时查找不成功。 时间复杂度O(log2n) 算法实现123456789101112131415func binarySearch&lt;T: Comparable&gt;(_ a: [T], key: T) -&gt; Int? { var lowerBound = 0 var upperBound = a.count while lowerBound &lt; upperBound { let midIndex = lowerBound + (upperBound - lowerBound) / 2 if a[midIndex] == key { return midIndex } else if a[midIndex] &lt; key { lowerBound = midIndex + 1 } else { upperBound = midIndex } } return nil}","link":"/二分查找/"},{"title":"【算法】冒泡排序","text":"冒泡排序。 算法原理 比较相邻的元素。如果第一个比第二个大，就交换两个元素。 对每一对相邻的元素做同样的工作，从开始第一对到结尾最后一对。一次循环后，最后的元素应该会是最大的数。 针对所有元素重复以上步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 外层循环控制数组的容量，内层循环一个一个比较交换排序。 时间复杂度冒泡排序最好的时间复杂度是O(n)最坏时间复杂度是O(n^2)平均复杂度为O(n^2)冒泡排序是一种稳定的排序算法。 算法实现C语言1234567891011121314void bubble_sort (int a[], int n);void bubble_sort (int a[], int n){ int i, j, temp; for ( j = 0; j &lt; n; j++) { for ( i = 0; i &lt; n-1-j; i++) { if (a[i] &gt; a[i + 1]) { temp = a[i]; a[i] = a[i + 1]; a[i + 1] = temp; } } }} Objective-C123456789101112- (void)sort:(NSMutableArray *)array {for (int i = 0; i &lt; array.count; i++) { for (int j = 0; j &lt; array.count-1-j; j++) { NSInteger left = [array[j] integerValue]; NSInteger right = [array[j+1] integerValue]; if (left &lt; right) { [array exchangeObjectAtIndex:j withObjectAtIndex:j+1]; } }}NSLog(@\"%@\",array);} Swift1234567891011func bubbleSort(_ array: inout [Int]) { let n = array.count for i in 0..&lt;n { for j in 0..&lt; (n-1-j) { if array[j] &gt; array[j+1] { array.swapAt (j, j+1) } } } print(array)}","link":"/冒泡排序/"},{"title":"【算法】合并两个数组并去重","text":"合并两个数组并去重。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 合并两个含有nA、nB个元素的有序数组void Merge(int *a, int *b, int *c, int nA, int nB, int&amp; nCout){ int i = 0 ; int j = 0 ; int k = 0 ; while (i &lt; nA &amp;&amp; j &lt; nB) { if (a[i] &lt; b[j])// 如果a的元素小，则插入a中元素到c { c[k++] = a[i] ; ++i ; nCout++; } else if (a[i] == b[j])// 如果a和b元素相等，则插入二者皆可，这里插入a { c[k++] = a[i] ; ++i ; ++j ; nCout++; } else // a[i] &gt; b[j] // 如果b中元素小，则插入b中元素到c { c[k++] = b[j] ; ++j ; nCout++; } } if (i == nA) // 若a遍历完毕，处理b中剩下的元素 { for (int m = j; m &lt; nB; ++m) { c[k++] = b[m] ; nCout++; } } else//j == n, 若b遍历完毕，处理a中剩下的元素 { for (int m = i; m &lt; nA; ++m) { c[k++] = a[m] ; nCout++; } }}","link":"/合并两个数组并去重/"},{"title":"【算法】快速排序","text":"快速排序算法。 基本思想通过一趟排序将要排序的数分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对着两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法原理 设置两个变量i、j，排序开始的时候：i = 0，j = N-1; 以数组的第一个元素作为关键数据，赋值给key，即key = A[0]; 从j开始向前搜索，即由后开始向前搜索（j–）,找到第一个小于key的值A[j],将A[j]和A[i]互换。 从i开始向后搜索，即由前开始向后搜索(i++),找到第一个大于key的值A[i],将A[i]和A[j]互换。 重复第3、4步，直到i=j。时间复杂度最优情况下，时间复杂度为O(nlogn)。最坏情况下，时间复杂度为O(n^2)。平均情况时间复杂度为O(nlogn)。算法实现C语言1234567891011121314151617181920212223242526void sort (int *a, int left, int right){ if (left &gt;= right) //如果左边索引大于或等于右边的索引就代表已经整理完成了。 { return; } int i = left; int j = right; int key = a[left]; while (i &lt; j) { while (i &lt; j &amp;&amp; key &lt;= a[j]) { j--; } a[i] = a[j]; while (i &lt; j &amp;&amp; key &gt;= a[i]) { i++; } a[j] = a[i]; } a[i] = key; sort (a, left i-1); sort (a, i+1, right);}","link":"/快速排序/"},{"title":"好未来面试题","text":"好未来面试题 一面1、说一下optional。（？ ！ ？？ 几种解包方式 if let、guard、？？等） 2、说一下闭包。 3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？( KVO 效率最低，因为 Runtime ） 4、NSString 和 String 的区别？（ String 是值类型，NSString 是引用类型） 5、Swift 跟 OC 的区别？（ OC 是动态的语言，Swift 是静态的语言）OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？ 6、说一下 MRC ？自动释放池？自动释放池什么时候释放？（我说 drain ） 7、说一下多线程？（我提到了 dispatch_once 单例） 8、分别用 OC 和 Swift 手写一下单例。（ Swift 的单例我忘记写 static 了，但是经提醒立马说出来了） 9、SnaptKit 内部看过吗？ 10、链式语法的实现。 UIView.top.equalTo().offSet(10) UIView.left.equalTo().offSet(10) 为什么能写成UIView.top.left.offSet(10) 二面主要是手写算法题： 1、用两个栈实现队列。 2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。 三面项目经理 四面HR","link":"/好未来面试题/"},{"title":"微店面试题","text":"微店面试题 微店一面1、说项目里的有价值的东西？ 2、HTTPS 过程是怎么样的？非对称加密 3、Swift 中逃逸闭包和非逃逸闭包的区别？ 4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？ 5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？ 6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？ 7、GCD 内部实现？ 8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？ 9、KVO 的原理？具体 NSObject 的两个方法？ 10、消息转发流程？使用场景？ 11、数据库减字段怎么容错？ 12、有没有打包过私有库？ 13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？ 14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？ 15、说一下一个项目的架构？ 16、组件化？ 17、手写冒泡排序算法？算法复杂度？ 微店二面1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？ 2、写一下其中一个项目的项目架构？写一下用到的第三方库。 3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？ 4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？ 5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？ 6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图） 7、加密算法，对称加密和非对称加密？ 8、如何理解 OC 是动态语言？ 9、Runtime？用 Runtime 做过什么？ 10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？ 11、内存管理？内存优化？ 12、卡顿？ 13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d） 14、从点击 App 图标，到显示界面流程？ 15、组件化？ 16、编译过程？某一个东西是属于哪一步骤的？ 17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图） 18、RN、Week？内部是怎么用 JS 调用原生的？ 19、日志记录？ 20、遇到的闪退？Bug？ 21、竞争同一个资源？ 22、进程线程与 App 的关系。","link":"/微店面试题/"},{"title":"【算法】斐波那切数列","text":"题目：求斐波那切数列的第 n 项。 解法1：12345678long long Fibonacci(unsigned int n){ if(n &lt;= 0) return 0; if(n == 1) return 1; return Fibonacci(n-1) + Fibonacci(n-2);} 递归代码之所以慢，是因为重复的计算太多，我们只要想办法避免重复计算就行了。 解法2：该解法是从下往上计算，首先根据 f(0) 和 f(1) 计算出 f(2)，再根据 f(1) 和 f(2) 算出 f(3)……以此类推就可以算出第 n 项了。很容易理解，这种思路时间复杂度是 O(n)。1234567891011121314151617long long Fibonacci(unsigned n){ int result[2] = {0, 1}; if(n &lt; 2) return result[n]; long long fibNMinusOne = 1; long long fibNMinusTwo = 0; long long fibN = 0; for(unsigned int i = 2; i &lt;= n; ++i) { fibN = fibNMinusOne + fibNMinusTwo; fibNMinusTwo = fibNMinusOne; fibNMinusOne = fibN; } return fibN;}","link":"/斐波那切数列/"},{"title":"开果科技面试题","text":"开果科技面试题 一面1、卡顿原因、解决办法。为什么透明视图不如不透明视图？ 2、闪退原因、监测、过程。友盟是怎么捕获闪退的？从一个事件到闪退发生了什么？ 3、图片的压缩，从600k到500k，不能设置固定压缩比，应该怎么做？压缩图片，压缩图片实际压缩的是哪些东西？加载超大图；图片在计算机中的存储形式；10M的图片加载到内存中是多大？大图是怎么加载的？ 图像文件存储的都是每一个像素对应的颜色值。 4、字典的本质？哈希表原理？ 哈希表。 5、链表和数组，哪个容易找到地址？ 数组。 在内存中，数组是一块连续的区域。插入和删除数据效率低。随机读取效率很高，因为数组是连续的，知道每一个数据的内存地址，可以直接找到给地址的数据。 链表增加和删除数据很容易。查找数据时效率低，因为不具有随机访问性。 6、列表有好多页，某一页和后边加载的一页中有相同的数据，怎么处理？ 7、动态库和静态库的区别。 8、设计模式。 二面(电话面试)1、什么时候开始接触 iOS？怎么学的iOS？ 2、公司多少人？什么项目？ 3、你会选择什么样的公司？ 4、数据库（SQLite/Realm）是怎么保证线程安全的？ 5、UserDeafaults 系统做了哪些优化？为什么可以在主线程上去做存取？如果让你实现，方法已经是同步的方法了，你会怎么处理？ 6、+load 和 +initialize 方法什么时候会调用，+load 和 +initialize 方法、main 方法这三个的调用顺序。 7、@class 和 #import 在编译的时候有哪些区别？ 8、JSON 转 Model 你用的是什么？MJExtension 字典转模型的具体步骤？拿到字典了，第一步做什么，第二步做什么？ 9、WebView 跟 JS 是怎么交互的？ 10、WebView 怎么存 cookie？ 11、A-&gt;B-&gt;C-&gt;D 从D返回到B。说几个不同的实现思路。 方案1：for 循环 self.navigationController.viewControllers 判断某个控制器是否是 B 如果是就 popToViewController:B。 方案2：self.navigationController.viewControllers 是一个不可变数组，可以赋值给一个可变的数组，然后把 C 移除，然后再赋值给 viewControllers。 其他方案：提示不一定要 push，present出来的怎么弄？ 12、二分查找。 13、深拷贝与浅拷贝，某个值得改变可能会影响原始值，那是深拷贝还是浅拷贝？ 14、性能优化？图片加载到 UIImageView 上经过了哪些过程？ 15、Label 怎么多行显示。 16、Button有哪些状态？ 17、dispatch_group_notify 是在哪个线程上？","link":"/开果科技面试题/"},{"title":"【算法】排序算法","text":"排序算法。 排序算法 非线性时间比较类排序交换排序 冒泡排序 快速排序插入排序 插入排序 希尔排序选择排序 简单选择排序 堆排序归并排序 二路归并排序 多路归并排序线性时间非比较类排序 计数排序 桶排序 基数排序时间复杂度参考链接十大经典排序算法","link":"/排序算法/"},{"title":"新浪乐居面试题","text":"新浪乐居面试题 笔试题笔试题 一面1、类方法和实例方法有什么区别？ 2、用封装的类方法去请求网络会有什么问题？ 3、说一下单例。单例的作用是什么？为什么不能多次创建对象？ 4、说一下 ARC、MRC，有什么区别？有啥优缺点？ 5、自动释放池的使用场景？耗内存时需要加到池子里。 6、沙盒目录除了 Documents 还有啥？Cache 和 Temp 有什么区别？ 7、项目里用地图了吗？如果用系统的地图会有一个问题，电量急速下降，遇到过这个问题吗？ 8、都有哪些可能循环引用？ 9、说一下从网络请求回来的数据怎么存？数据持久化的方法。数据库是存在沙盒的哪个目录？我说在 Documents 中。 10、assign 与 weak 区别？ 11、笔试题19的答案为什么是2、5？ 12、说一下冒泡排序的思路？ 13、GCD 需要注意什么？我说了一下使用场景。 14、Runtime、Runloop 了解吗？（说了一下消息发送和消息转发的流程）Runloop 有哪些 Mode？（说了3个，面试官说能用的到的就这三个。。其他俩点进去也看不着）说一下 CommonMode ？ 15、最后一个问题：类似简历 右上角是图片（宽高已知） 左边是一段文字 文字会包裹着图片，问实现思路？ 说了三个思路：（1）计算一下上边 label 宽高，左边用一个 label 显示，下边多余的字也用另一个 label 显示。 （2）YYText 可能有处理办法，算是第三方。 （3）他提示底层一点的，我说绘制。 二面1、了解项目，问在公司干啥。 2、AutoLayout 和 Masonry 有什么区别？ 3、面向对象在 OC 中的体现？封装、继承、多态。你觉得最主要的是面向对象的哪个特性？ 4、你对 H5、原生交互的看法。我说了实现方式后，他说不要实现细节，就你的看法。我又说了阿里是大前端，他说不要说阿里，你的看法呢？我说活动页用H5，其他用原生，可能效率高。 5、Block 和 delegate 的使用场景差异？ 6、你觉得开发一个项目难点在哪儿？ 7、其他问题：薪水能商量吗？有什么要问我的？","link":"/新浪乐居面试题/"},{"title":"滴滴面试题","text":"滴滴面试题 笔试题笔试题 滴滴一面看了一下笔试题的答案，第一题 C 语言字符串反转打印了一下 1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？ 2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？ 3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？ 4、你觉得自己是什么级别的？优势和不足主要是哪方面？ 5、GCD 平时项目里怎么用的？我提到了回到主线程操作 UI 需要 dispatch_get_mainQueue 6、为什么操作 UI 需要在主线程？ 7、哪些是你独立开发的项目？ 8、问了一下上家公司的情况 9、之后有什么打算？ 10、上家薪资多少？你还有啥想问的吗？ 滴滴二面1、自定义封装控件需要注意什么？有什么规范？ 2、说一下你了解的设计模式。 3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？ 4、内存优化是怎么做的？我提到了内存泄漏。什么情况会发生内存泄漏？ 5、App 启动时间优化？ 6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？ 7、AFNetworking 内部是怎么样的一个过程？ 8、你还有什么想问我的？","link":"/滴滴面试题/"},{"title":"滴滴笔试题","text":"滴滴笔试题 笔试题0.姓名？日期。 1.C语言实现字符串反转：void reverse(char *str, int length) {} 2.实现一个字符串数组去重函数。 3.描述OC中对象的实现原理。 4.编写代码，实现 NSObject 中添加一个属性 p1 5.KVO 的实现原理和注意事项。 6.下面的代码有哪些问题？ 123456789101112131415@interface Demo : NSObject@property (nonatomic, assign) BOOL *p1;@property (nonatomic, strong) NSString *p2;@end@implementation Demo@dynamic p1;- (void)setP2:(NSString *)p2;{ self.p1 = YES; self.p2 = p2;}@end 7.JS 和 Native 的通讯方式。 8.网络5层模型是哪5层？ 9.把t1表中 name 为 mike 的记录中 status 值改为1 10.常用的 Linux 命令。 11.用过的包/库管理工具。","link":"/滴滴笔试题/"},{"title":"【算法】用两个栈实现队列","text":"用两个栈实现队列。 题目用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。1234567891011template&lt;typename T&gt; class Queue{public: CQueue(void); ~CQueue(void); void appendTail(const T&amp; node); T deleteHead();private: stack&lt;T&gt; stack1; stack&lt;T&gt; stack2;} 解法123456789101112131415161718192021template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element){ stack1.push(element);}template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead(){ if(stack2.size() &lt;= 0) { while(stack1.size()&gt;0) { T&amp; data = stack1.top(); stack1.pop(); stack2.push(data); } } if(stack2.size() == 0) throw new exception(\"queue is empty\"); T head = stack2.top(); stack2.pop(); return head;}","link":"/用两个栈实现队列/"},{"title":"【算法】用队列实现栈","text":"用队列实现栈。思路：每次取值要取队列的队尾元素，数据队列A出队到辅助队列B，留下最后一个元素返回，辅助队列再把元素出队到数据队列。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct MyStack { var queueA: Queue var queueB: Queue init() { queueA = Queue() queueB = Queue() } var isEmpty: Bool { return queueA.isEmpty &amp;&amp; queueB.isEmpty } var peek: Any? { get { shift() let peekObj = queueA.peek queueB.enqueue(queueA.dequeue()!) swap() return peekObj } } var size: Int { return queueA.size } func push(object: Any) { queueA.enqueue(object) } func pop() -&gt; Any? { shift() let popObject = queueA.dequeue() swap() return popObject } private func shift() { while queueA.size != 1 { queueB.enqueue(queueA.dequeue()!) } } private func swap() { (queueA, queueB) = (queueB, queueA) }}","link":"/用队列实现栈/"},{"title":"苏宁面试题","text":"苏宁面试题 笔试题1、冒泡排序 2、二分查找 3、合并两个数组去重 4、两个大数相加 一面笔试题过一遍。 1、SDWebImage 的缓存机制？LRU 说一下。 2、数据库升级，比如从 1.0 升级到 2.0，增加了字段。 3、性能优化。 4、Git 开发流程。 5、微信登录流程。 6、WebView 与 JS 交互。 7、说一下Runloop，苹果设计 Runloop 的初衷是什么？ 8、性能优化。 9、Delegate 10、GCD 11、深拷贝与浅拷贝。 12、进程间通信。 13、线程间通信，两个线程怎么切换？ performSelector 14、多态。 15、HTTP 三次握手，四次挥手。 二面像是人事，不太像技术。让说具体方案。 1、有没有复杂点的页面。 2、（这个部门是做只能硬件的）蓝牙有哪些API。 3、播放音频，展示音频的曲线，具体怎么做？ 三面技术总监","link":"/苏宁面试题/"},{"title":"美团面试题","text":"美团面试题 1、Block 的底层原理，结构，内存以及需要注意的地方。 2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？ 3、Runtime。 4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。 5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。 6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。 7、做过什么动画。 8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。 9、网络层级，TCP 和 UDP 的区别。 10、SDWebImage 的框架结构，缓存机制。 11、Git 的 rebase 的原理。Git 流程。 12、对组件化的了解，组件化是为了解决什么问题。 13、JSPatch 的原理。 14、单例是为了处理什么问题而使用的，单例和全局变量的区别。 15、对设计模式的掌握。 16、分层打印二叉树。","link":"/美团面试题/"},{"title":"【算法】翻转字符串","text":"题目：翻转单词顺序。输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。 解法第一步先翻转句子中所有的字符，比如翻转”I am a student.”中所有的字符得到”.tneduts a ma I”，此时不但翻转了句子中单词的顺序，连单词内的字符顺序也被翻转了。第二步再翻转每个单词中字符的顺序，就得到了”student. am I”。12345678910111213void Reverse(char *pBegin, char *pEnd){ if(pBegin == nullptr || pEnd == nullptr) return; while(pBegin &lt; pEnd) { char temp = *pBegin; *pBegin = *pEnd; *pEnd = temp; pBegin ++, pEnd --; }} 12345678910111213141516171819202122232425262728293031323334char* ReverseSentence(char *pData){ if(pData == nullptr) return nullptr; char *pBegin = pData; char *pEnd = pData; while(*pEnd != '\\0') pEnd ++; pEnd--; //翻转整个句子 Reverse(pBegin,pEnd); //翻转句子中的每个单词 pBegin = pEnd = pData; while(*pBegin != '\\0') { if(*pBegin == '') { pBegin ++; pEnd ++; } else if(*pEnd == '' || *pEnd == '\\0') { Reverse(pBegin,--pEnd); pBegin = ++pEnd; } else { pEnd ++; } } return pData;} 在英语句子中，单词背空格符号分割，因此我们可以通过扫描空格来确定每个单词的起始位置和终止位置。在上述代码的翻转每个单词阶段，指针 pBegin 指向单词的第一个字符，而指针 pEnd 指向单词的最后一个字符。 Swift实现12345678fileprivate func _reverse&lt;T&gt;(_ chars: inout [T], _ start: Int, _ end: Int) { var start = start, end = end while start &lt; end { _swap(&amp;chars, start, end) start += 1 end -= 1 }} 1234567891011121314func reverseWords(s: String?) -&gt; String? { guard let s = s else { return nil } var chars = Array(s.characters), start = 0 _reverse(&amp;chars, 0, chars.count - 1) for i in 0 ..&lt; chars.count { if i == chars.count - 1 || chars[i + 1] == \" \" { _reverse(&amp;chars, start, i) start = i + 2 } } return String(chars)} 时间复杂度为O(n)。","link":"/翻转字符串/"},{"title":"【算法】选择排序","text":"选择排序。 基本思想选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。 算法原理n个记录的文件的直接选择排序可经过n-1趟直接选择排序得到有序结果： 初始状态：无序区为R[1..n]，有序区为空。 第1趟排序:在无序区R[1..n]中选出关键字最小的记录R[k]，将它与无序区的第1个记录R[1]交换，使R[1..1]和R[2..n]分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。…… 第i趟排序第i趟排序开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区。 时间复杂度平均复杂度为O(n^2) 算法实现1234567891011121314151617181920212223242526272829void select_sort(int*a,int n){ register int i,j,min,t; for(i=0;i&lt;n-1;i++) { min=i;//查找最小值 for(j=i+1;j&lt;n;j++) if(a[min]&gt;a[j]) min=j;//交换 if(min!=i) { t=a[min]; a[min]=a[i]; a[i]=t; } } }","link":"/选择排序/"},{"title":"【算法】连续子数组的最大和","text":"连续子数组的最大和。 题目输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。例如，输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为{3, 10, -4, 7, 2}，因此输出该子数组的和 18。 解法1234567891011121314151617181920212223242526bool g_InvalidInput = false;int FindGreatestSumOfSubArray(int *pData, int nLength){ if(pData == nullptr) || (nLength &lt;= 0) { g_InvalidInput = true; return 0; } g_InvalidInput = false; int nCurSum = 0; int nGreatestSum = 0x80000000; for(int i = 0; i &lt; nLength; ++i) { if(nCurSum &lt;= 0) nCurSum = pData[i]; else nCurSum += pData[i]; if(nCurSum &gt; nGreatestSum) nGreatestSum = nCurSum; } return nGreatestSum;}","link":"/连续子数组的最大和/"},{"title":"面试题交流（2019.10.16）","text":"面试题交流 1、Block的实质是怎样的？使用Block为何容易产生循环引用？ 2、简单说说怎样利用GCD实现高效的多读单写逻辑? 3、Runloop为何能做到有事做事，没事休息？ 4、怎么样解决DNS劫持？ 5、系统的UI事件传递机制是怎样的？ 6、KVO实现原理是怎么样的？ 7、简单说说消息传递机制和消息转发流程？ 8、当一个对象obj废弃的时候，指向它的weak指针为何会自动置为nil？ 9、TableView滑动卡顿与离屏渲染问题，如何优化？ 10、分类可以添加哪些内容？实例方法、类方法、协议、属性 11、iOS持久化方式有哪些？ 12、比较关键词：__weak,__block（或者weak相比assign有什么不同） 13、数组去重问题？ 14、内存分布与内存管理问题，栈区、堆区、未初始化数据、已初始化数据、代码段 15、类方法和实例方法区别？ 16、ARC、MRC，有什么区别？有啥优缺点 17、面向对象在OC的体现? 18、如何理解OC是动态语言？ 19、iOS13，遇到过没有一些问题？如何处理？ 20、说一下单例的作用是什么？为何不能多次创建对象？","link":"/面试题交流20191016/"},{"title":"面试题讨论（2019.09.03）","text":"面试题讨论9.3 函数和方法的区别。 地铁离线二维码的实现。 固定的宽度，如何展示较长的文本。 消息发送，转发流程，Runtime 交换方法的应用。 线程间的通信。 主线程使用同步方法插入同步线程造成阻塞。 同步、异步与串行、并行 异步与并行的区别。 怎么理解OC面向对象中的封装？ NSInterger 占多少个字节。 self = [super init] 为什么要写 [super init]。 Block 有几种？ 深拷贝与浅拷贝 NSArray 是深拷贝还是浅拷贝？NSMutableArray 是深拷贝还是浅拷贝？ [self class] 与 [super class]。 tableView 的优化，离屏渲染。 tableView 的复用机制 屏幕上有6个 cell 复用池里有几个 cell 。","link":"/面试题讨论9.3/"},{"title":"高思教育笔试题","text":"高思教育笔试题 笔试题（部分）3.下面代码输出什么？ 1234567int a = 0;void (^foo)(void) = ^{ a = 1; NSLog(@\"inner a=%d\",a);};foo();NSLog(@\"outer a=%@\",a); 4.下面代码输出什么？ 123456789- (void)viewDidLoad{ [super viewDidLoad]; NSLog(@\"1\"); dispatch_sync(dispatch_get_main_queue(),^{ NSLog(@\"2\"); }); NSLog(@\"3\");} 5.什么情况使用 weak 关键字，相比 assign 有什么不同？ 6.@property 中有哪些属性关键字？/ @property 后面可以有哪些修饰符？ 7.@synthesize 和 @dynamic 分别有什么作用？ 8.什么时候会报 unrecognized selector 的异常？ 9.能否想编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？ 10.如何用 GCD 同步若干异步调用？dispatch_barrier_async 的作用是什么？ 11.如何手动触发一个 value 的 KVO 12.Native 的 Web（WK/UI）控件和 js 的交互是如何实现的？（nativejs） 13.JavaScriptCore 框架中，native 如何调用 js？反之，js如何调用native？ 14.有阅读 Weex、ReactNative 或者 Cordova 框架的描述其一即可。","link":"/高思教育笔试题/"},{"title":"高思教育面试题","text":"高思教育面试题 笔试题笔试题 一面1、@property 本质是什么？NSString 为什么用 Copy，用 Strong 行不行？ 2、block 为什么用 copy ？ 3、block 和代理你用的哪个多？各有什么特点？ 4、GCD 的两个队列（串行、并行）有了解吗？从字面意思看，你觉得这俩哪个效率高，哪个（占空间）忘记了问的啥指标了。。 5、（说一下你的项目吧）看到我的酒店 App，问类似网易新闻那种滑动切换页面你是怎么做的？我说是一个 scrollView，点击按钮后滚动到指定的 index。他说的顶部按钮是3个，如果是30个呢，会有什么问题？他说如果1个页面占用5M，30个页面就占用5x30M，会有内存问题，怎么解决这个问题？我说看过别人写的，用的是子控制器，把这些页面加到当前控制器的子控制器中。（现在想想我也是这么做的。。但是没说是这么做） 6、AFN内部看过吗？AFN的5个模块。 大概这时候问，你觉得自己是什么级别的？（中级） 7、说一下响应者链。 8、一个约束题。 9、项目不忙的时候做过什么优化？（我说用 Instruments 分析过内存泄漏）他说发现过什么问题？（发现过 NSTimer 定时器有内存泄漏）他说那考虑用什么替换定时器呢？（我说没有替换它，退出这个页面的时候关掉了 Timer） 还做过什么优化？（忘记咋回答了） 10、（不知道问啥我的回答是野指针）然后就问野指针是啥？指针指向的那块地址（忘记了。。）如果又有其他指针指向了这块内存，会怎么样（他好像说会闪退） 12、斐波那切数列 0 1 2 3 4 5… 1 1 2 3 5 8 13 21 求n f(n) = f(n-1) + f(n-2) 复试1、怎么学的 iOS ？为什么没搞 Java 2、介绍公司情况，人员规模，介绍项目 3、说一下项目中遇到的问题，怎么解决的？ 4、说一下内存管理，怎么检测内存泄漏的？ 5、你用 OC 开发还是 Swift ？你觉得两者有啥不同？ 6、金融 App 应该有一些安全措施吧？你们是怎么做的？ 7、TCP 和 UDP 有啥区别？ 8、TCP 几次握手？过程是怎么样的？ 9、Post 请求和 Get 请求有啥区别？ 10、数据持久化都有哪些？ 11、AFN 的实现原理？SDWebImage 的实现原理？哪些存在内存，哪些存在磁盘？ 12、两个网络请求有依赖关系时，怎么处理的？ 13、同步、异步 串行、并行 14、几张图合成一张图 15、说一下 Runloop 16、KVO 的实现原理 17、不使用中间变量 实现交换两个数 swap(a, b) 18、copy 关键字修饰什么？ 19、类的私有属性，怎么设置属性值？我答了 KVC 他提到了 Runtime 20、有没有做过音频的处理？类似唱吧把原唱关掉。 21、动画了解的怎么样？ 22、了解 ARKit 吗？ 23、数据结构和算法你怎么样？冒泡排序，选择排序？","link":"/高思教育面试题/"},{"title":"iOS 代码规范","text":"iOS 开发的代码规范。原文链接：有了这些你们团队的代码肯定规范 原则 长的、描述性的方法和变量命名是好的命名方式。不要使用简写，除非是一些大家都知道的场景比如 VIP。不要使用 bgView，推荐使用 backgroundView。 见名知意。含义清楚，做好不加注释代码自我表述能力强。（前提是代码足够规范） 不要过分追求技巧，降低代码可读性。 删除没必要的代码。比如我们新建一个控制器，里面会有一些不会用到的代码，或者注释起来的代码，如果这些代码不需要，那就删除它，留着偷懒吗？下次需要自己手写。 在方法内部不要重复计算某个值，适当的情况下可以将计算结果缓存起来。 尽量减少单例的使用。 提供一个统一的数据管理入口，不管是 MVC、MVVM、MVP 模块内提供一个统一的数据管理入口会使得代码变得更容易管理和维护。 除了 .m 文件中方法，其他的地方”{“不需要另起一行。 123456789101112131415161718- (void)getGooodsList{ // ...}- (void)doHomework{ if (self.hungry) { return; } if (self.thirsty) { return; } if (self.tired) { return; } papapa.then.over;} 变量 一个变量最好只有一个作用，切勿为了节省代码行数，觉得一个变量可以做多个用途。（单一原则） 方法内部如果有局部变量，那么局部变量应该靠近在使用的地方，而不是全部在顶部声明全部的局部变量。 运算符 1元运算符和变量之间不需要空格。例如：++n 2元运算符与变量之间需要空格隔开。例如： containerWidth = 0.3 * Screen_Width当有多个运算符的时候需要使用括号来明确正确的顺序，可读性较好。例如：2 &lt;&lt; (1 + 2 * 3 - 4) 条件表达式 当有条件过多、过长的时候需要换行，为了代码看起来整齐些。 123456789//goodif (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4()) { // Do something}//badif (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4(）) { // Do something } 在一个代码块里面有个可能的情况时善于使用 return 来结束异常的情况。 12345678910111213- (void)doHomework{ if (self.hungry) { return; } if (self.thirsty) { return; } if (self.tired) { return; } papapa.then.over;} 每个分支的实现都必须使用 {} 包含。 123456// badif (self.hungry) self.eat() // goodif (self.hungry) { self.eat()} 条件判断的时候应该是变量在左，条件在右。 if ( currentCursor == 2 ) { //… } switch 语句后面的每个分支都需要用大括号括起来。 switch 语句后面的 default 分支必须存在，除非是在对枚举进行 switch。123456789101112131415161718switch (menuType) { case menuTypeLeft: { // ... break; } case menuTypeRight: { // ... break; } case menuTypeTop: { // ... break; } case menuTypeBottom: { // ... break; }} 类名 大写驼峰式命名。每个单词首字母大写。比如「申请记录控制器」ApplyRecordsViewController 每个类型的命名以该类型结尾。 ViewController：使用 ViewController 结尾。例子：ApplyRecordsViewController View：使用 View 结尾。例子：分界线：boundaryView NSArray：使用 s 结尾。比如商品分类数据源。categories UITableViewCell：使用 Cell 结尾。比如 MyProfileCell Protocol：使用 Delegate 或者 Datasource 结尾。比如 XQScanViewDelegate Tool：工具类 代理类：Delegate Service 类：Service 类的注释有时候我们需要为我们创建的类设置一些注释。我们可以在类的下面添加。 枚举枚举的命名和类的命名相近。123456typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) { UIControlContentVerticalAlignmentCenter = 0, UIControlContentVerticalAlignmentTop = 1, UIControlContentVerticalAlignmentBottom = 2, UIControlContentVerticalAlignmentFill = 3,}; 宏 全部大写，单词与单词之间用 _ 连接。 以 K 开头。后面遵循大写驼峰命名。「不带参数」12#define HOME_PAGE_DID_SCROLL @\"com.xq.home.page.tableview.did.scroll\"#define KHomePageDidScroll @\"com.xq.home.page.tableview.did.scroll\" 属性书写规则，基本上就是 @property 之后空一格，括号，里面的 线程修饰词、内存修饰词、读写修饰词，空一格 类 对象名称 根据不同的场景选择合适的修饰符。1234@property (nonatomic, strong) UITableView *tableView;@property (nonatomic, assign, readonly) BOOL loading; @property (nonatomic, weak) id&lt;#delegate#&gt; delegate;@property (nonatomic, copy) &lt;#returnType#&gt; (^&lt;#Block#&gt;)(&lt;#parType#&gt;); 单例单例适合全局管理状态或者事件的场景。一旦创建，对象的指针保存在静态区，单例对象在堆内存中分配的内存空间只有程序销毁的时候才会释放。基于这种特点，那么我们类似 UIApplication 对象，需要全局访问唯一一个对象的情况才适合单例，或者访问频次较高的情况。我们的功能模块的生命周期肯定小于 App 的生命周期，如果多个单例对象的话，势必 App 的开销会很大，糟糕的情况系统会杀死 App。如果觉得非要用单例比较好，那么注意需要在合适的场合 tearDown 掉。 单例的使用场景概括如下： 控制资源的使用，通过线程同步来控制资源的并发访问。 控制实例的产生，以达到节约资源的目的。 控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。 私有变量推荐以_开头，写在 .m 文件中。例如NSString * _somePrivateVariable 代理方法 类的实例必须作为方法的参数之一。 对于一些连续的状态的，可以加一些 will（将要）、did（已经） 以类的名称开头123- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath; 方法 方法与方法之间间隔一行 大量的方法尽量要以组的形式放在一起，比如生命周期函数、公有方法、私有方法、setter &amp;&amp; getter、代理方法.. 方法最后面的括号需要另起一行。遵循 Apple 的规范 对于其他场景的括号，括号不需要单独换行。比如 if 后面的括号。 如果方法参数过多过长，建议多行书写。用冒号进行对齐。 一个方法内的代码最好保持在50行以内，一般经验来看如果一个方法里面的代码行数过多，代码的阅读体验就很差（别问为什么，做过重构代码行数很长的人都有类似的心情） 一个函数只做一个事情，做到单一原则。所有的类、方法设计好后就可以类似搭积木一样实现一个系统。 对于有返回值的函数，且函数内有分支情况。确保每个分支都有返回值。 函数如果有多个参数，外部传入的参数需要检验参数的非空、数据类型的合法性，参数错误做一些措施：立即返回、断言。 多个函数如果有逻辑重复的代码，建议将重复的部分抽取出来，成为独立的函数进行调用 方法如果有多个参数的情况下需要注意是否需要介词和连词。很多时候在不知道如何抉择测时候思考下苹果的一些 API 的方法命名。 123456789//good- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;//bad- (instancetype)initWithAge:(NSInteger)age andName:(NSString *)name;- (void)tableView:(UITableView *)tableView :(NSIndexPath *)indexPath; .m 文件中的私有方法需要在顶部进行声明 方法组之间也有个顺序问题。 在文件最顶部实现属性的声明、私有方法的声明（很多人省去这一步，问题不大，但是蛮多第三方的库都写了，看起来还是会很方便，建议书写）。 在生命周期的方法里面，比如 viewDidLoad 里面只做界面的添加，而不是做界面的初始化，所有的 view 初始化建议放在 getter 里面去做。往往 view 的初始化的代码长度会比较长、且一般会有多个 view 所以 getter 和 setter 一般建议放在最下面，这样子顶部就可以很清楚的看到代码的主要逻辑。 所有button、gestureRecognizer 的响应事件都放在这个区域里面，不要到处乱放。 文件基本上就是123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#import \"ViewController.h\"/*ViewController*//*View&amp;&amp;Util*//*model*//*NetWork InterFace*//*Vender*/@interface ViewController ()@end@implementation ViewController#pragma mark - life cycle- (void)viewWillAppear:(BOOL)animated{[super viewDidAppear:animated];}- (void)viewDidAppear:(BOOL)animated{[super viewDidAppear:animated];}- (void)viewDidLoad{[super viewDidLoad];self.title = @\"标准模版\";}- (void)viewWillDisappear:(BOOL)animated{[super viewDidAppear:animated];}- (void)viewDidDisappear:(BOOL)animated{[super viewDidAppear:animated];}- (void)dealloc{NSLog(@\"%s\",__func__);}#pragma mark - public Method#pragma mark - private method#pragma mark - event response#pragma mark - UITableViewDelegate#pragma mark - UITableViewDataSource//...(多个代理方法依次往下写)#pragma mark - getters and setters@end 图片资源 单个文件的命名 文件资源的命名也需要一定的规范，形式为：功能模块名_类别_功能_状态@nx.png Setting_Button_search_selected@2x.png、Setting_Button_search_selected@3x.png Setting_Button_search_unselected@2x.png、Setting_Button_search_unselected@3x.png 资源的文件夹命名 最好也参考 App 按照功能模块建立对应的实体文件夹目录，最后到对应的目录下添加相应的资源文件。 注释 对于类的注释写在当前类文件的顶部 对于属性的注释需要写在属性后面的地方。 //**&lt;userId*/ 对于 .h 文件中方法的注释，一律按快捷键 command+option+/。三个快捷键解决。按需在旁边对方法进行说明解释、返回值、参数的说明和解释 对于 .m 文件中的方法的注释，在方法的旁边添加 //。 注释符和注释内容需要间隔一个空格。 例如： // fetch goods list 版本规范采用 A.B.C 三位数字命名，比如：1.0.2，当有更新的情况下按照下面的依据 版本号示例A.b.c属于重大内容的更新1.0.2 -&gt; 2.0.0a.B.c属于小部分内容的更新1.0.2 -&gt; 1.1.1a.b.C属于补丁更新1.0.2 -&gt; 1.0.3","link":"/CodingGuidelines/"},{"title":"Effective Objective-C 2.0（第2章）","text":"编写高质量iOS与OS X代码的52个有效方法第2章 对象、消息、运行期 6.理解“属性”这一概念使用属性，编译器会自动编写访问这些属性所需要的方法，这个过程由编译器在编译期执行。除了生成方法代码外，编译器还会自动向类中添加适当类型的实例变量，并且在属性名前面加下划线。 可以使用 @synthesize 语法来指定实例变量的名字。 @dynamic 关键字会告诉编译器：不要自动创建实现属性所用的实例变量，也不要为其创建存取方法。而且，在编译器访问属性的代码时，即使编译器发现没有定义存取方法，也不会报错，它相信这些方法能在运行期找到。 属性特质 属性可以拥有的特质分为四类：原子性、读/写权限、内存管理语义、方法名 1.原子性 具备 atomic 特质的获取方法会通过锁定机制来确保其操作的原子性。也就是说，如果两个线程读写同一属性，那么不论何时，总能看到有效的属性值，若是不加锁的话（nonatomic），那么当其中一个线程正在改写某属性值时，另外一个线程也许会突然闯入，把尚未修改好的属性值读取出来，发生这种情况时，线程读到的属性值可能不对。 开发 iOS 程序，属性都声明为 nonatomic。历史原因是：在 iOS 中使用同步锁的开销较大，会带来性能问题。并且并不能保证线程安全。例如，一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为 atomic，也还是会读到不同的属性值。 2.读写/权限 readwrite readonly 3.内存管理语义 assign 针对“纯量类型”的简单赋值操作。 strong 拥有关系。为这种属性设置新值时，设置方法会先保留新值，并释放旧值，然后再将新值设置上去。 weak 非拥有关系。设置方法既不保留新值，也不释放旧值。此特性同 assign 类似，然而在属性所指的对象遭到销毁时，属性值也会清空（nil out）。 unsafe_unretained 语义和 assign 相同，但它适用于“对象类型”，非拥有关系，当目标对象遭到摧毁时，属性值不会自动清空，这一点与 weak 有区别。 copy 与 strong 类似。然而设置方法并不保留新值，而是将其拷贝（copy）。只要实现属性所用的对象是可变的（mutable），就应该在设置新属性值时拷贝一份。 4.方法名 getter=&lt;name&gt; 指定“获取方法”的方法名。例如 UISwitch 类中的 switch 是否打开的属性@property (nonatomic, getter=isOn) BOOL on; setter=&lt;name&gt; 指定“设置方法”的方法名。不常见。 若是自己来实现这些存取方法，那么应该保证其具备相关属性所声明的特质。例如，如果将某个属性声明为 copy，那么就应该在“设置方法”中拷贝相关对象，否则会误导该属性的使用者，而且还会令程序产生 bug。 在实现自定义初始化方法时，如果属性是 copy 修饰的，初始化方法中赋值时也要 copy 一下。 atomic 为什么不能保证线程安全？例：一个线程在连续多次读取某属性值的过程中有别的线程在同时改写该值，那么即便将属性声明为atomic，也还是会读到不同的属性值。 要点 可以使用 @property 语法来定义对象中所封装的数据。 通过“特质”来指定存储数据所需的正确语义。 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。 开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能。 7.在对象内部尽量直接访问实例变量在对象之外访问实例变量，总是应该通过属性来做。 通过属性访问与直接访问的区别 直接访问实例变量不经过 Objective-C 的“方法派发”（method dispatch）步骤，所以直接访问实例变量的速度当然比较快。在这种情况下，编译器所生成的代码会直接访问保存对象实例变量的那块内存。 直接访问实例变量，不会调用其“设置方法”，这就绕过了为相关属性所定义的“内存管理语义”。比方说，如果在 ARC 下直接访问一个声明为 copy 的属性，那么并不会拷贝该属性，只会保留新值并释放旧值。 如果直接访问实例变量，那么不会触发“键值观测”（Key-Value Observing,KVO）通知。 通过属性来访问有助于排查与之相关的错误，因为可以给“获取方法”和/或“设置方法”中新增断点，监控该属性的调用者及其访问时机。 要点 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写（set方法），（1）首要原因在于，这样做能够确保相关属性的“内存管理语义”得以贯彻。（2）为了触发 KVO。 在初始化方法和dealloc方法中，总是应该直接通过实例变量来读写数据。 使用懒加载时，需要通过属性来读取数据。（get方法） 8.理解“对象等同性”这一概念== 比较的是两个指针本身，而不是所指的对象。isEqual 比较的两个对象。 要点 若想检测对象的等同性，请提供“isEqual:”与 hash 方法。 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。 不要盲目地逐个检测每条属性，而是应该依照具体需求来制定监测方案。 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。 9.以“类族模式”隐藏实现细节类族（class cluster）是一种很有用的模式（pattern），可以隐藏“抽象基类”（abstract base class）背后的实现细节。比如 UIButton 的类方法： 1+ (UIButton*)buttonWithType:(UIButtonType)type; 该方法所返回的对象，其类型取决于传入的按钮类型。然而，不管返回什么类型的对象，它们都继承自同一个基类：UIButton。这么做的意义在于：UIButton 类的使用者无需关心创建出来的按钮具体属于哪个子类，也不用考虑按钮的绘制方式等实现细节。 工厂模式（Factory pattern）是创建类族的办法之一。 要点 类族模式可以把实现细节隐藏在一套简单的公共接口后面。 系统框架中经常使用类族。 从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。 10.在既有类中使用关联对象存放自定义数据1void objc_setAssociatedObject(id object, void*key, id value, objc_AssociationPolicy policy) 此方法以给定的键和策略为某对象设置关联对象值。1void objc_getAssociatedObject(id object, void*key) 此方法根据给定的键从某对象中获取相应的关联对象值。1void objc_removeAssociatedObject(id object) 此方法移除指定对象的全部关联对象。 要点 可以通过“关联对象”机制把两个对象连起来。 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。 只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。 11.理解objc_msgSend的作用void objc_msgSend(id self, SEL cmd, …) 这是个参数可变的函数，能接受两个或两个以上的参数。第一个参数代表接收者，第二个参数代表选择子（SEL是选择子的类型），后续参数就是消息中的那些参数，其顺序不变。选择子指的就是方法的名字。 objc_msgSend 函数会根据接收者与选择子的类型来调用适当的方法。为了完成此操作，该方法需要在接收者所属的类中搜寻其“方法列表”（list of methods）,如果能找到与选择子名称相符的方法，就跳转到其实现代码。若是找不到，那就沿着继承体系继续向上查找，等找到合适的方法之后再跳转。如果最终还是找不到相符的方法，那就执行“消息转发”（message forwarding）操作。 objc_msgSend 会将匹配结果缓存在“快速映射表”（fast map）里面，每个类都有这样一块缓存。 边界情况 objc_msgSend_stret。如果待发送的消息要返回结构体，那么可交由此函数处理。 objc_msgSend_fpret。如果消息返回的是浮点数，那么可交由此函数处理。 objc_msgSendSuper。如果要给超类发消息，那么就交由此函数处理。 要点 消息由接收者、选择子及参数构成。给某对象发送消息也就相当于在该对象上调用方法。 发给某对象的全部消息都要由“动态消息派发系统”（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。 12.理解消息转发机制动态方法解析 1+ (BOOL)resolveInstanceMethod:(SEL)selector 假如尚未实现的方法是类方法 resolveClassMethod: 备援接收者 1- (id)forwardingTargetForSelector:(SEL)selector 通过此方案，我们可以用组合来模拟出多重继承（multiple inheritance）的某些特性。 完整的消息转发 首先创建 NSInvocation 对象，把与尚未处理的那条消息有关的全部细节都封于其中。此对象包含选择子、目标（target）及参数。在触发 NSInvocation 对象时，“消息派发系统”（message-dispatch system）将亲自出马，把消息指派给目标对象。 1- (void)forwardInvocation:(NSInvocation*)invocation 要点 若对象无法响应某个选择子，则进入消息转发流程。 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。 对象可以把其无法解读的某些选择子转交给其他对象来处理。 经过上述两步后，如果还是没办法处理选择子，那就启动完整的消息转发机制。 13.用“方法调配技术”调试“黑盒方法”1void method_exchangeImplementations(Method m1, Method m2) 此函数的两个参数表示待交换的两个方法实现，而方法实现则可通过下列函数获得： 1Method class_getInstanceMethod(Class aClass, SEL aSelector) 要点 在运行期，可以向类中新增或替换选择子所对应的方法实现。 使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常使用此技术向原有实现中添加新功能。 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。 14.理解“类对象”的用意Objective-C 对象的本质 每个 Objective-C 对象实例都是指向某块内存数据的指针。 描述 Objective-C 对象所用的数据结构定义在运行期程序库的头文件里，id 类型本身也定义在这里： 123typedef struct objc_object { Class isa;} *id; 由此可见，每个对象结构体的首个成员是 Class 类的变量。该变量定义了对象所属的类。 Class 对象也定义在运行期程序库的头文件中： 12345678910111213typedef struct objc_class *Class;struct objc_class { Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache; struct objc_protocol_list *protocols;} 此结构存放类的“元数据”（metadata）。此结构体的首个变量也是 isa 指针，这说明 Class 本身亦为 Objective-C 对象。结构体里还有个变量叫做 super_class，它定义了本类的超类。类对象所属的类型（也就是 isa 指针所指向的类型）是另外一个类，叫做“元类”（metaclass）,用来表述类对象本身所具备的元数据。“类方法”就定义于此处，因为这些方法可以理解成类对象的实例方法。每个类仅有一个“类对象”，而每个“类对象”仅有一个与之相关的“元类”。 isMemberOfClass: 能够判断出对象是否为某个特定类的实例，而isKindOfClass:则能够判断出对象是否为某类或其派生类的实例。 要点 每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的继承体系。 如果对象类型无法在编译期确定，那么就应该使用类型信息查询方法来探知。 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。","link":"/EffectiveObjectiveCPart2/"},{"title":"Effective Objective-C 2.0（第6章）","text":"编写高质量iOS与OS X代码的52个有效方法第6章 块与大中枢派发 37.理解“块”这一概念 块是C、C++、Objective-C 中的词法闭包。 块可接受参数，也可返回值。 块可以分配在栈或堆上，也可以是全局的。分配在栈上的块可拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。 38.为常用的块类型创建 typedef 以typedef重新定义块类型，可令块变量用起来更加简单。 定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需修改相应的 typedef 中的块签名即可，无须改动其他typedef。 39.用 handler 块降低代码分散程度 在创建对象时，可以使用内联的 handler 块将相关业务逻辑一并声明。 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handler 块来实现，则可直接将块与相关对象放在一起。 设计 API 时如果用到了 handler 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行。 40.用块引用其所属对象时不要出现保留环123456- (void)p_requestCompleted { if (_completionHandler) { _completionHandler(_downloadedData); } self.completionHandler = nil;} 只要下载请求执行完毕，保留环就解除了，而获取器对象也将会在必要时为系统所回收。 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。 一定要找个适当的时机解除保留环，而不能把责任推给 API 的调用者。 41.多用派发队列，少用同步锁锁 同步块（synchronization block） 12345- (void)synchronizedMethod { @synchronized(self) { //Safe }} NSLock锁对象 NSRecursiveLock递归锁 123456_lock = [[NSLock alloc] init];- (void)synchronizedMethod { [_lock lock]; //Safe [_lock unlock];} 缺陷： 在极端情况下，同步块会导致死锁。 效率不见得很高。 直接使用锁对象，一旦遇到死锁，就会非常麻烦。 用atomic来修饰属性，只能提供某种程度的线程安全，无法保证访问该对象时绝对是线程安全的。使用属性时，必然能从中获取到有效值，然而在同一线程上多次调用获取方法（getter），每次获取到的结果未必相同。在两次访问操作之间，其他线程可能会写入新的属性值。 GCD 串行同步队列（serial synchronization queue）12345678910111213_syncQueue = dispatch_queue_create(\"com.effectiveObjectivec.syncQueue\",NULL);- (NSString *)someString { __block NSString *localSomeString; dispatch_sync(_syncQueue, ^{ localSomeString = _someString; }); return localSomeString;}- (void)setSomeString:(NSString *)someString { dispatch_sync(_syncQueue, ^{ _someString = someString; });} 思路是：把设置操作与获取操作都安排在序列化的队列里执行，这样的话，所有针对属性的访问操作就都同步了。全部加锁任务都在GCD中处理。并发队列（concurrent queue）栅栏（barrier）在队列中，栅栏块必须单独执行，不能与其他块并行。这只对并发队列有意义，因为串行队列中的块总是按顺序逐个来执行的。并发队列如果发现接下来要处理的块是个栅栏块，那么久一直要等栅栏块执行过后，再按正常方式继续向下处理。 要点 派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用@synchronized 块或 NSLock 对象更简单。 将同步与异步派发结合起来，可以实现与普通加锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。 使用同步队列及栅栏块，可以令同步行为更加高效。 42.多用GCD，少用 performSelector 系列方法 performSelector 可能内存泄漏 performSelector 调用了一个方法。编译器并不知道将要调用的选择子是什么，因此，也就不了解其方法签名及返回值，甚至连是否有返回值都不清楚。而且，由于编译器不知道方法名，所以就没办法运用ARC的内存管理规则来判定返回值是不是应该释放。鉴于此，ARC采用了比较谨慎的做法，就是不添加释放操作。然而这么做可能导致内存泄漏，因为方法在返回对象时可能已经将其保留了。 有局限性。 返回值只能是void或对象类型。 参数类型是id，所以只能传入对象。此外，最多只能接受两个参数。 dispatch_syncdispatch_asyncdispatch_after 要点 performSelector 系列方法在内存管理方面容易有疏忽。它无法确定将要执行的选择子具体是什么，因而ARC编译器也就无法插入适当的内存管理方法。 performSelector 系列方法所能处理的选择子太过局限了，选择子的返回值类型及发送给方法的参数个数都收到限制。 如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。 43.掌握GCD及操作队列的使用时机GCD与NSOperationQueue 操作队列在底层是用GCD来实现的。 GCD是纯C的API，而操作队列则是Objective-C的对象。 在GCD中，任务用块来表示，而块是一个轻量级的数据结构。预支相反，“操作”（operation）则是个更为重量级的Objective-C对象。 使用NSOperation及NSOperationQueue的好处： 取消某个操作。运行任务之前，可以在NSOperation对象上调用cancel方法，该方法会设置对象内的标志位，用以表明此任务不需执行，不过，已经启动的任务无法取消。若是不使用操作队列，而是把块安排在GCD队列，那就无法取消了。开发者可以在应用程序层自己来实现取消功能，不过这样做需要编写很多代码，而那些代码其实已经由操作队列实现好了。 指定操作间的依赖关系。 通过键值观察机制监控NSOperation对象的属性。如isCancelled、isFinished。如果想在某个任务变更其状态时得到通知，或是想用比GCD更为精细的方式来控制所要执行的任务，那么键值观察机制会很有用。 指定操作的优先级。GCD只有队列的优先级，没有任务的优先级。NSOpetation对象也有线程优先级，这决定了运行此操作的线程处在何种优先级上。GCD可以实现此功能，然而操作队列更简单，只需设置一个属性。 重用NSOperation对象。系统的NSNotificationCenter API选用了操作队列而非派发队列，开发者可通过其中的方法来注册监听器，以便在发生相关事件时得到通知，而这个方法接受的参数是块，不是选择子。 要点 在解决多线程与任务管理问题时，派发队列并非唯一方案。 操作队列提供了一套高层的Objective-C API，能实现纯GCD所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用GCD来实现，则需另外编写代码。 44.通过 Dispatch Group 机制，根据系统资源状况来执行任务要点 一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。 通过dispatch group，可以在并发式派发队列里同时执行多项任务。此时GCD会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。 45. 使用dispatch_once来执行只需运行一次的线程安全代码实现单例12345678+ (id)sharedInstance { static EOCClass *sharedInstance = nil; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ sharedInstance = [[self alloc] init]; }); return sharedInstance;} 要点 经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过GCD所提供的 dispatch_once 函数，很容易就能实现此功能。 标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的。 46.不要使用 dispatch_get_current_queue要点 dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。此函数已经废弃，只应做调试之用。 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。 dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。","link":"/EffectiveObjectiveCPart6/"},{"title":"《大话数据结构》五","text":"第6章 树树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。 树的定义 树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。 结点分类树的结点包含一个数据元素及若干指向其子树的分支。 结点拥有的子树数称为结点的度（Degree）。度为 0 的结点称为叶结点（Leaf）或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。 结点间关系结点的子树的根称为该结点的孩子（Child），相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之前互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。 树的其他相关概念结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 1 层，则其子树的根就在第 i+1 层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。 如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。 森林（Forest）是 m（m≥0）棵互不相交的树的集合。 线性表与树结构 线性结构 树结构 第一个数据元素：无前驱 根结点：无双亲，唯一 最后一个数据元素：无后继 叶结点：无孩子，可以多个 中间元素：一个前驱一个后继 中间结点：一个双亲多个孩子 树的抽象数据类型ADT 树（tree） Data 树是由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系。 Operation InitTree(*T):构造空树 T。 DestroyTree(*T):销毁树 T。 CreateTree(*T, definition):按 definition 中给出树的定义来构造树。 ClearTree(*T):若树 T 存在，则将树 T 清为空树。 TreeEmpty(*T):若 T 为空树，返回 true，否则返回 false。 TreeDepth(T):返回 T 的深度。 Root(T):返回树的根结点。 Value(T, cur_e):cur_e 是树 T 中一个结点，返回此结点的值。 Assign(T, cur_e,value):给树 T 的结点 cur_e 赋值为 value。 Parent(T, cur_e):若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。 LeftChild(T, cur_e):若 cur_e 是树 T 的非叶结点，则返回它的最左孩子，否则返回空。 RightSibling(T, cur_e):若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。 InsertChild(T, p, i, c):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 指结点的第 i 棵子树。 DeleteChild(T, p, i):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。 endADT 树的存储结构双亲表示法我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器表示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。 以下是我们的双亲表示法的结点结构定义代码。 12345678910111213/* 树的双亲表示法结点结构定义 */#define MAX_TREE_SIZE 100typedef int TElemType; /* 树结点的数据类型，目前暂定为整型 */typedef struct PTNode /* 结点结构 */{ TElemType data; /* 结点数据 */ int parent; /* 双亲位置 */} PTNode;typedef struct /* 树结构 */{ PTNode nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r,n; /* 根的位置和结点数 */} PTree 存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适、是否方便，时间复杂度好不好等。 孩子表示法由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。 孩子表示法。把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，放进一个一维数组中。 以下是我们的孩子表示法的结构定义代码。 1234567891011121314151617/* 树的孩子表示法结构定义 */#define MAX_TREE_SIZE 100typedef struct CTNode /* 孩子结点 */{ int child; struct CTNode *next;} *ChildPtr;typedef struct /* 表头结构 */{ TElemType data; ChildPtr firstchild;} CTBox;typedef struct /* 树结构 */{ CTBox nodes[MAX_TREE_SIZE]; /* 结点数组 */ int r,n; /* 根的位置和结点数 */} CTree; 孩子兄弟表示法任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。 结构定义代码如下。 123456/* 树的孩子兄弟表示法结构定义 */typedef struct CSNode{ TElemType data; struct CSNode *fistchild,*rightsib;} CSNode, *CSTree; 二叉树的定义二叉树（Binary Tree）是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。 二叉树特点二叉树的特点有： 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者一棵子树都是可以的。 左子树和右子树是有顺序的，次序不能任意颠倒。 即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。 二叉树具有五种基本形态： 空二叉树。 只有一个根结点。 根结点只有左子树。 根结点只有右子树。 根结点既有左子树又有右子树。 特殊二叉树1. 斜树所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。 2. 满二叉树在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层，这样的二叉树称为满二叉树。 满二叉树的特点有： （1）叶子只能出现在最下一层。 （2）非叶子结点的度一定是 2。 （3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。 3. 完全二叉树对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。 完全二叉树的特点： （1）叶子结点只能出现在最下两层。 （2）最下层的叶子一定集中在左部连续位置。 （3）倒数二层，若有叶子结点，一定都在右部连续位置。 （4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。 （5）同样结点的二叉树，完全二叉树的深度最小。 判断某个二叉树是否是完全二叉树的办法，就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是。 二叉树的性质二叉树的性质1性质1：在二叉树的第 i 层上至多有 2i-1 个结点（i≥1）。 二叉树的性质2性质2：深度为 k 的二叉树至多有 2k-1 个结点（k≥1）。 二叉树的性质3性质3：对任何一棵二叉树 T，如果其终端结点数为 n0，度为 2 的结点数为 n2，则 n0=n2+1。 二叉树的性质4性质4：具有 n 个结点的完全二叉树的深度为 ⎣log2n⎦+1 ( ⎣x⎦表示不大于 x 的最大整数)。 注：⎣⎦ 向下取整运算。 二叉树的性质5性质5：如果对于一棵有 n 个结点的完全二叉树（其深度为 ⎣log2n⎦+1）的结点按层序编号（从第 1 层到第 ⎣log2n⎦+1 层），每层从左到右，对任一结点 i （1≤i≤n）有： 如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1，则其双亲是结点 ⎣i/2⎦。 如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。 如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。 二叉树的存储结构二叉树顺序存储结构顺序存储结构一般只用于完全二叉树。 二叉链表二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。 以下是我们的二叉链表的结点结构定义代码。 123456/* 二叉树的二叉链表结点结构定义 */typedef struct BitNode /* 结点结构 */{ TElemType data; /* 结点数据 */ struct BiTNode *lchild, *rchild; /* 左右孩子指针 */} BiTNode, *BiTree; 遍历二叉树二叉树遍历原理二叉树的遍历（traversing biary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。 二叉树遍历方法1. 前序遍历规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。 2. 中序遍历规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。 3. 后序遍历规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。 4. 层序遍历规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。 前序遍历算法123456789/* 二叉树的前序遍历递归算法 */void PreOrderTraverse (BiTree T){ if (T==NULL) return; printf(\"%c\",T-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */ PreOrderTraverse (T-&gt;lchild); /* 再先序遍历左子树 */ PreOrderTraverse (T-&gt;rchild); /* 最后先序遍历右子树 */} 中序遍历算法123456789/* 二叉树的中序遍历递归算法 */void InOrderTraverse (BiTree T){ if (T==NULL) return; InOrderTraverse (T-&gt;lchild); /* 中序遍历左子树 */ printf(\"%c\",T-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */ InOrderTraverse (T-&gt;rchild); /* 最后中序遍历右子树 */} 后序遍历算法123456789/* 二叉树的后序遍历递归算法 */void PostOrderTraverse (BiTree T){ if (T==NULL) return; PostOrderTraverse (T-&gt;lchild); /* 先后序遍历左子树 */ PostOrderTraverse (T-&gt;rchild); /* 再后序遍历右子树 */ printf(\"%c\",T-&gt;data); /* 显示结点数据，可以更改为其他对结点操作 */} 推导遍历结果 已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。 已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。 已知前序和后序遍历，是不能唯一确定一棵二叉树的。 二叉树的建立123456789101112131415161718/* 按前序输入二叉树中结点的值（一个字符） *//* #表示空树，构造二叉链表表示二叉树 T。 */void CreateBiTree (BiTree *T){ TElemType ch; scanf(\"%c\",&amp;ch); if (ch=='#') *T=NULL; else { *T=(BiTree)malloc(sizeof(BiTNode)); if (!*T) exit (OVERFLOW); (*T)-&gt;data=ch; /* 生成根结点 */ CreateBiTree(&amp;(*T)-&gt;lchild); /* 构造左子树 */ CreateBiTree(&amp;(*T)-&gt;rchild); /* 构造右子树 */ }} 线索二叉树线索二叉树原理指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。 对二叉树以某种次序遍历使其变为线索二叉树的过程叫做是线索化。 线索二叉树结构实现123456789/* 二叉树的二叉线索存储结构定义 */typedef enum (Link, Thread) PointerTag; /* Link==0 表示指向左右孩子指针 Thread==1 表示指向前驱或后继的线索 */typedef struct BiThrNode /* 二叉线索存储结点结构 */{ TElemType data; /* 结点数据 */ struct BiThrNode *lchild, *rchild; /* 左右孩子指针 */ PointerTag LTag; PointerTag RTag; /* 左右标志 */} BiThrNode, *BiThrTree; 线索化的过程就是在遍历的过程中修改空指针的过程。 如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。 树、森林与二叉树的转换树转换为二叉树将树转换为二叉树的步骤如下 加线。在所有兄弟结点之间加一条连线。 去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。 层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。 森林转换为二叉树步骤如下： 将每个树转换为二叉树。 第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。 二叉树转换为树 加线。 去线。 层次调整。 二叉树转换为森林 从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。 再将每棵分离的二叉树转换为树即可。 树与森林的遍历树的遍历分为两种方式。 一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。 另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。 森林的遍历也分为两种方式： 前序遍历 后序遍历 赫夫曼树及其应用赫夫曼树定义与原理从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。 树的路径长度就是从树根到每一个结点的路径长度之和。 带权路径长度 WPL 最小的二叉树称做赫夫曼树。 赫夫曼编码一般地，设需要编码的字符集为{d1,d2,…,dn}，各个字符在电文中出现的次数或频率集合为 {w1,w2,…,wn}，以 d1,d2,…,dn 作为叶子结点，以 w1,w2,…,wn 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。","link":"/DataStructurePart5/"}],"tags":[{"name":"学习笔记","slug":"学习笔记","link":"/tags/学习笔记/"},{"name":"Effective Objective-C 2.0","slug":"Effective-Objective-C-2-0","link":"/tags/Effective-Objective-C-2-0/"},{"name":"Markdown","slug":"Markdown","link":"/tags/Markdown/"},{"name":"iOS 开发","slug":"iOS-开发","link":"/tags/iOS-开发/"},{"name":"Hello World","slug":"Hello-World","link":"/tags/Hello-World/"},{"name":"算法","slug":"算法","link":"/tags/算法/"},{"name":"栈","slug":"栈","link":"/tags/栈/"},{"name":"面试","slug":"面试","link":"/tags/面试/"},{"name":"ofo","slug":"ofo","link":"/tags/ofo/"},{"name":"三年高考五年模拟","slug":"三年高考五年模拟","link":"/tags/三年高考五年模拟/"},{"name":"环信","slug":"环信","link":"/tags/环信/"},{"name":"京东","slug":"京东","link":"/tags/京东/"},{"name":"冒泡排序","slug":"冒泡排序","link":"/tags/冒泡排序/"},{"name":"排序","slug":"排序","link":"/tags/排序/"},{"name":"开果","slug":"开果","link":"/tags/开果/"},{"name":"面试题","slug":"面试题","link":"/tags/面试题/"},{"name":"滴滴","slug":"滴滴","link":"/tags/滴滴/"},{"name":"笔试题","slug":"笔试题","link":"/tags/笔试题/"},{"name":"队列","slug":"队列","link":"/tags/队列/"},{"name":"苏宁","slug":"苏宁","link":"/tags/苏宁/"},{"name":"美团","slug":"美团","link":"/tags/美团/"},{"name":"选择排序","slug":"选择排序","link":"/tags/选择排序/"},{"name":"高思教育","slug":"高思教育","link":"/tags/高思教育/"},{"name":"代码规范","slug":"代码规范","link":"/tags/代码规范/"}],"categories":[{"name":"《大话数据结构》","slug":"《大话数据结构》","link":"/categories/《大话数据结构》/"},{"name":"Effective Objective-C 2.0","slug":"Effective-Objective-C-2-0","link":"/categories/Effective-Objective-C-2-0/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"iOS 开发","slug":"iOS-开发","link":"/categories/iOS-开发/"},{"name":"Hello World","slug":"Hello-World","link":"/categories/Hello-World/"},{"name":"算法","slug":"算法","link":"/categories/算法/"},{"name":"面试题","slug":"面试题","link":"/categories/面试题/"},{"name":"《三年高考五年模拟》","slug":"面试题/《三年高考五年模拟》","link":"/categories/面试题/《三年高考五年模拟》/"},{"name":"代码规范","slug":"代码规范","link":"/categories/代码规范/"}]}