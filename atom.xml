<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ObjC.vip</title>
  <icon>https://www.gravatar.com/avatar/7f3b33261dd48600587207c66a04554c</icon>
  <subtitle>Stay hungry, stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://objcvip.github.io/"/>
  <updated>2019-09-06T08:51:09.319Z</updated>
  <id>https://objcvip.github.io/</id>
  
  <author>
    <name>ObjC.vip</name>
    <email>objcvip@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>美团面试题</title>
    <link href="https://objcvip.github.io/%E7%BE%8E%E5%9B%A2%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/美团面试题/</id>
    <published>2019-09-06T08:50:00.000Z</published>
    <updated>2019-09-06T08:51:09.319Z</updated>
    
    <content type="html"><![CDATA[<p>美团面试题</p><a id="more"></a><p>1、Block 的底层原理，结构，内存以及需要注意的地方。</p><p>2、图片渲染，一张 png/jpg 格式的图片渲染到页面上显示有哪些流程。png 和 jpg 的区别。png 一定是无损的吗？</p><p>3、Runtime。</p><p>4、Runloop 的结构和循环流程，用 Runloop 做过什么事情。</p><p>5、多线程，NSOperationQueue 和 GCD 的区别。用多线程做过什么事情。线程安全的问题。加锁有几种方式。</p><p>6、NSURLSession 和 NSURLConnection 的区别， NSURLConnection 是怎么封装的。CFNetwork。</p><p>7、做过什么动画。</p><p>8、HTTPS 的工作原理，和 HTTP 的区别。RSA 加密原理。</p><p>9、网络层级，TCP 和 UDP 的区别。</p><p>10、SDWebImage 的框架结构，缓存机制。</p><p>11、Git 的 rebase 的原理。Git 流程。</p><p>12、对组件化的了解，组件化是为了解决什么问题。</p><p>13、JSPatch 的原理。</p><p>14、单例是为了处理什么问题而使用的，单例和全局变量的区别。</p><p>15、对设计模式的掌握。</p><p>16、分层打印二叉树。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;美团面试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="美团" scheme="https://objcvip.github.io/tags/%E7%BE%8E%E5%9B%A2/"/>
    
  </entry>
  
  <entry>
    <title>ofo面试题</title>
    <link href="https://objcvip.github.io/ofo%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/ofo面试题/</id>
    <published>2019-09-06T08:40:00.000Z</published>
    <updated>2019-09-06T08:51:25.596Z</updated>
    
    <content type="html"><![CDATA[<p>ofo面试题</p><a id="more"></a><p>1、bloc k的底层实现?</p><p>2、block 的类型有哪几种?</p><p>3、你碰到的 block 的循环引用?</p><p>4、为什么你在用 masonry , AFNetworking 的 block 回调不需要对 self 进行 __weak?</p><p>5、出现野指针的情况大概有哪些？</p><p>6、swift 里的闭包和 OC 的 block 的区别。</p><p>7、sqlite 使用的时候需要注意什么。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ofo面试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="ofo" scheme="https://objcvip.github.io/tags/ofo/"/>
    
  </entry>
  
  <entry>
    <title>高思教育笔试题</title>
    <link href="https://objcvip.github.io/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/高思教育笔试题/</id>
    <published>2019-09-06T08:25:00.000Z</published>
    <updated>2019-09-06T08:38:23.070Z</updated>
    
    <content type="html"><![CDATA[<p>高思教育笔试题</p><a id="more"></a><h1 id="笔试题（部分）"><a href="#笔试题（部分）" class="headerlink" title="笔试题（部分）"></a>笔试题（部分）</h1><p>3.下面代码输出什么？</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 0;</span><br><span class="line">void (^foo)(void) = ^&#123;</span><br><span class="line">a = 1;</span><br><span class="line">NSLog(@&quot;inner a=%d&quot;,a);</span><br><span class="line">&#125;;</span><br><span class="line">foo();</span><br><span class="line">NSLog(@&quot;outer a=%@&quot;,a);</span><br></pre></td></tr></table></figure><p>4.下面代码输出什么？</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [super viewDidLoad];</span><br><span class="line">  NSLog(@&quot;1&quot;);</span><br><span class="line">  dispatch_sync(dispatch_get_main_queue(),^&#123;</span><br><span class="line">    NSLog(@&quot;2&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">  NSLog(@&quot;3&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5.什么情况使用 weak 关键字，相比 assign 有什么不同？</p><p>6.@property 中有哪些属性关键字？/ @property 后面可以有哪些修饰符？</p><p>7.@synthesize 和 @dynamic 分别有什么作用？</p><p>8.什么时候会报 unrecognized selector 的异常？</p><p>9.能否想编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？</p><p>10.如何用 GCD 同步若干异步调用？dispatch_barrier_async 的作用是什么？</p><p>11.如何手动触发一个 value 的 KVO</p><p>12.Native 的 Web（WK/UI）控件和 js 的交互是如何实现的？（native<->js）</-></p><p>13.JavaScriptCore 框架中，native 如何调用 js？反之，js如何调用native？</p><p>14.有阅读 Weex、ReactNative 或者 Cordova 框架的描述其一即可。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高思教育笔试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="笔试题" scheme="https://objcvip.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
      <category term="高思教育" scheme="https://objcvip.github.io/tags/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>京东面试题</title>
    <link href="https://objcvip.github.io/%E4%BA%AC%E4%B8%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/京东面试题/</id>
    <published>2019-09-06T08:25:00.000Z</published>
    <updated>2019-09-06T08:50:49.144Z</updated>
    
    <content type="html"><![CDATA[<p>京东面试题</p><a id="more"></a><p>1、AFNetworking 是如何实现多线程的。</p><p>2、如何自己控制 AFNetWorking 的多线程，如果解决上传多张图片引起的内存剧增的问题。</p><p>3、模块化的实现过程。</p><p>4、自动化测试。</p><p>5、数据库的升级（当前数据库不能满足业务了，1.0-&gt;2.0-&gt;3.0…..）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;京东面试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="京东" scheme="https://objcvip.github.io/tags/%E4%BA%AC%E4%B8%9C/"/>
    
  </entry>
  
  <entry>
    <title>滴滴笔试题</title>
    <link href="https://objcvip.github.io/%E6%BB%B4%E6%BB%B4%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/滴滴笔试题/</id>
    <published>2019-09-06T08:11:00.000Z</published>
    <updated>2019-09-06T08:37:57.488Z</updated>
    
    <content type="html"><![CDATA[<p>滴滴笔试题</p><a id="more"></a><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>0.姓名？日期。</p><p>1.C语言实现字符串反转：<code>void reverse(char *str, int length) {}</code></p><p>2.实现一个字符串数组去重函数。</p><p>3.描述OC中对象的实现原理。</p><p>4.编写代码，实现 NSObject 中添加一个属性 p1</p><p>5.KVO 的实现原理和注意事项。</p><p>6.下面的代码有哪些问题？</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@interface Demo : NSObject</span><br><span class="line">@property (nonatomic, assign) BOOL *p1;</span><br><span class="line">@property (nonatomic, strong) NSString *p2;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Demo</span><br><span class="line">@dynamic p1;</span><br><span class="line"></span><br><span class="line">- (void)setP2:(NSString *)p2;</span><br><span class="line">&#123;</span><br><span class="line">self.p1 = YES;</span><br><span class="line">self.p2 = p2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>7.JS 和 Native 的通讯方式。</p><p>8.网络5层模型是哪5层？</p><p>9.把t1表中 name 为 mike 的记录中 status 值改为1</p><p>10.常用的 Linux 命令。</p><p>11.用过的包/库管理工具。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;滴滴笔试题&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="滴滴" scheme="https://objcvip.github.io/tags/%E6%BB%B4%E6%BB%B4/"/>
    
      <category term="笔试题" scheme="https://objcvip.github.io/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>新浪乐居面试题</title>
    <link href="https://objcvip.github.io/%E6%96%B0%E6%B5%AA%E4%B9%90%E5%B1%85%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/新浪乐居面试题/</id>
    <published>2019-09-04T08:12:00.000Z</published>
    <updated>2019-09-04T08:16:49.347Z</updated>
    
    <content type="html"><![CDATA[<p>新浪乐居面试题<br><a id="more"></a></p><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>笔试题</p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、类方法和实例方法有什么区别？</p><p>2、用封装的类方法去请求网络会有什么问题？</p><p>3、说一下单例。单例的作用是什么？为什么不能多次创建对象？</p><p>4、说一下 ARC、MRC，有什么区别？有啥优缺点？</p><p>5、自动释放池的使用场景？耗内存时需要加到池子里。</p><p>6、沙盒目录除了 Documents 还有啥？Cache 和 Temp 有什么区别？</p><p>7、项目里用地图了吗？如果用系统的地图会有一个问题，电量急速下降，遇到过这个问题吗？</p><p>8、都有哪些可能循环引用？</p><p>9、说一下从网络请求回来的数据怎么存？数据持久化的方法。数据库是存在沙盒的哪个目录？我说在 Documents 中。</p><p>10、assign 与 weak 区别？</p><p>11、笔试题19的答案为什么是2、5？</p><p>12、说一下冒泡排序的思路？</p><p>13、GCD 需要注意什么？我说了一下使用场景。</p><p>14、Runtime、Runloop 了解吗？（说了一下消息发送和消息转发的流程）Runloop 有哪些 Mode？（说了3个，面试官说能用的到的就这三个。。其他俩点进去也看不着）说一下 CommonMode ？</p><p>15、最后一个问题：类似简历  右上角是图片（宽高已知） 左边是一段文字  文字会包裹着图片，问实现思路？</p><p>说了三个思路：<br>（1）计算一下上边 label 宽高，左边用一个 label 显示，下边多余的字也用另一个 label 显示。</p><p>（2）YYText 可能有处理办法，算是第三方。</p><p>（3）他提示底层一点的，我说绘制。</p><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>1、了解项目，问在公司干啥。</p><p>2、AutoLayout 和 Masonry 有什么区别？</p><p>3、面向对象在 OC 中的体现？封装、继承、多态。你觉得最主要的是面向对象的哪个特性？</p><p>4、你对 H5、原生交互的看法。我说了实现方式后，他说不要实现细节，就你的看法。我又说了阿里是大前端，他说不要说阿里，你的看法呢？我说活动页用H5，其他用原生，可能效率高。</p><p>5、Block 和 delegate 的使用场景差异？</p><p>6、你觉得开发一个项目难点在哪儿？</p><p>7、其他问题：薪水能商量吗？有什么要问我的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;新浪乐居面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>微店面试题</title>
    <link href="https://objcvip.github.io/%E5%BE%AE%E5%BA%97%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/微店面试题/</id>
    <published>2019-09-04T08:05:00.000Z</published>
    <updated>2019-09-04T08:10:06.680Z</updated>
    
    <content type="html"><![CDATA[<p>微店面试题<br><a id="more"></a></p><h1 id="微店一面"><a href="#微店一面" class="headerlink" title="微店一面"></a>微店一面</h1><p>1、说项目里的有价值的东西？</p><p>2、HTTPS 过程是怎么样的？非对称加密</p><p>3、Swift 中逃逸闭包和非逃逸闭包的区别？</p><p>4、属性用 copy 关键字，是深拷贝还是浅拷贝？深拷贝和浅拷贝的区别？</p><p>5、SDWebImage 的缓存机制？LRU 内部原理？下载完成图片后，是先存到内存、磁盘后，才显示到界面上吗？</p><p>6、AFN 用到了 NSOperation、GCD，说一下内部 Operation 相关的？Manager？</p><p>7、GCD 内部实现？</p><p>8、约束 left/right 和 leading/trailing 的区别？约束报黄怎么解决？</p><p>9、KVO 的原理？具体 NSObject 的两个方法？</p><p>10、消息转发流程？使用场景？</p><p>11、数据库减字段怎么容错？</p><p>12、有没有打包过私有库？</p><p>13、从点击 App 的图标到 App 启动，说一下这个过程？+load 发生在什么时候？</p><p>14、用什么管理第三方库？CocoaPods 中的 .lock 文件存储了什么信息？</p><p>15、说一下一个项目的架构？</p><p>16、组件化？</p><p>17、手写冒泡排序算法？算法复杂度？</p><h1 id="微店二面"><a href="#微店二面" class="headerlink" title="微店二面"></a>微店二面</h1><p>1、项目介绍，开发人员分工？购物车本地化如果加入购物车的价格变了怎么处理的？</p><p>2、写一下其中一个项目的项目架构？写一下用到的第三方库。</p><p>3、项目用什么管理的？CocoaPods 指定版本号带 ~ 跟不带 ~各有什么含义？</p><p>4、AFN 实现原理？发10个网络请求，AFN 内部是怎么处理的？</p><p>5、SDWebImage 是怎么加载图片的？用的是 Get 还是 Post ？如果让你实现，你会选择 Get 还是 Post ？</p><p>6、HTTPS 流程是怎么样的？（画一下客户端、服务器的时序图）</p><p>7、加密算法，对称加密和非对称加密？</p><p>8、如何理解 OC 是动态语言？</p><p>9、Runtime？用 Runtime 做过什么？</p><p>10、Runloop？内部实现原理？跟自己写个 for 循环有没有区别？</p><p>11、内存管理？内存优化？</p><p>12、卡顿？</p><p>13、多线程？用 GCD 实现同步多个异步调用（a，b），然后再同步执行（c，d）</p><p>14、从点击 App 图标，到显示界面流程？</p><p>15、组件化？</p><p>16、编译过程？某一个东西是属于哪一步骤的？</p><p>17、微信支付流程（客户端、微信 SDK 、自己服务器、微信服务器时序图）</p><p>18、RN、Week？内部是怎么用 JS 调用原生的？</p><p>19、日志记录？</p><p>20、遇到的闪退？Bug？</p><p>21、竞争同一个资源？</p><p>22、进程线程与 App 的关系。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;微店面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>好未来面试题</title>
    <link href="https://objcvip.github.io/%E5%A5%BD%E6%9C%AA%E6%9D%A5%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/好未来面试题/</id>
    <published>2019-09-04T07:56:00.000Z</published>
    <updated>2019-09-04T08:01:25.975Z</updated>
    
    <content type="html"><![CDATA[<p>好未来面试题<br><a id="more"></a></p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、说一下optional。（？ ！ ？？ 几种解包方式 if let、guard、？？等）</p><p>2、说一下闭包。</p><p>3、比较代理、通知、KVO？这三个谁的效率最高，谁的效率最低？( KVO 效率最低，因为 Runtime ）</p><p>4、NSString 和 String 的区别？（ String 是值类型，NSString 是引用类型）</p><p>5、Swift 跟 OC 的区别？（ OC 是动态的语言，Swift 是静态的语言）OC 是面向对象的，Swift 呢？（面向对象、面向协议、响应式编程）解释一下面向协议编程？</p><p>6、说一下 MRC ？自动释放池？自动释放池什么时候释放？（我说 drain ）</p><p>7、说一下多线程？（我提到了 dispatch_once 单例）</p><p>8、分别用 OC 和 Swift 手写一下单例。（ Swift 的单例我忘记写 static 了，但是经提醒立马说出来了）</p><p>9、SnaptKit 内部看过吗？</p><p>10、链式语法的实现。</p><p>UIView.top.equalTo().offSet(10)</p><p>UIView.left.equalTo().offSet(10)</p><p>为什么能写成UIView.top.left.offSet(10)</p><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><p>主要是手写算法题：</p><p>1、用两个栈实现队列。</p><p>2、从扑克牌中抽出5张，写一个方法判断是不是顺子。（如34567）大小王是万能的，可以替代任意数字。</p><h1 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h1><p>项目经理</p><h1 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h1><p>HR</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;好未来面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>高思教育面试题</title>
    <link href="https://objcvip.github.io/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/高思教育面试题/</id>
    <published>2019-09-04T07:39:00.000Z</published>
    <updated>2019-09-06T08:36:19.087Z</updated>
    
    <content type="html"><![CDATA[<p>高思教育面试题<br><a id="more"></a></p><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>笔试题</p><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><p>1、@property 本质是什么？NSString 为什么用 Copy，用 Strong 行不行？</p><p>2、block 为什么用 copy ？</p><p>3、block 和代理你用的哪个多？各有什么特点？</p><p>4、GCD 的两个队列（串行、并行）有了解吗？从字面意思看，你觉得这俩哪个效率高，哪个（占空间）忘记了问的啥指标了。。</p><p>5、（说一下你的项目吧）看到我的酒店 App，问类似网易新闻那种滑动切换页面你是怎么做的？我说是一个 scrollView，点击按钮后滚动到指定的 index。他说的顶部按钮是3个，如果是30个呢，会有什么问题？他说如果1个页面占用5M，30个页面就占用5x30M，会有内存问题，怎么解决这个问题？我说看过别人写的，用的是子控制器，把这些页面加到当前控制器的子控制器中。（现在想想我也是这么做的。。但是没说是这么做）</p><p>6、AFN内部看过吗？AFN的5个模块。</p><p>大概这时候问，你觉得自己是什么级别的？（中级）</p><p>7、说一下响应者链。</p><p>8、一个约束题。</p><p>9、项目不忙的时候做过什么优化？（我说用 Instruments 分析过内存泄漏）他说发现过什么问题？（发现过 NSTimer 定时器有内存泄漏）他说那考虑用什么替换定时器呢？（我说没有替换它，退出这个页面的时候关掉了 Timer）</p><p>还做过什么优化？（忘记咋回答了）</p><p>10、（不知道问啥我的回答是野指针）然后就问野指针是啥？指针指向的那块地址（忘记了。。）如果又有其他指针指向了这块内存，会怎么样（他好像说会闪退）</p><p>12、斐波那切数列</p><p>0 1 2 3 4 5…</p><p>1 1 2 3 5 8 13 21  求n  f(n) = f(n-1) + f(n-2)</p><h1 id="复试"><a href="#复试" class="headerlink" title="复试"></a>复试</h1><p>1、怎么学的 iOS ？为什么没搞 Java </p><p>2、介绍公司情况，人员规模，介绍项目</p><p>3、说一下项目中遇到的问题，怎么解决的？</p><p>4、说一下内存管理，怎么检测内存泄漏的？</p><p>5、你用 OC 开发还是 Swift ？你觉得两者有啥不同？</p><p>6、金融 App 应该有一些安全措施吧？你们是怎么做的？</p><p>7、TCP 和 UDP 有啥区别？</p><p>8、TCP 几次握手？过程是怎么样的？</p><p>9、Post 请求和 Get 请求有啥区别？</p><p>10、数据持久化都有哪些？</p><p>11、AFN 的实现原理？SDWebImage 的实现原理？哪些存在内存，哪些存在磁盘？</p><p>12、两个网络请求有依赖关系时，怎么处理的？</p><p>13、同步、异步  串行、并行</p><p>14、几张图合成一张图</p><p>15、说一下 Runloop</p><p>16、KVO 的实现原理</p><p>17、不使用中间变量 实现交换两个数 swap(a, b)</p><p>18、copy 关键字修饰什么？</p><p>19、类的私有属性，怎么设置属性值？我答了 KVC  他提到了 Runtime</p><p>20、有没有做过音频的处理？类似唱吧把原唱关掉。</p><p>21、动画了解的怎么样？</p><p>22、了解 ARKit 吗？</p><p>23、数据结构和算法你怎么样？冒泡排序，选择排序？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高思教育面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="高思教育" scheme="https://objcvip.github.io/tags/%E9%AB%98%E6%80%9D%E6%95%99%E8%82%B2/"/>
    
  </entry>
  
  <entry>
    <title>滴滴面试题</title>
    <link href="https://objcvip.github.io/%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://objcvip.github.io/滴滴面试题/</id>
    <published>2019-09-04T07:27:00.000Z</published>
    <updated>2019-09-04T08:02:21.795Z</updated>
    
    <content type="html"><![CDATA[<p>滴滴面试题<br><a id="more"></a></p><h1 id="笔试题"><a href="#笔试题" class="headerlink" title="笔试题"></a>笔试题</h1><p>笔试题</p><h1 id="滴滴一面"><a href="#滴滴一面" class="headerlink" title="滴滴一面"></a>滴滴一面</h1><p>看了一下笔试题的答案，第一题 C 语言字符串反转打印了一下</p><p>1、说一下你觉得项目中遇到了什么印象深刻的问题，你是怎么解决的？</p><p>2、大学里学了哪些课？信息管理与信息系统专业是哪个学院的？</p><p>3、项目里的网络请求用到了网络5层模型的哪些，TCP/IP 属于哪一层？HTTP 呢？</p><p>4、你觉得自己是什么级别的？优势和不足主要是哪方面？</p><p>5、GCD 平时项目里怎么用的？我提到了回到主线程操作 UI 需要 dispatch_get_mainQueue</p><p>6、为什么操作 UI 需要在主线程？</p><p>7、哪些是你独立开发的项目？</p><p>8、问了一下上家公司的情况</p><p>9、之后有什么打算？</p><p>10、上家薪资多少？你还有啥想问的吗？</p><h1 id="滴滴二面"><a href="#滴滴二面" class="headerlink" title="滴滴二面"></a>滴滴二面</h1><p>1、自定义封装控件需要注意什么？有什么规范？</p><p>2、说一下你了解的设计模式。</p><p>3、数据库怎么优化？我说数据量大的话加索引提升查询效率。问其他优化呢？比如数据库大小有没有做过优化？</p><p>4、内存优化是怎么做的？我提到了内存泄漏。什么情况会发生内存泄漏？</p><p>5、App 启动时间优化？</p><p>6、视图做过哪些优化，我提了 TableView。那就以 TableView 说一下优化了哪些方面？</p><p>7、AFNetworking 内部是怎么样的一个过程？</p><p>8、你还有什么想问我的？</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;滴滴面试题&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>面试题讨论（2019.09.03）</title>
    <link href="https://objcvip.github.io/%E9%9D%A2%E8%AF%95%E9%A2%98%E8%AE%A8%E8%AE%BA9.3/"/>
    <id>https://objcvip.github.io/面试题讨论9.3/</id>
    <published>2019-09-03T07:47:00.000Z</published>
    <updated>2019-09-06T08:52:00.543Z</updated>
    
    <content type="html"><![CDATA[<p>面试题讨论9.3</p><a id="more"></a><ol><li>函数和方法的区别。</li><li>地铁离线二维码的实现。</li><li>固定的宽度，如何展示较长的文本。</li><li>消息发送，转发流程，Runtime 交换方法的应用。</li><li>线程间的通信。</li><li>主线程使用同步方法插入同步线程造成阻塞。</li><li>同步、异步与串行、并行  异步与并行的区别。</li><li>怎么理解OC面向对象中的封装？</li><li>NSInterger 占多少个字节。</li><li>self = [super init] 为什么要写 [super init]。</li><li>Block 有几种？</li><li>深拷贝与浅拷贝 NSArray 是深拷贝还是浅拷贝？NSMutableArray 是深拷贝还是浅拷贝？</li><li>[self class] 与 [super class]。</li><li>tableView 的优化，离屏渲染。</li><li>tableView 的复用机制  屏幕上有6个 cell  复用池里有几个 cell 。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;面试题讨论9.3&lt;/p&gt;
    
    </summary>
    
      <category term="面试题" scheme="https://objcvip.github.io/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="https://objcvip.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>【iOS 开发】使用环信实现聊天遇到的一些坑</title>
    <link href="https://objcvip.github.io/imeasemob/"/>
    <id>https://objcvip.github.io/imeasemob/</id>
    <published>2019-08-26T07:47:00.000Z</published>
    <updated>2019-08-27T05:20:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。<br><a id="more"></a></p><h2 id="问题1-聊天页面环信工具栏向上偏移"><a href="#问题1-聊天页面环信工具栏向上偏移" class="headerlink" title="问题1 聊天页面环信工具栏向上偏移"></a>问题1 聊天页面环信工具栏向上偏移</h2><h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h3><p>在聊天页面，点击输入框弹起键盘，点击<code>IQKeyboardManager</code>带的完成按钮或者点击空白页面收起键盘，反复操作多次后，会出现页面向上偏移，环信<code>UI</code>的工具栏移动到了页面最上边。</p><h3 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在聊天页面禁用<code>IQKeyboardManager</code>。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewDidAppear:animated];</span><br><span class="line">    IQKeyboardManager *keyboardManager =  [IQKeyboardManager sharedManager];</span><br><span class="line">    keyboardManager.enable = NO;</span><br><span class="line">    keyboardManager.enableAutoToolbar = NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">    [super viewWillDisappear:animated];</span><br><span class="line">    IQKeyboardManager *keyboardManager =  [IQKeyboardManager sharedManager];</span><br><span class="line">    keyboardManager.enable = YES;</span><br><span class="line">    keyboardManager.enableAutoToolbar = YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题2-保存环信昵称头像到数据库失败"><a href="#问题2-保存环信昵称头像到数据库失败" class="headerlink" title="问题2 保存环信昵称头像到数据库失败"></a>问题2 保存环信昵称头像到数据库失败</h2><h3 id="问题描述：-1"><a href="#问题描述：-1" class="headerlink" title="问题描述："></a>问题描述：</h3><p>环信服务器不存储用户的昵称头像等用户数据。需要客户端自己来存储并展示在界面上。有几个时机是需要插入或更新一条包含昵称、头像的用户数据到数据库里，比如查看用户详情，在某个页面收到环信消息。我们服务器提供的查询用户信息接口返回的昵称和头像，之前是没有问题的，有一次出现了从用户信息界面进入聊天页面不显示昵称的问题。</p><h3 id="问题原因："><a href="#问题原因：" class="headerlink" title="问题原因："></a>问题原因：</h3><p>经排查，接口返回的用户头像字段的值是<code>null</code>，由于客户端之前没有做空处理，导致插入或更新一条数据失败。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DB Query: INSERT or REPLACE INTO t_huanxin (hxId,nickname,avatar) VALUES (?,?,?)</span><br><span class="line">Unknown error finalizing or resetting statement (19: NOT NULL constraint failed: t_huanxin.avatar)</span><br></pre></td></tr></table></figure></p><h3 id="解决方案：-1"><a href="#解决方案：-1" class="headerlink" title="解决方案："></a>解决方案：</h3><p>存储用户信息到本地数据库时增加安全判断。如果为空，就存入空字符串。避免插入或更新字段为<code>null</code>导致操作失败。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NSString *nickname = dic[@&quot;nickname&quot;]?:@&quot;&quot;;</span><br><span class="line">NSString *avatar = dic[@&quot;avatar&quot;]?:@&quot;&quot;;</span><br></pre></td></tr></table></figure></p><h2 id="问题3-聊天页面发送首条消息后下拉刷新出现两条重复消息"><a href="#问题3-聊天页面发送首条消息后下拉刷新出现两条重复消息" class="headerlink" title="问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息"></a>问题3 聊天页面发送首条消息后下拉刷新出现两条重复消息</h2><h3 id="问题描述：-2"><a href="#问题描述：-2" class="headerlink" title="问题描述："></a>问题描述：</h3><p>使用环信<code>Demo</code>发送消息，首条消息发送后，下拉刷新，单聊页面会有两条重复的消息。<br>操作步骤：1.点击单聊页面右上角的清空按钮，清空某个用户的消息。2.返回会话列表。3.首次进入该用户的单聊页面。4.发送首条消息。5.页面下拉刷新。6.出现了两条一摸一样的消息。</p><h3 id="解决方案：-2"><a href="#解决方案：-2" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMChatViewController</code>的<code>tableViewDidTriggerHeaderRefresh</code>方法中增加如下判断。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableViewDidTriggerHeaderRefresh</span><br><span class="line">&#123;</span><br><span class="line">    //解决首条消息发送后下拉刷新出现两条重复消息的BUG 开始</span><br><span class="line">    if (self.dataArray.count &amp;&amp; self.moreMsgId == nil) &#123;</span><br><span class="line">        [self tableViewDidFinishTriggerHeader:YES reload:NO];</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    //解决首条消息发送后下拉刷新出现两条重复消息的BUG 结束</span><br><span class="line">    other code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题4-聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录"><a href="#问题4-聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录" class="headerlink" title="问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录"></a>问题4 聊天页面发送语音，点击“按住录音”，发送了0秒的聊天记录</h2><h3 id="问题描述：-3"><a href="#问题描述：-3" class="headerlink" title="问题描述："></a>问题描述：</h3><p><code>iOS</code>环信<code>Demo</code>聊天页面，发送语音，点击“按住录音”，发送了0秒的聊天记录。</p><h3 id="解决方案：-3"><a href="#解决方案：-3" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMChatViewController</code>的<code>chatBarRecordAudioViewStopRecord:timeLength:</code>方法中增加对录音时长的判断。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)chatBarRecordAudioViewStopRecord:(NSString *)aPath</span><br><span class="line">                              timeLength:(NSInteger)aTimeLength</span><br><span class="line">&#123;</span><br><span class="line">    EMVoiceMessageBody *body = [[EMVoiceMessageBody alloc] initWithLocalPath:aPath displayName:@&quot;audio&quot;];</span><br><span class="line">    body.duration = (int)aTimeLength;</span><br><span class="line">    if (body.duration == 0) &#123;</span><br><span class="line">        NSLog(@&quot;录音时长为0&quot;);</span><br><span class="line">        NSLog(@&quot;录制时间过短，不能发送&quot;);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    [self _sendMessageWithBody:body ext:nil isUpload:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="问题5-聊天页面点击查看图片，图片右上角按钮显示Done"><a href="#问题5-聊天页面点击查看图片，图片右上角按钮显示Done" class="headerlink" title="问题5 聊天页面点击查看图片，图片右上角按钮显示Done"></a>问题5 聊天页面点击查看图片，图片右上角按钮显示<code>Done</code></h2><h3 id="问题描述：-4"><a href="#问题描述：-4" class="headerlink" title="问题描述："></a>问题描述：</h3><p>聊天页面，点击查看图片，图片右上角的按钮显示<code>Done</code>，而不是”完成“。</p><h3 id="解决方案：-4"><a href="#解决方案：-4" class="headerlink" title="解决方案："></a>解决方案：</h3><p>直接全局搜索<code>Done</code>,把环信<code>UI</code>里的<code>Done</code>,替换成”完成“即可。</p><h2 id="问题6-如何实现推送消息内容自定义"><a href="#问题6-如何实现推送消息内容自定义" class="headerlink" title="问题6 如何实现推送消息内容自定义"></a>问题6 如何实现推送消息内容自定义</h2><h3 id="问题描述：-5"><a href="#问题描述：-5" class="headerlink" title="问题描述："></a>问题描述：</h3><p>不想使用环信默认的推送内容：”您有一条新消息”，或”xxx：消息内容”。想实现自定义的消息内容。</p><h3 id="解决方案：-5"><a href="#解决方案：-5" class="headerlink" title="解决方案："></a>解决方案：</h3><p>发送消息扩展里添加字段<code>em_apns_ext</code><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">nickname:&quot;王小二&quot;,</span><br><span class="line">avatar:&quot;http://www.baidu.com&quot;,</span><br><span class="line">em_apns_ext:&#123;&quot;em_push_content&quot;:&quot;自定义推送内容&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考链接：<a href="http://docs-im.easemob.com/im/ios/apns/content" target="_blank" rel="noopener">环信 APNs 内容解析文档</a></p><h2 id="问题7-头像链接与路由短链冲突"><a href="#问题7-头像链接与路由短链冲突" class="headerlink" title="问题7 头像链接与路由短链冲突"></a>问题7 头像链接与路由短链冲突</h2><h3 id="问题描述：-6"><a href="#问题描述：-6" class="headerlink" title="问题描述："></a>问题描述：</h3><p>项目里点击推送通知到落地页采用了路由模式，有一个场景是需要我们自己服务器发推送点击通知栏跳转到聊天页面。路由短链类似：<code>page://chat?from=hxId_10086</code>,由于某些原因，需要带上昵称和头像，加上头像链接后，短链变成了<code>page://chat?from=hxId_10086&amp;avatar=http://www.baidu.com&amp;nickname=王小二</code>，<code>iOS</code> 解析短链的方法是先把短链字符串转成了<code>URL</code>，加了<code>avatar</code>参数之后，转换失败，导致无法跳转。</p><h3 id="解决方案：-6"><a href="#解决方案：-6" class="headerlink" title="解决方案："></a>解决方案：</h3><ul><li>方案1：<br>由于短链中含有<code>URL</code>，其实违反了路由链接设计的初衷，可以把<code>avatar</code>的值用<code>AES</code>加密一下传输，避免出现链接。</li><li>方案2：<br>不把短链字符串转换成<code>URL</code>，直接处理短链，去解析。</li></ul><h2 id="问题8-小程序发的语音消息iOS无法播放"><a href="#问题8-小程序发的语音消息iOS无法播放" class="headerlink" title="问题8 小程序发的语音消息iOS无法播放"></a>问题8 小程序发的语音消息<code>iOS</code>无法播放</h2><h3 id="问题描述：-7"><a href="#问题描述：-7" class="headerlink" title="问题描述："></a>问题描述：</h3><p>小程序发过来的语音消息<code>iOS</code>无法播放。</p><h3 id="问题原因：-1"><a href="#问题原因：-1" class="headerlink" title="问题原因："></a>问题原因：</h3><p><code>Android</code>和<code>iOS</code>发的语音格式都是<code>AMR</code>，小程序发的语音格式是<code>MP3</code>，<code>iOS</code>收到音频后，会先调用<code>_convertAudioFile:</code>方法转换格式，该方法内部实现实现里有一行代码是判断路径是否是<code>MP3</code>文件的，<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[EMAudioPlayerHelper isMP3File:retPath]</span><br></pre></td></tr></table></figure></p><p>这个判断方法有问题，发过来的是<code>MP3</code>，却判断不是<code>MP3</code>，接着音频被当成<code>AMR</code>去转换<code>WAV</code> ，转换音频格式失败，播放失败。</p><h3 id="解决方案：-7"><a href="#解决方案：-7" class="headerlink" title="解决方案："></a>解决方案：</h3><p>在<code>EMAudioPlayerHelper</code>类中的<code>startPlayerWithPath:model:completion:</code>方法中增加判断，如果含有<code>.mp3</code>，就不转换，直接去播放。不含<code>.mp3</code>，就照旧走<code>_convertAudioFile:</code>转换格式方法。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if ([aPath containsString:@&quot;.mp3&quot;]) &#123;</span><br><span class="line">   //不转换</span><br><span class="line">&#125;else &#123;</span><br><span class="line">   aPath = [self _convertAudioFile:aPath];</span><br><span class="line">&#125;</span><br><span class="line">// aPath = [self _convertAudioFile:aPath];</span><br></pre></td></tr></table></figure></p><h3 id="问题扩展："><a href="#问题扩展：" class="headerlink" title="问题扩展："></a>问题扩展：</h3><p><code>iOS</code>发的语音消息，<code>Web</code>/小程序收到后无法播放？<br><code>App</code>端发来的文件是<code>AMR</code>格式的，小程序需要下载的时候转成<code>MP3</code>格式去播放。转换方法如下：<br>参考链接：<a href="http://docs-im.easemob.com/im/web/basics/message#%E9%9F%B3%E9%A2%91%E6%B6%88%E6%81%AF" target="_blank" rel="noopener">环信 Web IM 音频消息文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用环信实现聊天的过程遇到了一些坑，记录一下避免自己和其他人踩坑或者尽快出坑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS 开发" scheme="https://objcvip.github.io/categories/iOS-%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="iOS 开发" scheme="https://objcvip.github.io/tags/iOS-%E5%BC%80%E5%8F%91/"/>
    
      <category term="环信" scheme="https://objcvip.github.io/tags/%E7%8E%AF%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》二</title>
    <link href="https://objcvip.github.io/DataStructurePart2/"/>
    <id>https://objcvip.github.io/DataStructurePart2/</id>
    <published>2019-05-29T09:46:00.000Z</published>
    <updated>2019-09-04T06:58:25.653Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第3章-线性表"><a href="#第3章-线性表" class="headerlink" title="第3章 线性表"></a>第3章 线性表</h1><p>线性表：零个或多个数据元素的有限序列。</p><a id="more"></a><h2 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h2><blockquote><p>线性表(List):零个或多个数据元素的有限序列。</p></blockquote><p>线性表元素的个数 n (n&gt;=0) 定义为线性表的长度，当 n = 0时，称为空表。</p><h2 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h2><p>ADT 线性表(List)<br>Data<br>​    线性表的数据对象集合为{a<sub>1</sub>,a<sub>2</sub>,……,a<sub>n</sub>},每个元素的类型均为DataType。其中，除第一个元素a<sub>1</sub>外，每一个元素有且只有一个直接前驱元素，除了最后一个元素a<sub>n</sub>外，每一个元素有且只有一个直接后继元素。数据元素之间的关系是一对一的关系。</p><p>Operation</p><p>​    InitList (*L):初始化操作，建立一个空的线性表L。</p><p>​    ListEmpty(L)：若线性表为空，返回true，否则返回false。</p><p>​    ClearList(*L)：将线性表清空。</p><p>​    GetElem(L,i,*e)：在线性表L中的第i个位置元素值返回给e。</p><p>​    LocateElem(L,e)：在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败。</p><p>​    ListInsert(*L,i,e)：在线性表L中的第i个位置插入新元素e。</p><p>​    ListDelete(<em>L,i, </em>e)：删除线性表L中的第i个位置元素，并用e返回其值。</p><p>​    ListLength(L)：返回线性表L的元素个数。</p><p>endADT</p><h2 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的顺序存储结构</h2><h3 id="顺序存储定义"><a href="#顺序存储定义" class="headerlink" title="顺序存储定义"></a>顺序存储定义</h3><blockquote><p>线性表的顺序存储结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。</p></blockquote><h3 id="顺序存储方式"><a href="#顺序存储方式" class="headerlink" title="顺序存储方式"></a>顺序存储方式</h3><p>一维数组来实现顺序存储结构。</p><h3 id="数组长度与线性表长度区别"><a href="#数组长度与线性表长度区别" class="headerlink" title="数组长度与线性表长度区别"></a>数组长度与线性表长度区别</h3><p>数组的长度是存放线性表的存储空间的长度。线性表的长度是线性表中数据元素的个数。在任意时刻，线性表的长度应该小于等于数组的长度。</p><h3 id="地址计算方法"><a href="#地址计算方法" class="headerlink" title="地址计算方法"></a>地址计算方法</h3><p>存储器中每个存储单元都有自己的编号，这个编号称为地址。</p><p>LOC(a<sub>i</sub>) = LOC(a<sub>1</sub>) + (i-1)*c</p><p>存取的时间性能为O(1)。</p><h2 id="顺序存储结构的插入与删除"><a href="#顺序存储结构的插入与删除" class="headerlink" title="顺序存储结构的插入与删除"></a>顺序存储结构的插入与删除</h2><h3 id="获得元素操作"><a href="#获得元素操作" class="headerlink" title="获得元素操作"></a>获得元素操作</h3><p>只要i的数值在数组的下标范围内，就是把数组的第i-1下标的值返回即可。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>插入算法的思路：</p><ul><li>如果插入位置不合理，抛出异常；</li><li>如果线性表的长度大于等于数组长度，则抛出异常或动态增加容量；</li><li>从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；</li><li>将要插入元素填入位置i处；</li><li>表长加1。</li></ul><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除算法的思路：</p><ul><li>如果删除位置不合理，抛出异常；</li><li>取出删除元素；</li><li>从删除元素位置开始遍历到最后一个元素位置，分别将它们都向前移动一个位置；</li><li>表长减1。</li></ul><p>插入和删除的时间复杂度，最好情况为O(1)，最坏情况为O(n)，平均时间复杂度为O(n)。</p><h3 id="线性表顺序存储结构的优缺点"><a href="#线性表顺序存储结构的优缺点" class="headerlink" title="线性表顺序存储结构的优缺点"></a>线性表顺序存储结构的优缺点</h3><p>优点：</p><ul><li>无须为表示表中元素之间的逻辑关系而增加额外的存储空间。</li><li>可以快速地存取表中任一位置的元素。</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量元素。</li><li>当线性表长度变化较大时，难以确定存储空间的容量。</li><li>造成存储空间的”碎片”。</li></ul><h2 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的链式存储结构</h2><h3 id="线性表链式存储结构定义"><a href="#线性表链式存储结构定义" class="headerlink" title="线性表链式存储结构定义"></a>线性表链式存储结构定义</h3><p>​    为了表示每个数据元素a<sub>i</sub>与其直接后继数据元素a<sub>i+1</sub>之间的逻辑关系，对数据元素a<sub>i</sub>来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。我们把存储数据元素信息的域称为数据域，把存储直接后继位置的域称为指针域。指针域中存储的信息称作指针或链。这两部分信息组成数据元素a<sub>i</sub>的存储映像，称为结点(Node)。</p><p>​    n个结点(a<sub>i</sub>的存储映像)链结成一个链表，即为线性表(a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>)的链式存储结构，因为此链表的每个结点中只包含一个指针域，所以叫做单链表。</p><p>​    链表中的第一个结点的存储位置叫做头指针。在单链表的第一个结点前附设一个结点，称为头结点。头结点的指针域存储指向第一个结点的指针。</p><h3 id="线性表链式存储结构代码描述"><a href="#线性表链式存储结构代码描述" class="headerlink" title="线性表链式存储结构代码描述"></a>线性表链式存储结构代码描述</h3><p>单链表中，我们在C语言中可用结构指针来描述。</p><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/*线性表的单链表存储结构*/</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  ElemType data;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125; Node;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Node</span> *<span class="hljs-title">LinkList</span>;</span> <span class="hljs-comment">/*定义LinkList*/</span></span><br></pre></td></tr></table></figure><h3 id="单链表的读取"><a href="#单链表的读取" class="headerlink" title="单链表的读取"></a>单链表的读取</h3><p>获取链表第i个数据的算法思路：</p><ol><li>声明一个指针p指向链表的第一个结点，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，返回结点p的数据。</li></ol><h3 id="单链表的插入与删除"><a href="#单链表的插入与删除" class="headerlink" title="单链表的插入与删除"></a>单链表的插入与删除</h3><h3 id="单链表的插入"><a href="#单链表的插入" class="headerlink" title="单链表的插入"></a>单链表的插入</h3><p>单链表第i个数据插入结点的算法思路：</p><ol><li>声明一指针p指向链表头结点，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，在系统中生成一个空节点s；</li><li>将数据元素e赋值给s-&gt;data;</li><li>单链表的插入标准语句s-&gt;next = p-&gt;next; p-&gt;next = s;</li><li>返回成功。</li></ol><h3 id="单链表的删除"><a href="#单链表的删除" class="headerlink" title="单链表的删除"></a>单链表的删除</h3><p>单链表第i个数据删除结点的算法思路：</p><ol><li>声明一指针p指向链表头指针，初始化j从1开始；</li><li>当j&lt;i时，就遍历链表，让p的指针向后移动，不断指向下一个结点，j累加1；</li><li>若到链表末尾p为空，则说明第i个结点不存在；</li><li>否则查找成功，将欲删除的结点p-&gt;next赋值给q；</li><li>单链表的删除标准语句p-&gt;next = q-&gt;next;</li><li>将q结点中的数据赋值给e，作为返回；</li><li>释放q结点。</li><li>返回成功。</li></ol><h2 id="单链表的整表创建"><a href="#单链表的整表创建" class="headerlink" title="单链表的整表创建"></a>单链表的整表创建</h2><p>头插法</p><p>尾插法</p><h2 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h2><p>单链表整表删除的算法思路如下：</p><ol><li>声明一节点p和q；</li><li>将第一个结点赋值给p；</li><li>循环：<ul><li>将下一个结点赋值给q；</li><li>释放p；</li><li>将q赋值给p。</li></ul></li></ol><h2 id="单链表结构与顺序存储结构优缺点"><a href="#单链表结构与顺序存储结构优缺点" class="headerlink" title="单链表结构与顺序存储结构优缺点"></a>单链表结构与顺序存储结构优缺点</h2><p>存储分配方式</p><ul><li>顺序存储结构用一段连续的存储单元依次存储线性表的数据元素。</li><li>单链表采用链式存储结构，用一组任意的存储单元存放线性表中的元素。</li></ul><p>时间性能</p><ul><li>查找 顺序存储结构O(1) 单链表O(n)</li><li>插入和删除 顺序存储结构需要平均移动表长一半的元素，时间为O(n) 单链表在显出某位置的指针后，插入和删除时间仅为O(1)</li></ul><p>空间性能</p><ul><li>顺序存储结构需要预分配存储空间，分大了，浪费，分小了易发生上溢。</li><li>单链表不需要分配存储空间，只要有就可以分配，元素个数也不受限制。</li></ul><h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>用数组描述的链表叫做静态链表，这种描述方法还有起名叫做游标实现法。</p><p>静态链表优缺点</p><p>优点：在插入和删除操作时，只需要修改游标，不需要移动元素，从而改进了顺序存储结构中的插入和删除操作需要移动大量元素的缺点。</p><p>缺点：</p><ul><li>没有解决连续存储分配带来的表长难以确定的问题。</li><li>失去了顺序存储结构随机性存取的特性。</li></ul><h2 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h2><p>将单链表中终端节点的指针端由空指针改为指向头结点，就使整个单链表形成一个环，这种头尾相接的单链表称为单循环链表，简称循环链表(circular linked list)。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p>双向链表(double linked list)是在单链表的每个结点中，再设置一个指向其前驱结点的指针域。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第3章-线性表&quot;&gt;&lt;a href=&quot;#第3章-线性表&quot; class=&quot;headerlink&quot; title=&quot;第3章 线性表&quot;&gt;&lt;/a&gt;第3章 线性表&lt;/h1&gt;&lt;p&gt;线性表：零个或多个数据元素的有限序列。&lt;/p&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="https://objcvip.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="https://objcvip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>《大话数据结构》一</title>
    <link href="https://objcvip.github.io/DataStructurePart1/"/>
    <id>https://objcvip.github.io/DataStructurePart1/</id>
    <published>2019-03-05T15:41:00.000Z</published>
    <updated>2019-09-04T06:58:05.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-数据结构绪论"><a href="#第1章-数据结构绪论" class="headerlink" title="第1章 数据结构绪论"></a>第1章 数据结构绪论</h1><a id="more"></a><ul><li>数据：是描述客观事物的符号，是计算机中可以操作的对象，是能被计算机识别，并输入给计算机处理的符号集合。</li><li>数据元素： 是组成数据的、有一定意义的基本单位，在计算机中通常作为整体处理。也被称为记录。</li><li>数据项：一个数据元素可以由若干个数据项组成。数据项是数据不可分割的最小单位。</li><li>数据对象：是性质相同的数据元素的集合，是数据的子集。</li><li>数据结构：是相互之间存在一种或多种特定关系的数据元素的集合。</li></ul><h2 id="逻辑结构与物理结构"><a href="#逻辑结构与物理结构" class="headerlink" title="逻辑结构与物理结构"></a>逻辑结构与物理结构</h2><h4 id="1-逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种："><a href="#1-逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种：" class="headerlink" title="1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种："></a>1. 逻辑结构：是指数据对象中数据元素之间的相互关系。分为以下4种：</h4><ul><li>集合机构</li><li>线性结构</li><li>树形结构</li><li>图形结构</li></ul><h4 id="2-物理结构：是指数据的逻辑结构在计算机中的存储形式。"><a href="#2-物理结构：是指数据的逻辑结构在计算机中的存储形式。" class="headerlink" title="2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。"></a>2. 物理结构：是指数据的逻辑结构在计算机中的存储形式。</h4><ul><li>顺序存储结构：是把数据元素放在地址连续的存储单元里，其数据间的逻辑关系和物理关系是一致的。</li><li>链式存储结构：是把数据元素存放在任意的存储单元里，这组单元可以是连续的，也可以是不连续的。</li></ul><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>数据类型：是指一组性质相同的值得集合及定义在此集合上的一些操作的总称。<br>C语言中，按照取值的不同，可以分为两类：</p><ul><li>原子类型：是不可以再分解的基本类型，包括整型、实型、字符型等。</li><li>结构类型：由若干个类型组合而成，是可以再分解的。例如，整型数组是由若干整型数组组成的。</li></ul><p>抽象数据类型（Abstract Data Type, ADT）：是指一个数学模型及定义在该模型上的一组操作。</p><h1 id="第2章-算法"><a href="#第2章-算法" class="headerlink" title="第2章 算法"></a>第2章 算法</h1><p>算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。</p><h2 id="算法的特性"><a href="#算法的特性" class="headerlink" title="算法的特性"></a>算法的特性</h2><ol><li>输入输出</li><li>有穷性</li><li>确定性</li><li>可行性</li></ol><h2 id="算法设计的要求"><a href="#算法设计的要求" class="headerlink" title="算法设计的要求"></a>算法设计的要求</h2><ol><li>正确性</li><li>可读性</li><li>健壮性</li><li>时间效率高和存储量低</li></ol><h2 id="算法效率的度量方法"><a href="#算法效率的度量方法" class="headerlink" title="算法效率的度量方法"></a>算法效率的度量方法</h2><ol><li>事后统计方法（不科学、不准确）</li><li>事前分析估算方法</li></ol><h2 id="函数的渐近式增长"><a href="#函数的渐近式增长" class="headerlink" title="函数的渐近式增长"></a>函数的渐近式增长</h2><p>函数的渐近增长：给定两个函数 f(n) 和 g(n), 如果存在一个整数N，使得对于所有的 n &gt; N, f(n) 总是比 g(n) 大，那么，我们说 f(n) 的增长渐近快于 g(n)。</p><h2 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h2><p>在进行算法分析时，语句总的执行次数 T(n) 是关于问题规模 n 的函数，进而分析 T(n) 随 n 的变化情况并确定 T(n) 的数量级。算法的时间复杂度，也就是算法的时间度量，记作：T(n) = O(f(n))。它表示随问题规模 n 的增大，算法执行时间的增长率和 f(n) 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。其中 f(n) 是问题规模 n 的某个函数。</p><h2 id="推导大-O-阶方法"><a href="#推导大-O-阶方法" class="headerlink" title="推导大 O 阶方法"></a>推导大 O 阶方法</h2><ol><li>用常数 1 取代运行时间中的所有加法常数。</li><li>在修改后的运行次数函数中，只保留最高阶项。</li><li>如果最高阶存在且不是 1，则去除与这个项相乘的常数。<br>得到的结果就是大 O 阶。</li></ol><h2 id="常见的时间复杂度"><a href="#常见的时间复杂度" class="headerlink" title="常见的时间复杂度"></a>常见的时间复杂度</h2><p>O(1) &lt; O(logn) &lt; O(n) &lt; O(nlogn) &lt; O(n^2) &lt; O(n^3) &lt; O(2^n) &lt; O(n!) &lt; O(n^n)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第1章-数据结构绪论&quot;&gt;&lt;a href=&quot;#第1章-数据结构绪论&quot; class=&quot;headerlink&quot; title=&quot;第1章 数据结构绪论&quot;&gt;&lt;/a&gt;第1章 数据结构绪论&lt;/h1&gt;
    
    </summary>
    
      <category term="《大话数据结构》" scheme="https://objcvip.github.io/categories/%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B/"/>
    
    
      <category term="学习笔记" scheme="https://objcvip.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>iOS 代码规范</title>
    <link href="https://objcvip.github.io/CodingGuidelines/"/>
    <id>https://objcvip.github.io/CodingGuidelines/</id>
    <published>2019-03-04T16:00:00.000Z</published>
    <updated>2019-09-04T05:59:56.028Z</updated>
    
    <content type="html"><![CDATA[<p>iOS 开发的代码规范。<br><a id="more"></a><br>原文链接：<a href="https://juejin.im/post/5c7c7e0cf265da2ddb298123" target="_blank" rel="noopener">有了这些你们团队的代码肯定规范</a></p><h1 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h1><ol><li>长的、描述性的方法和变量命名是好的命名方式。不要使用简写，除非是一些大家都知道的场景比如 VIP。不要使用 bgView，推荐使用 backgroundView。</li><li>见名知意。含义清楚，做好不加注释代码自我表述能力强。（前提是代码足够规范）</li><li>不要过分追求技巧，降低代码可读性。</li><li>删除没必要的代码。比如我们新建一个控制器，里面会有一些不会用到的代码，或者注释起来的代码，如果这些代码不需要，那就删除它，留着偷懒吗？下次需要自己手写。</li><li>在方法内部不要重复计算某个值，适当的情况下可以将计算结果缓存起来。</li><li>尽量减少单例的使用。</li><li>提供一个统一的数据管理入口，不管是 MVC、MVVM、MVP 模块内提供一个统一的数据管理入口会使得代码变得更容易管理和维护。</li><li>除了 .m 文件中方法，其他的地方”{“不需要另起一行。</li></ol><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)getGooodsList</span><br><span class="line">&#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)doHomework</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hungry) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.thirsty) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.tired) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    papapa.then.over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><ol><li>一个变量最好只有一个作用，切勿为了节省代码行数，觉得一个变量可以做多个用途。（单一原则）</li><li>方法内部如果有局部变量，那么局部变量应该靠近在使用的地方，而不是全部在顶部声明全部的局部变量。</li></ol><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><ol><li>1元运算符和变量之间不需要空格。例如：<code>++n</code></li><li>2元运算符与变量之间需要空格隔开。例如： <code>containerWidth = 0.3 * Screen_Width</code><br>当有多个运算符的时候需要使用括号来明确正确的顺序，可读性较好。例如：<code>2 &lt;&lt; (1 + 2 * 3 - 4)</code></li></ol><h1 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h1><ol><li><p>当有条件过多、过长的时候需要换行，为了代码看起来整齐些。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//good</span><br><span class="line">if (condition1() &amp;&amp; </span><br><span class="line">    condition2() &amp;&amp; </span><br><span class="line">    condition3() &amp;&amp; </span><br><span class="line">    condition4()) &#123;</span><br><span class="line">  // Do something</span><br><span class="line">&#125;</span><br><span class="line">//bad</span><br><span class="line">if (condition1() &amp;&amp; condition2() &amp;&amp; condition3() &amp;&amp; condition4(）) &#123; // Do something &#125;</span><br></pre></td></tr></table></figure></li><li><p>在一个代码块里面有个可能的情况时善于使用 return 来结束异常的情况。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)doHomework</span><br><span class="line">&#123;</span><br><span class="line">    if (self.hungry) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.thirsty) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (self.tired) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    papapa.then.over;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>每个分支的实现都必须使用 {} 包含。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">if (self.hungry) self.eat() </span><br><span class="line">// good</span><br><span class="line">if (self.hungry) &#123;</span><br><span class="line">    self.eat()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>条件判断的时候应该是变量在左，条件在右。 if ( currentCursor == 2 ) { //… }</p></li><li>switch 语句后面的每个分支都需要用大括号括起来。</li><li>switch 语句后面的 default 分支必须存在，除非是在对枚举进行 switch。<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">switch (menuType) &#123;  </span><br><span class="line">  case menuTypeLeft: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">   &#125;</span><br><span class="line">  case menuTypeRight: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">  case menuTypeTop: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">  case menuTypeBottom: &#123;</span><br><span class="line">    // ...  </span><br><span class="line">    break; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="类名"><a href="#类名" class="headerlink" title="类名"></a>类名</h1><ol><li>大写驼峰式命名。每个单词首字母大写。比如「申请记录控制器」ApplyRecordsViewController</li><li>每个类型的命名以该类型结尾。</li></ol><ul><li>ViewController：使用 ViewController 结尾。例子：ApplyRecordsViewController</li><li>View：使用 View 结尾。例子：分界线：boundaryView</li><li>NSArray：使用 s 结尾。比如商品分类数据源。categories</li><li>UITableViewCell：使用 Cell 结尾。比如 MyProfileCell</li><li>Protocol：使用 Delegate 或者 Datasource 结尾。比如 XQScanViewDelegate</li><li>Tool：工具类</li><li>代理类：Delegate</li><li>Service 类：Service</li></ul><h1 id="类的注释"><a href="#类的注释" class="headerlink" title="类的注释"></a>类的注释</h1><p>有时候我们需要为我们创建的类设置一些注释。我们可以在类的下面添加。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举的命名和类的命名相近。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">typedef NS_ENUM(NSInteger, UIControlContentVerticalAlignment) &#123;</span><br><span class="line">    UIControlContentVerticalAlignmentCenter  = 0,</span><br><span class="line">    UIControlContentVerticalAlignmentTop     = 1,</span><br><span class="line">    UIControlContentVerticalAlignmentBottom  = 2,</span><br><span class="line">    UIControlContentVerticalAlignmentFill    = 3,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h1 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h1><ol><li>全部大写，单词与单词之间用 _ 连接。</li><li>以 K 开头。后面遵循大写驼峰命名。「不带参数」<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define HOME_PAGE_DID_SCROLL @&quot;com.xq.home.page.tableview.did.scroll&quot;</span><br><span class="line">#define KHomePageDidScroll @&quot;com.xq.home.page.tableview.did.scroll&quot;</span><br></pre></td></tr></table></figure></li></ol><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><p>书写规则，基本上就是 @property 之后空一格，括号，里面的 线程修饰词、内存修饰词、读写修饰词，空一格 类 对象名称 根据不同的场景选择合适的修饰符。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@property (nonatomic, strong) UITableView *tableView;</span><br><span class="line">@property (nonatomic, assign, readonly) BOOL loading;   </span><br><span class="line">@property (nonatomic, weak) id&lt;#delegate#&gt; delegate;</span><br><span class="line">@property (nonatomic, copy) &lt;#returnType#&gt; (^&lt;#Block#&gt;)(&lt;#parType#&gt;);</span><br></pre></td></tr></table></figure></p><h1 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h1><p>单例适合全局管理状态或者事件的场景。一旦创建，对象的指针保存在静态区，单例对象在堆内存中分配的内存空间只有程序销毁的时候才会释放。基于这种特点，那么我们类似 UIApplication 对象，需要全局访问唯一一个对象的情况才适合单例，或者访问频次较高的情况。我们的功能模块的生命周期肯定小于 App 的生命周期，如果多个单例对象的话，势必 App 的开销会很大，糟糕的情况系统会杀死 App。如果觉得非要用单例比较好，那么注意需要在合适的场合 tearDown 掉。</p><p>单例的使用场景概括如下：</p><ul><li>控制资源的使用，通过线程同步来控制资源的并发访问。</li><li>控制实例的产生，以达到节约资源的目的。</li><li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信。</li></ul><h1 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h1><p>推荐以<code>_</code>开头，写在 .m 文件中。例如<code>NSString * _somePrivateVariable</code></p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ol><li>类的实例必须作为方法的参数之一。</li><li>对于一些连续的状态的，可以加一些 will（将要）、did（已经）</li><li>以类的名称开头<figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didEndDisplayingCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></li></ol><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>方法与方法之间间隔一行</li><li>大量的方法尽量要以组的形式放在一起，比如生命周期函数、公有方法、私有方法、setter &amp;&amp; getter、代理方法..</li><li>方法最后面的括号需要另起一行。遵循 Apple 的规范</li><li>对于其他场景的括号，括号不需要单独换行。比如 if 后面的括号。</li><li>如果方法参数过多过长，建议多行书写。用冒号进行对齐。</li><li>一个方法内的代码最好保持在50行以内，一般经验来看如果一个方法里面的代码行数过多，代码的阅读体验就很差（别问为什么，做过重构代码行数很长的人都有类似的心情）</li><li>一个函数只做一个事情，做到单一原则。所有的类、方法设计好后就可以类似搭积木一样实现一个系统。</li><li>对于有返回值的函数，且函数内有分支情况。确保每个分支都有返回值。</li><li>函数如果有多个参数，外部传入的参数需要检验参数的非空、数据类型的合法性，参数错误做一些措施：立即返回、断言。</li><li>多个函数如果有逻辑重复的代码，建议将重复的部分抽取出来，成为独立的函数进行调用</li><li><p>方法如果有多个参数的情况下需要注意是否需要介词和连词。很多时候在不知道如何抉择测时候思考下苹果的一些 API 的方法命名。</p><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//good</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age name:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView didSelectRowAtIndexPath:(NSIndexPath *)indexPath;</span><br><span class="line"></span><br><span class="line">//bad</span><br><span class="line">- (instancetype)initWithAge:(NSInteger)age andName:(NSString *)name;</span><br><span class="line"></span><br><span class="line">- (void)tableView:(UITableView *)tableView :(NSIndexPath *)indexPath;</span><br></pre></td></tr></table></figure></li><li><p>.m 文件中的私有方法需要在顶部进行声明 </p></li><li>方法组之间也有个顺序问题。</li></ol><ul><li>在文件最顶部实现属性的声明、私有方法的声明（很多人省去这一步，问题不大，但是蛮多第三方的库都写了，看起来还是会很方便，建议书写）。</li><li>在生命周期的方法里面，比如 viewDidLoad 里面只做界面的添加，而不是做界面的初始化，所有的 view 初始化建议放在 getter 里面去做。往往 view 的初始化的代码长度会比较长、且一般会有多个 view 所以 getter 和 setter 一般建议放在最下面，这样子顶部就可以很清楚的看到代码的主要逻辑。</li><li>所有button、gestureRecognizer 的响应事件都放在这个区域里面，不要到处乱放。</li></ul><p>文件基本上就是<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;ViewController.h&quot;</span><br><span class="line"></span><br><span class="line">/*ViewController*/</span><br><span class="line"></span><br><span class="line">/*View&amp;&amp;Util*/</span><br><span class="line"></span><br><span class="line">/*model*/</span><br><span class="line"></span><br><span class="line">/*NetWork InterFace*/</span><br><span class="line"></span><br><span class="line">/*Vender*/</span><br><span class="line"></span><br><span class="line">@interface ViewController ()</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ViewController</span><br><span class="line"></span><br><span class="line">#pragma mark - life cycle</span><br><span class="line"></span><br><span class="line">- (void)viewWillAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidAppear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidLoad];</span><br><span class="line">self.title = @&quot;标准模版&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewWillDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)viewDidDisappear:(BOOL)animated</span><br><span class="line">&#123;</span><br><span class="line">[super viewDidAppear:animated];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)dealloc</span><br><span class="line">&#123;</span><br><span class="line">NSLog(@&quot;%s&quot;,__func__);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#pragma mark - public Method</span><br><span class="line"></span><br><span class="line">#pragma mark - private method</span><br><span class="line"></span><br><span class="line">#pragma mark - event response</span><br><span class="line"></span><br><span class="line">#pragma mark - UITableViewDelegate</span><br><span class="line"></span><br><span class="line">#pragma mark - UITableViewDataSource</span><br><span class="line"></span><br><span class="line">//...(多个代理方法依次往下写)</span><br><span class="line"></span><br><span class="line">#pragma mark - getters and setters</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></p><h2 id="图片资源"><a href="#图片资源" class="headerlink" title="图片资源"></a>图片资源</h2><ol><li>单个文件的命名 文件资源的命名也需要一定的规范，形式为：<code>功能模块名_类别_功能_状态</code><br>@nx.png <a href="mailto:Setting_Button_search_selected@2x.png" target="_blank" rel="noopener">Setting_Button_search_selected@2x.png</a>、<a href="mailto:Setting_Button_search_selected@3x.png" target="_blank" rel="noopener">Setting_Button_search_selected@3x.png</a> <a href="mailto:Setting_Button_search_unselected@2x.png" target="_blank" rel="noopener">Setting_Button_search_unselected@2x.png</a>、<a href="mailto:Setting_Button_search_unselected@3x.png" target="_blank" rel="noopener">Setting_Button_search_unselected@3x.png</a></li><li>资源的文件夹命名 最好也参考 App 按照功能模块建立对应的实体文件夹目录，最后到对应的目录下添加相应的资源文件。</li></ol><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ol><li>对于类的注释写在当前类文件的顶部</li><li>对于属性的注释需要写在属性后面的地方。 <code>//**&lt;userId*/</code></li><li>对于 .h 文件中方法的注释，一律按快捷键 <code>command+option+/</code>。三个快捷键解决。按需在旁边对方法进行说明解释、返回值、参数的说明和解释 </li><li>对于 .m 文件中的方法的注释，在方法的旁边添加 //。 </li><li>注释符和注释内容需要间隔一个空格。 例如： // fetch goods list</li></ol><h2 id="版本规范"><a href="#版本规范" class="headerlink" title="版本规范"></a>版本规范</h2><p>采用 A.B.C 三位数字命名，比如：1.0.2，当有更新的情况下按照下面的依据</p><p>版本号示例<br>A.b.c属于重大内容的更新1.0.2 -&gt; 2.0.0<br>a.B.c属于小部分内容的更新1.0.2 -&gt; 1.1.1<br>a.b.C属于补丁更新1.0.2 -&gt; 1.0.3</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS 开发的代码规范。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="代码规范" scheme="https://objcvip.github.io/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="https://objcvip.github.io/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>【算法】用两个栈实现队列</title>
    <link href="https://objcvip.github.io/%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>https://objcvip.github.io/用两个栈实现队列/</id>
    <published>2018-03-06T07:47:00.000Z</published>
    <updated>2019-09-04T05:53:52.842Z</updated>
    
    <content type="html"><![CDATA[<p>用两个栈实现队列。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。<br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; class Queue</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">        CQueue(void);</span><br><span class="line">        ~CQueue(void);</span><br><span class="line">        void appendTail(const T&amp; node);</span><br><span class="line">        T deleteHead();</span><br><span class="line">private:</span><br><span class="line">        stack&lt;T&gt; stack1;</span><br><span class="line">        stack&lt;T&gt; stack2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; void CQueue&lt;T&gt;::appendTail(const T&amp; element)</span><br><span class="line">&#123;</span><br><span class="line">      stack1.push(element);</span><br><span class="line">&#125;</span><br><span class="line">template&lt;typename T&gt; T CQueue&lt;T&gt;::deleteHead()</span><br><span class="line">&#123;</span><br><span class="line">      if(stack2.size() &lt;= 0)</span><br><span class="line">      &#123;</span><br><span class="line">            while(stack1.size()&gt;0)</span><br><span class="line">            &#123;</span><br><span class="line">                  T&amp; data = stack1.top();</span><br><span class="line">                  stack1.pop();</span><br><span class="line">                  stack2.push(data);</span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      if(stack2.size() == 0)</span><br><span class="line">           throw new exception(&quot;queue is empty&quot;);</span><br><span class="line">      T head = stack2.top();</span><br><span class="line">      stack2.pop();</span><br><span class="line">      return head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用两个栈实现队列。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://objcvip.github.io/tags/%E6%A0%88/"/>
    
      <category term="队列" scheme="https://objcvip.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>【算法】用队列实现栈</title>
    <link href="https://objcvip.github.io/%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://objcvip.github.io/用队列实现栈/</id>
    <published>2018-03-05T07:47:00.000Z</published>
    <updated>2019-09-04T05:53:35.557Z</updated>
    
    <content type="html"><![CDATA[<p>用队列实现栈。<br><a id="more"></a><br>思路：每次取值要取队列的队尾元素，数据队列A出队到辅助队列B，留下最后一个元素返回，辅助队列再把元素出队到数据队列。<br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">MyStack</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> queueA: <span class="hljs-type">Queue</span></span><br><span class="line">    <span class="hljs-keyword">var</span> queueB: <span class="hljs-type">Queue</span></span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">init</span>() &#123;</span><br><span class="line">        queueA = <span class="hljs-type">Queue</span>()</span><br><span class="line">        queueB = <span class="hljs-type">Queue</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> isEmpty: <span class="hljs-type">Bool</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> queueA.isEmpty &amp;&amp; queueB.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">var</span> peek: <span class="hljs-type">Any</span>? &#123;</span><br><span class="line">        <span class="hljs-keyword">get</span> &#123;</span><br><span class="line">            shift()</span><br><span class="line">            <span class="hljs-keyword">let</span> peekObj = queueA.peek</span><br><span class="line">            queueB.enqueue(queueA.dequeue()!)</span><br><span class="line">            <span class="hljs-built_in">swap</span>()</span><br><span class="line">            <span class="hljs-keyword">return</span> peekObj</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-keyword">var</span> size: <span class="hljs-type">Int</span> &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> queueA.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(object: <span class="hljs-keyword">Any</span>)</span></span> &#123;</span><br><span class="line">        queueA.enqueue(object)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">Any</span>? &#123;</span><br><span class="line">        shift()</span><br><span class="line">        <span class="hljs-keyword">let</span> popObject = queueA.dequeue()</span><br><span class="line">        <span class="hljs-built_in">swap</span>()</span><br><span class="line">        <span class="hljs-keyword">return</span> popObject</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">shift</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        <span class="hljs-keyword">while</span> queueA.size != <span class="hljs-number">1</span> &#123;</span><br><span class="line">            queueB.enqueue(queueA.dequeue()!)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">()</span></span> &#123;</span><br><span class="line">        (queueA, queueB) = (queueB, queueA)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用队列实现栈。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】连续子数组的最大和</title>
    <link href="https://objcvip.github.io/%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/"/>
    <id>https://objcvip.github.io/连续子数组的最大和/</id>
    <published>2018-03-04T07:47:00.000Z</published>
    <updated>2019-09-04T05:53:06.229Z</updated>
    
    <content type="html"><![CDATA[<p>连续子数组的最大和。<br><a id="more"></a></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>输入一个整型数组，数组里有正数也有负数。数组中的一个或连续多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为 O(n)。<br>例如，输入的数组为{1, -2, 3, 10, -4, 7, 2, -5}，和最大的子数组为{3, 10, -4, 7, 2}，因此输出该子数组的和 18。</p><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">bool g_InvalidInput = false;</span><br><span class="line"></span><br><span class="line">int FindGreatestSumOfSubArray(int *pData, int nLength)</span><br><span class="line">&#123;</span><br><span class="line">    if(pData == nullptr) || (nLength &lt;= 0)</span><br><span class="line">    &#123;</span><br><span class="line">        g_InvalidInput = true;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    g_InvalidInput = false;</span><br><span class="line">    </span><br><span class="line">    int nCurSum = 0;</span><br><span class="line">    int nGreatestSum = 0x80000000;</span><br><span class="line">    for(int i = 0; i &lt; nLength; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if(nCurSum &lt;= 0)</span><br><span class="line">            nCurSum = pData[i];</span><br><span class="line">        else</span><br><span class="line">            nCurSum += pData[i];</span><br><span class="line">        if(nCurSum &gt; nGreatestSum)</span><br><span class="line">            nGreatestSum = nCurSum;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return nGreatestSum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;连续子数组的最大和。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>【算法】Swift 用数组实现栈</title>
    <link href="https://objcvip.github.io/Swift%E7%94%A8%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E6%A0%88/"/>
    <id>https://objcvip.github.io/Swift用数组实现栈/</id>
    <published>2018-03-03T07:47:00.000Z</published>
    <updated>2019-09-04T05:52:20.511Z</updated>
    
    <content type="html"><![CDATA[<p>用数组实现栈。<br><a id="more"></a><br><figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">var</span> stack: [<span class="hljs-type">AnyObject</span>]</span><br><span class="line">    <span class="hljs-keyword">var</span> isEmpty: <span class="hljs-type">Bool</span> &#123; <span class="hljs-keyword">return</span> stack.isEmpty &#125;</span><br><span class="line">    <span class="hljs-keyword">var</span> peek: <span class="hljs-type">AnyObject</span>? &#123; <span class="hljs-keyword">return</span> stack.last &#125;</span><br><span class="line">    </span><br><span class="line">    int() &#123;</span><br><span class="line">      stack = [<span class="hljs-type">AnyObject</span>]()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">push</span><span class="hljs-params">(object: AnyObject)</span></span> &#123;</span><br><span class="line">        stack.append(object)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span> -&gt; <span class="hljs-type">AnyObject</span>? &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (!isEmpty) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> stack.removeLast()</span><br><span class="line">        &#125;<span class="hljs-keyword">else</span> &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用数组实现栈。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="栈" scheme="https://objcvip.github.io/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>【算法】合并两个数组并去重</title>
    <link href="https://objcvip.github.io/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E5%B9%B6%E5%8E%BB%E9%87%8D/"/>
    <id>https://objcvip.github.io/合并两个数组并去重/</id>
    <published>2018-03-02T07:47:00.000Z</published>
    <updated>2019-09-04T05:52:20.611Z</updated>
    
    <content type="html"><![CDATA[<p>合并两个数组并去重。<br><a id="more"></a><br><figure class="highlight plain hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">// 合并两个含有nA、nB个元素的有序数组</span><br><span class="line">void Merge(int *a, int *b, int *c, int nA, int nB, int&amp; nCout)</span><br><span class="line">&#123;</span><br><span class="line">    int i = 0 ;</span><br><span class="line">    int j = 0 ;</span><br><span class="line">    int k = 0 ;</span><br><span class="line">     </span><br><span class="line">    while (i &lt; nA &amp;&amp; j &lt; nB)</span><br><span class="line">    &#123;</span><br><span class="line">        if (a[i] &lt; b[j])// 如果a的元素小，则插入a中元素到c</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = a[i] ;</span><br><span class="line">            ++i ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (a[i] == b[j])// 如果a和b元素相等，则插入二者皆可，这里插入a</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = a[i] ;</span><br><span class="line">            ++i ;</span><br><span class="line">            ++j ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">        else // a[i] &gt; b[j] // 如果b中元素小，则插入b中元素到c</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = b[j] ;</span><br><span class="line">            ++j ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    if (i == nA) // 若a遍历完毕，处理b中剩下的元素</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m = j; m &lt; nB; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = b[m] ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else//j == n, 若b遍历完毕，处理a中剩下的元素</span><br><span class="line">    &#123;</span><br><span class="line">        for (int m = i; m &lt; nA; ++m)</span><br><span class="line">        &#123;</span><br><span class="line">            c[k++] = a[m] ;</span><br><span class="line">            nCout++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;合并两个数组并去重。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://objcvip.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://objcvip.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
