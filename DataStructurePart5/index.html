<!DOCTYPE html>
<html  lang="zh">
<head>
    <meta charset="utf-8" />

<meta name="generator" content="Hexo 3.8.0" />

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

<title>《大话数据结构》五 - OBJC.VIP</title>


    <meta name="description" content="第6章 树树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&amp;gt;1 时，其余结点可分为 m（m&amp;gt;0）个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。">
<meta name="keywords" content="学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《大话数据结构》五">
<meta property="og:url" content="https://objcvip.github.io/DataStructurePart5/index.html">
<meta property="og:site_name" content="OBJC.VIP">
<meta property="og:description" content="第6章 树树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&amp;gt;1 时，其余结点可分为 m（m&amp;gt;0）个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://objcvip.github.io/images/og_image.png">
<meta property="og:updated_time" content="2019-09-16T08:59:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《大话数据结构》五">
<meta name="twitter:description" content="第6章 树树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&amp;gt;1 时，其余结点可分为 m（m&amp;gt;0）个互不相交的有限集 T1、T2、……、Tm，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。">
<meta name="twitter:image" content="https://objcvip.github.io/images/og_image.png">







<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    

    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-1-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                <img src="/images/logo.svg" alt="《大话数据结构》五" height="28">
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item"
                href="/">首页</a>
                
                <a class="navbar-item"
                href="/archives">归档</a>
                
                <a class="navbar-item"
                href="/categories">分类</a>
                
                <a class="navbar-item"
                href="/tags">标签</a>
                
                <a class="navbar-item"
                href="/links">友链</a>
                
                <a class="navbar-item"
                href="/about">关于</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="搜索" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-12 has-order-2 column-main"><div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <time class="level-item has-text-grey" datetime="2019-09-15T15:55:00.000Z">2019-09-15</time>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/《大话数据结构》/">《大话数据结构》</a>
                </div>
                
                
                <span class="level-item has-text-grey">
                    
                    
                    31 分钟 读完 (大约 4692 个字)
                </span>
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                《大话数据结构》五
            
        </h1>
        <div class="content">
            <h1 id="第6章-树"><a href="#第6章-树" class="headerlink" title="第6章 树"></a>第6章 树</h1><p>树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p>
<a id="more"></a>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><blockquote>
<p>树（Tree）是 n（n≥0）个结点的有限集。n=0 时称为空树。在任意一棵非空树中：（1）有且仅有一个特定的称为根（Root）的结点；（2）当 n&gt;1 时，其余结点可分为 m（m&gt;0）个互不相交的有限集 T<sub>1</sub>、T<sub>2</sub>、……、T<sub>m</sub>，其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）。</p>
</blockquote>
<h3 id="结点分类"><a href="#结点分类" class="headerlink" title="结点分类"></a>结点分类</h3><p>树的结点包含一个数据元素及若干指向其子树的分支。</p>
<p>结点拥有的子树数称为结点的度（Degree）。度为 0 的结点称为叶结点（Leaf）或终端结点；度不为 0 的结点称为非终端结点或分支结点。除根结点之外，分支结点也称为内部结点。树的度是树内各结点的度的最大值。</p>
<h3 id="结点间关系"><a href="#结点间关系" class="headerlink" title="结点间关系"></a>结点间关系</h3><p>结点的子树的根称为该结点的孩子（Child），相应的，该结点称为孩子的双亲（Parent）。同一个双亲的孩子之前互称兄弟（Sibling）。结点的祖先是从根到该结点所经分支上的所有结点。反之，以某结点为根的子树中的任一结点都称为该结点的子孙。</p>
<h3 id="树的其他相关概念"><a href="#树的其他相关概念" class="headerlink" title="树的其他相关概念"></a>树的其他相关概念</h3><p>结点的层次（Level）从根开始定义起，根为第一层，根的孩子为第二层。若某结点在第 1 层，则其子树的根就在第 i+1 层。其双亲在同一层的结点互为堂兄弟。树中结点的最大层次称为树的深度（Depth）或高度。</p>
<p>如果将树中结点的各子树看成从左至右是有次序的，不能互换的，则称该树为有序树，否则称为无序树。</p>
<p>森林（Forest）是 m（m≥0）棵互不相交的树的集合。</p>
<p>线性表与树结构</p>
<table>
<thead>
<tr>
<th style="text-align:center">线性结构</th>
<th style="text-align:center">树结构</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">第一个数据元素：无前驱</td>
<td style="text-align:center">根结点：无双亲，唯一</td>
</tr>
<tr>
<td style="text-align:center">最后一个数据元素：无后继</td>
<td style="text-align:center">叶结点：无孩子，可以多个</td>
</tr>
<tr>
<td style="text-align:center">中间元素：一个前驱一个后继</td>
<td style="text-align:center">中间结点：一个双亲多个孩子</td>
</tr>
</tbody>
</table>
<h2 id="树的抽象数据类型"><a href="#树的抽象数据类型" class="headerlink" title="树的抽象数据类型"></a>树的抽象数据类型</h2><p>ADT 树（tree）</p>
<p>Data</p>
<p>  树是由一个根结点和若干子树构成。树中结点具有相同数据类型及层次关系。</p>
<p>Operation</p>
<p>  InitTree(*T):构造空树 T。</p>
<p>  DestroyTree(*T):销毁树 T。</p>
<p>  CreateTree(*T, definition):按 definition 中给出树的定义来构造树。</p>
<p>  ClearTree(*T):若树 T 存在，则将树 T 清为空树。</p>
<p>  TreeEmpty(*T):若 T 为空树，返回 true，否则返回 false。</p>
<p>  TreeDepth(T):返回 T 的深度。</p>
<p>  Root(T):返回树的根结点。</p>
<p>  Value(T, cur_e):cur_e 是树 T 中一个结点，返回此结点的值。</p>
<p>  Assign(T, cur_e,value):给树 T 的结点 cur_e 赋值为 value。</p>
<p>  Parent(T, cur_e):若 cur_e 是树 T 的非根结点，则返回它的双亲，否则返回空。</p>
<p>  LeftChild(T, cur_e):若 cur_e 是树 T 的非叶结点，则返回它的最左孩子，否则返回空。</p>
<p>  RightSibling(T, cur_e):若 cur_e 有右兄弟，则返回它的右兄弟，否则返回空。</p>
<p>  InsertChild(<em>T, </em>p, i, c):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度加上1，非空树 c 与 T 不相交，操作结果为插入 c 为树 T 中 p 指结点的第 i 棵子树。</p>
<p>  DeleteChild(<em>T, </em>p, i):其中 p 指向树 T 的某个结点，i 为所指结点 p 的度，操作结果为删除 T 中 p 所指结点的第 i 棵子树。</p>
<p>endADT</p>
<h2 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h2><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p>我们假设以一组连续空间存储树的结点，同时在每个结点中，附设一个指示器表示其双亲结点在数组中的位置。也就是说，每个结点除了知道自己是谁以外，还知道它的双亲在哪里。</p>
<p>以下是我们的双亲表示法的结点结构定义代码。</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 树的双亲表示法结点结构定义 */</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">int</span> TElemType; <span class="hljs-comment">/* 树结点的数据类型，目前暂定为整型 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PTNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data; <span class="hljs-comment">/* 结点数据 */</span></span><br><span class="line">  <span class="hljs-keyword">int</span> parent; <span class="hljs-comment">/* 双亲位置 */</span></span><br><span class="line">&#125; PTNode;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>  /* 树结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  PTNode nodes[MAX_TREE_SIZE]; <span class="hljs-comment">/* 结点数组 */</span></span><br><span class="line">  <span class="hljs-keyword">int</span> r,n;  <span class="hljs-comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125; PTree</span><br></pre></td></tr></table></figure>
<p>存储结构的设计是一个非常灵活的过程。一个存储结构设计的是否合理，取决于基于该存储结构的运算是否合适、是否方便，时间复杂度好不好等。</p>
<h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p>由于树中每个结点可能有多棵子树，可以考虑用多重链表，即每个结点有多个指针域，其中每个指针指向一棵子树的根结点，我们把这种方法叫做多重链表表示法。</p>
<p>孩子表示法。把每个结点的孩子结点排列起来，以单链表作存储结构，则 n 个结点有 n 个孩子链表，如果是叶子结点则此单链表为空。然后 n 个头指针又组成一个线性表，采用顺序存储结构，放进一个一维数组中。</p>
<p>以下是我们的孩子表示法的结构定义代码。</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 树的孩子表示法结构定义 */</span></span><br><span class="line"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX_TREE_SIZE 100</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> /* 孩子结点 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  <span class="hljs-keyword">int</span> child;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CTNode</span> *<span class="hljs-title">next</span>;</span></span><br><span class="line">&#125; *ChildPtr;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /* 表头结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  ChildPtr firstchild;</span><br><span class="line">&#125; CTBox;</span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> /* 树结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  CTBox nodes[MAX_TREE_SIZE]; <span class="hljs-comment">/* 结点数组 */</span></span><br><span class="line">  <span class="hljs-keyword">int</span> r,n; <span class="hljs-comment">/* 根的位置和结点数 */</span></span><br><span class="line">&#125; CTree;</span><br></pre></td></tr></table></figure>
<h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p>任意一棵树，它的结点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，我们设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟。</p>
<p>结构定义代码如下。</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 树的孩子兄弟表示法结构定义 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span></span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">CSNode</span> *<span class="hljs-title">fistchild</span>,*<span class="hljs-title">rightsib</span>;</span></span><br><span class="line">&#125; CSNode, *CSTree;</span><br></pre></td></tr></table></figure>
<h2 id="二叉树的定义"><a href="#二叉树的定义" class="headerlink" title="二叉树的定义"></a>二叉树的定义</h2><p>二叉树（Binary Tree）是 n（n≥0）个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根结点和两棵互不相交的、分别称为根结点的左子树和右子树的二叉树组成。</p>
<h3 id="二叉树特点"><a href="#二叉树特点" class="headerlink" title="二叉树特点"></a>二叉树特点</h3><p>二叉树的特点有：</p>
<ul>
<li>每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者一棵子树都是可以的。</li>
<li>左子树和右子树是有顺序的，次序不能任意颠倒。</li>
<li>即使树中某个结点只有一棵子树，也要区分它是左子树还是右子树。</li>
</ul>
<p>二叉树具有五种基本形态：</p>
<ol>
<li>空二叉树。</li>
<li>只有一个根结点。</li>
<li>根结点只有左子树。</li>
<li>根结点只有右子树。</li>
<li>根结点既有左子树又有右子树。</li>
</ol>
<h3 id="特殊二叉树"><a href="#特殊二叉树" class="headerlink" title="特殊二叉树"></a>特殊二叉树</h3><h4 id="1-斜树"><a href="#1-斜树" class="headerlink" title="1. 斜树"></a>1. 斜树</h4><p>所有的结点都只有左子树的二叉树叫左斜树。所有结点都是只有右子树的二叉树叫右斜树。这两者统称为斜树。</p>
<h4 id="2-满二叉树"><a href="#2-满二叉树" class="headerlink" title="2. 满二叉树"></a>2. 满二叉树</h4><p>在一棵二叉树中，如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层，这样的二叉树称为满二叉树。</p>
<p>满二叉树的特点有：</p>
<p>（1）叶子只能出现在最下一层。</p>
<p>（2）非叶子结点的度一定是 2。</p>
<p>（3）在同样深度的二叉树中，满二叉树的结点个数最多，叶子树最多。</p>
<h4 id="3-完全二叉树"><a href="#3-完全二叉树" class="headerlink" title="3. 完全二叉树"></a>3. 完全二叉树</h4><p>对一棵具有 n 个结点的二叉树按层序编号，如果编号为 i（1≤i≤n）的结点与同样深度的满二叉树中编号为 i 的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>
<p>完全二叉树的特点：</p>
<p>（1）叶子结点只能出现在最下两层。</p>
<p>（2）最下层的叶子一定集中在左部连续位置。</p>
<p>（3）倒数二层，若有叶子结点，一定都在右部连续位置。</p>
<p>（4）如果结点度为1，则该结点只有左孩子，即不存在只有右子树的情况。</p>
<p>（5）同样结点的二叉树，完全二叉树的深度最小。</p>
<p>判断某个二叉树是否是完全二叉树的办法，就是看着树的示意图，心中默默给每个结点按照满二叉树的结构逐层顺序编号，如果编号出现空挡，就说明不是完全二叉树，否则就是。</p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><h3 id="二叉树的性质1"><a href="#二叉树的性质1" class="headerlink" title="二叉树的性质1"></a>二叉树的性质1</h3><p>性质1：在二叉树的第 i 层上至多有 2<sup>i-1</sup> 个结点（i≥1）。</p>
<h3 id="二叉树的性质2"><a href="#二叉树的性质2" class="headerlink" title="二叉树的性质2"></a>二叉树的性质2</h3><p>性质2：深度为 k 的二叉树至多有 2<sup>k</sup>-1 个结点（k≥1）。</p>
<h3 id="二叉树的性质3"><a href="#二叉树的性质3" class="headerlink" title="二叉树的性质3"></a>二叉树的性质3</h3><p>性质3：对任何一棵二叉树 T，如果其终端结点数为 n<sub>0</sub>，度为 2 的结点数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1。</p>
<h3 id="二叉树的性质4"><a href="#二叉树的性质4" class="headerlink" title="二叉树的性质4"></a>二叉树的性质4</h3><p>性质4：具有 n 个结点的完全二叉树的深度为 ⎣log<sub>2</sub>n⎦+1 ( ⎣x⎦表示不大于 x 的最大整数)。</p>
<p>注：⎣⎦ 向下取整运算。</p>
<h3 id="二叉树的性质5"><a href="#二叉树的性质5" class="headerlink" title="二叉树的性质5"></a>二叉树的性质5</h3><p>性质5：如果对于一棵有 n 个结点的完全二叉树（其深度为 ⎣log<sub>2</sub>n⎦+1）的结点按层序编号（从第 1 层到第 ⎣log<sub>2</sub>n⎦+1 层），每层从左到右，对任一结点 i （1≤i≤n）有：</p>
<ol>
<li>如果 i = 1，则结点 i 是二叉树的根，无双亲；如果 i&gt;1，则其双亲是结点 ⎣i/2⎦。</li>
<li>如果 2i&gt;n，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 2i。</li>
<li>如果 2i+1&gt;n，则结点 i 无右孩子；否则其右孩子是结点 2i+1。</li>
</ol>
<h2 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h2><h3 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h3><p>顺序存储结构一般只用于完全二叉树。</p>
<h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><p>二叉树每个结点最多有两个孩子，所以为它设计一个数据域和两个指针域是比较自然的想法，我们称这样的链表叫做二叉链表。</p>
<p>以下是我们的二叉链表的结点结构定义代码。</p>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的二叉链表结点结构定义 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BitNode</span> /* 结点结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data; <span class="hljs-comment">/* 结点数据 */</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiTNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">/* 左右孩子指针 */</span></span><br><span class="line">&#125; BiTNode, *BiTree;</span><br></pre></td></tr></table></figure>
<h2 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h2><h3 id="二叉树遍历原理"><a href="#二叉树遍历原理" class="headerlink" title="二叉树遍历原理"></a>二叉树遍历原理</h3><p>二叉树的遍历（traversing biary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅被访问一次。</p>
<h3 id="二叉树遍历方法"><a href="#二叉树遍历方法" class="headerlink" title="二叉树遍历方法"></a>二叉树遍历方法</h3><h4 id="1-前序遍历"><a href="#1-前序遍历" class="headerlink" title="1. 前序遍历"></a>1. 前序遍历</h4><p>规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树。</p>
<h4 id="2-中序遍历"><a href="#2-中序遍历" class="headerlink" title="2. 中序遍历"></a>2. 中序遍历</h4><p>规则是若树为空，则空操作返回，否则从根结点开始（注意不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树。</p>
<h4 id="3-后序遍历"><a href="#3-后序遍历" class="headerlink" title="3. 后序遍历"></a>3. 后序遍历</h4><p>规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点。</p>
<h4 id="4-层序遍历"><a href="#4-层序遍历" class="headerlink" title="4. 层序遍历"></a>4. 层序遍历</h4><p>规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问。</p>
<h3 id="前序遍历算法"><a href="#前序遍历算法" class="headerlink" title="前序遍历算法"></a>前序遍历算法</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的前序遍历递归算法 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PreOrderTraverse</span> <span class="hljs-params">(BiTree T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (T==<span class="hljs-literal">NULL</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data); <span class="hljs-comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">  PreOrderTraverse (T-&gt;lchild); <span class="hljs-comment">/* 再先序遍历左子树 */</span></span><br><span class="line">  PreOrderTraverse (T-&gt;rchild); <span class="hljs-comment">/* 最后先序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历算法"><a href="#中序遍历算法" class="headerlink" title="中序遍历算法"></a>中序遍历算法</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的中序遍历递归算法 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">InOrderTraverse</span> <span class="hljs-params">(BiTree T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (T==<span class="hljs-literal">NULL</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  InOrderTraverse (T-&gt;lchild); <span class="hljs-comment">/* 中序遍历左子树 */</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data); <span class="hljs-comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">  InOrderTraverse (T-&gt;rchild); <span class="hljs-comment">/* 最后中序遍历右子树 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历算法"><a href="#后序遍历算法" class="headerlink" title="后序遍历算法"></a>后序遍历算法</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的后序遍历递归算法 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">PostOrderTraverse</span> <span class="hljs-params">(BiTree T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (T==<span class="hljs-literal">NULL</span>)</span><br><span class="line">    <span class="hljs-keyword">return</span>;</span><br><span class="line">  PostOrderTraverse (T-&gt;lchild); <span class="hljs-comment">/* 先后序遍历左子树 */</span></span><br><span class="line">  PostOrderTraverse (T-&gt;rchild); <span class="hljs-comment">/* 再后序遍历右子树 */</span></span><br><span class="line">  <span class="hljs-built_in">printf</span>(<span class="hljs-string">"%c"</span>,T-&gt;data); <span class="hljs-comment">/* 显示结点数据，可以更改为其他对结点操作 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="推导遍历结果"><a href="#推导遍历结果" class="headerlink" title="推导遍历结果"></a>推导遍历结果</h3><ul>
<li>已知前序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知后序遍历序列和中序遍历序列，可以唯一确定一棵二叉树。</li>
<li>已知前序和后序遍历，是不能唯一确定一棵二叉树的。</li>
</ul>
<h2 id="二叉树的建立"><a href="#二叉树的建立" class="headerlink" title="二叉树的建立"></a>二叉树的建立</h2><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 按前序输入二叉树中结点的值（一个字符） */</span></span><br><span class="line"><span class="hljs-comment">/* #表示空树，构造二叉链表表示二叉树 T。 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">CreateBiTree</span> <span class="hljs-params">(BiTree *T)</span></span></span><br><span class="line"><span class="hljs-function"></span>&#123;</span><br><span class="line">  TElemType ch;</span><br><span class="line">  <span class="hljs-built_in">scanf</span>(<span class="hljs-string">"%c"</span>,&amp;ch);</span><br><span class="line">  <span class="hljs-keyword">if</span> (ch==<span class="hljs-string">'#'</span>)</span><br><span class="line">    *T=<span class="hljs-literal">NULL</span>;</span><br><span class="line">  <span class="hljs-keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    *T=(BiTree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(BiTNode));</span><br><span class="line">    <span class="hljs-keyword">if</span> (!*T)</span><br><span class="line">      <span class="hljs-built_in">exit</span> (OVERFLOW);</span><br><span class="line">    (*T)-&gt;data=ch; <span class="hljs-comment">/* 生成根结点 */</span></span><br><span class="line">    CreateBiTree(&amp;(*T)-&gt;lchild); <span class="hljs-comment">/* 构造左子树 */</span></span><br><span class="line">    CreateBiTree(&amp;(*T)-&gt;rchild); <span class="hljs-comment">/* 构造右子树 */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h2><h3 id="线索二叉树原理"><a href="#线索二叉树原理" class="headerlink" title="线索二叉树原理"></a>线索二叉树原理</h3><p>指向前驱和后继的指针称为线索，加上线索的二叉链表称为线索链表，相应的二叉树就称为线索二叉树（Threaded Binary Tree）。</p>
<p>对二叉树以某种次序遍历使其变为线索二叉树的过程叫做是线索化。</p>
<h3 id="线索二叉树结构实现"><a href="#线索二叉树结构实现" class="headerlink" title="线索二叉树结构实现"></a>线索二叉树结构实现</h3><figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment">/* 二叉树的二叉线索存储结构定义 */</span></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">enum</span> <span class="hljs-params">(Link, Thread)</span> PointerTag</span>; <span class="hljs-comment">/* Link==0 表示指向左右孩子指针 Thread==1 表示指向前驱或后继的线索 */</span></span><br><span class="line"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> /* 二叉线索存储结点结构 */</span></span><br><span class="line"><span class="hljs-class">&#123;</span></span><br><span class="line">  TElemType data; <span class="hljs-comment">/* 结点数据 */</span></span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">BiThrNode</span> *<span class="hljs-title">lchild</span>, *<span class="hljs-title">rchild</span>;</span> <span class="hljs-comment">/* 左右孩子指针 */</span></span><br><span class="line">  PointerTag LTag;</span><br><span class="line">  PointerTag RTag; <span class="hljs-comment">/* 左右标志 */</span></span><br><span class="line">&#125; BiThrNode, *BiThrTree;</span><br></pre></td></tr></table></figure>
<p>线索化的过程就是在遍历的过程中修改空指针的过程。</p>
<p>如果所用的二叉树需经常遍历或查找结点时需要某种遍历序列中的前驱和后继，那么采用线索二叉链表的存储结构就是非常不错的选择。</p>
<h2 id="树、森林与二叉树的转换"><a href="#树、森林与二叉树的转换" class="headerlink" title="树、森林与二叉树的转换"></a>树、森林与二叉树的转换</h2><h3 id="树转换为二叉树"><a href="#树转换为二叉树" class="headerlink" title="树转换为二叉树"></a>树转换为二叉树</h3><p>将树转换为二叉树的步骤如下</p>
<ol>
<li>加线。在所有兄弟结点之间加一条连线。</li>
<li>去线。对树中每个结点，只保留它与第一个孩子结点的连线，删除它与其他孩子结点之间的连线。</li>
<li>层次调整。以树的根结点为轴心，将整棵树顺时针旋转一定的角度，使之结构层次分明。注意第一个孩子是二叉树结点的左孩子，兄弟转换过来的孩子是结点的右孩子。</li>
</ol>
<h3 id="森林转换为二叉树"><a href="#森林转换为二叉树" class="headerlink" title="森林转换为二叉树"></a>森林转换为二叉树</h3><p>步骤如下：</p>
<ol>
<li>将每个树转换为二叉树。</li>
<li>第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子，用线连接起来。当所有的二叉树连接起来后就得到了由森林转换来的二叉树。</li>
</ol>
<h3 id="二叉树转换为树"><a href="#二叉树转换为树" class="headerlink" title="二叉树转换为树"></a>二叉树转换为树</h3><ol>
<li>加线。</li>
<li>去线。</li>
<li>层次调整。</li>
</ol>
<h3 id="二叉树转换为森林"><a href="#二叉树转换为森林" class="headerlink" title="二叉树转换为森林"></a>二叉树转换为森林</h3><ol>
<li>从根结点开始，若右孩子存在，则把右孩子结点的连线删除，再查看分离后的二叉树，若右孩子存在，则连线删除……，直到所有右孩子连线都删除为止，得到分离的二叉树。</li>
<li>再将每棵分离的二叉树转换为树即可。</li>
</ol>
<h3 id="树与森林的遍历"><a href="#树与森林的遍历" class="headerlink" title="树与森林的遍历"></a>树与森林的遍历</h3><p>树的遍历分为两种方式。</p>
<ol>
<li>一种是先根遍历树，即先访问树的根结点，然后依次先根遍历根的每棵子树。</li>
<li>另一种是后根遍历，即先依次后根遍历每棵子树，然后再访问根结点。</li>
</ol>
<p>森林的遍历也分为两种方式：</p>
<ol>
<li>前序遍历</li>
<li>后序遍历</li>
</ol>
<h2 id="赫夫曼树及其应用"><a href="#赫夫曼树及其应用" class="headerlink" title="赫夫曼树及其应用"></a>赫夫曼树及其应用</h2><h3 id="赫夫曼树定义与原理"><a href="#赫夫曼树定义与原理" class="headerlink" title="赫夫曼树定义与原理"></a>赫夫曼树定义与原理</h3><p>从树中一个结点到另一个结点之间的分支构成两个结点之间的路径，路径上的分支数目称做路径长度。</p>
<p>树的路径长度就是从树根到每一个结点的路径长度之和。</p>
<p>带权路径长度 WPL 最小的二叉树称做赫夫曼树。</p>
<h3 id="赫夫曼编码"><a href="#赫夫曼编码" class="headerlink" title="赫夫曼编码"></a>赫夫曼编码</h3><p>一般地，设需要编码的字符集为{d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub>}，各个字符在电文中出现的次数或频率集合为 {w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub>}，以 d<sub>1</sub>,d<sub>2</sub>,…,d<sub>n</sub> 作为叶子结点，以 w<sub>1</sub>,w<sub>2</sub>,…,w<sub>n</sub> 作为相应叶子结点的权值来构造一棵赫夫曼树。规定赫夫曼树的左分支代表 0，右分支代表 1，则从根结点到叶子结点所经过的路径分支组成的 0 和 1 的序列便为该结点对应字符的编码，这就是赫夫曼编码。</p>

        </div>
        
        <div class="level is-size-7 is-uppercase">
            <div class="level-start">
                <div class="level-item">
                    <span class="is-size-6 has-text-grey has-mr-7">#</span>
                    <a class="has-link-grey -link" href="/tags/学习笔记/">学习笔记</a>
                </div>
            </div>
        </div>
        
        
        
    </div>
</div>





<div class="card card-transparent">
    <div class="level post-navigation is-flex-wrap is-mobile">
        
        
        <div class="level-end">
            <a class="level level-item has-link-grey  article-nav-next" href="/DataStructurePart4/">
                <span class="level-item">《大话数据结构》四</span>
                <i class="level-item fas fa-chevron-right"></i>
            </a>
        </div>
        
    </div>
</div>



<div class="card">
    <div class="card-content">
        <h3 class="title is-5 has-text-weight-normal">评论</h3>
        
<div id="comment-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.min.js"></script>

<script>
    var gitalk = new Gitalk({
        clientID: '7cf9ae5a9ae4228f59ef',
        clientSecret: 'a60824892847d86dab15dae00b18a8227f9af769',
        id: 'bb8c31cafc90b0d8a2432d4f07a3ead0',
        repo: 'Comments',
        owner: 'objcvip',
        admin: "objcvip",
        createIssueManually: false,
        distractionFreeMode: true
    })
    gitalk.render('comment-container')
</script>

    </div>
</div>
</div>
                
                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    <img src="/images/logo.svg" alt="《大话数据结构》五" height="28">
                
                </a>
                <p class="is-size-7">
                &copy; 2020 ObjC.vip&nbsp;
                All rights reserved.
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("zh-CN");</script>

<script>
var IcarusThemeSettings = {
    article: {
        highlight: {
            clipboard: true,
            fold: 'unfolded'
        }
    }
};
</script>


    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>



    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="回到顶端" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="想要查找什么..." />
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: '文章',
                PAGES: '页面',
                CATEGORIES: '分类',
                TAGS: '标签',
                UNTITLED: '(无标题)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>